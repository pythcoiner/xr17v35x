commit e894b6005dce0ed621b2788d6a249708fb6f95f9
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Mar 4 14:27:04 2024 +0200

    serial: port: Introduce a common helper to read properties
    
    Several serial drivers want to read the same or similar set of
    the port properties. Make a common helper for them.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Link: https://lore.kernel.org/r/20240304123035.758700-4-andriy.shevchenko@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 3b64c9a26945..0a0f6e21d40e 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -963,6 +963,8 @@ int uart_register_driver(struct uart_driver *uart);
 void uart_unregister_driver(struct uart_driver *uart);
 int uart_add_one_port(struct uart_driver *reg, struct uart_port *port);
 void uart_remove_one_port(struct uart_driver *reg, struct uart_port *port);
+int uart_read_port_properties(struct uart_port *port);
+int uart_read_and_validate_port_properties(struct uart_port *port);
 bool uart_match_port(const struct uart_port *port1,
 		const struct uart_port *port2);
 

commit 79d713baf63c8f23cc58b304c40be33d64a12aaf
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Mar 4 14:27:03 2024 +0200

    serial: core: Add UPIO_UNKNOWN constant for unknown port type
    
    In some APIs we would like to assign the special value to iotype
    and compare against it in another places. Introduce UPIO_UNKNOWN
    for this purpose.
    
    Note, we can't use 0, because it's a valid value for IO port access.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Link: https://lore.kernel.org/r/20240304123035.758700-3-andriy.shevchenko@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index f9d7f0a625fd..3b64c9a26945 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -470,6 +470,7 @@ struct uart_port {
 
 	unsigned char		iotype;			/* io access style */
 
+#define UPIO_UNKNOWN		((unsigned char)~0U)	/* UCHAR_MAX */
 #define UPIO_PORT		(SERIAL_IO_PORT)	/* 8b I/O port access */
 #define UPIO_HUB6		(SERIAL_IO_HUB6)	/* Hub6 ISA card */
 #define UPIO_MEM		(SERIAL_IO_MEM)		/* driver-specific */

commit 35c822a34b2293aedf475238c395e75858d1e8c8
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Mon Mar 4 14:27:02 2024 +0200

    serial: core: Move struct uart_port::quirks closer to possible values
    
    Currently it's not crystal clear what UPIO_* and UPQ_* definitions
    belong to. Reindent the code, so it will be easy to read and understand.
    No functional changes intended.
    
    Reviewed-by: Andi Shyti <andi.shyti@linux.intel.com>
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Link: https://lore.kernel.org/r/20240304123035.758700-2-andriy.shevchenko@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index bb0f2d4ac62f..f9d7f0a625fd 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -467,8 +467,8 @@ struct uart_port {
 	unsigned int		fifosize;		/* tx fifo size */
 	unsigned char		x_char;			/* xon/xoff char */
 	unsigned char		regshift;		/* reg offset shift */
+
 	unsigned char		iotype;			/* io access style */
-	unsigned char		quirks;			/* internal quirks */
 
 #define UPIO_PORT		(SERIAL_IO_PORT)	/* 8b I/O port access */
 #define UPIO_HUB6		(SERIAL_IO_HUB6)	/* Hub6 ISA card */
@@ -479,7 +479,9 @@ struct uart_port {
 #define UPIO_MEM32BE		(SERIAL_IO_MEM32BE)	/* 32b big endian */
 #define UPIO_MEM16		(SERIAL_IO_MEM16)	/* 16b little endian */
 
-	/* quirks must be updated while holding port mutex */
+	unsigned char		quirks;			/* internal quirks */
+
+	/* internal quirks must be updated while holding port mutex */
 #define UPQ_NO_TXEN_TEST	BIT(0)
 
 	unsigned int		read_status_mask;	/* driver specific */

commit 7bfb915a597a301abb892f620fe5c283a9fdbd77
Author: Jonas Gorski <jonas.gorski@gmail.com>
Date:   Sun Mar 3 16:08:07 2024 +0100

    serial: core: only stop transmit when HW fifo is empty
    
    If the circular buffer is empty, it just means we fit all characters to
    send into the HW fifo, but not that the hardware finished transmitting
    them.
    
    So if we immediately call stop_tx() after that, this may abort any
    pending characters in the HW fifo, and cause dropped characters on the
    console.
    
    Fix this by only stopping tx when the tx HW fifo is actually empty.
    
    Fixes: 8275b48b2780 ("tty: serial: introduce transmit helpers")
    Cc: stable@vger.kernel.org
    Signed-off-by: Jonas Gorski <jonas.gorski@gmail.com>
    Link: https://lore.kernel.org/r/20240303150807.68117-1-jonas.gorski@gmail.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 55b1f3ba48ac..bb0f2d4ac62f 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -786,7 +786,8 @@ enum UART_TX_FLAGS {
 	if (pending < WAKEUP_CHARS) {					      \
 		uart_write_wakeup(__port);				      \
 									      \
-		if (!((flags) & UART_TX_NOSTOP) && pending == 0)	      \
+		if (!((flags) & UART_TX_NOSTOP) && pending == 0 &&	      \
+		    __port->ops->tx_empty(__port))			      \
 			__port->ops->stop_tx(__port);			      \
 	}								      \
 									      \

commit 3ee07964d407411fd578a3bc998de44fd64d266a
Author: Jiri Slaby (SUSE) <jirislaby@kernel.org>
Date:   Thu Feb 1 11:55:56 2024 +0100

    serial: core: introduce uart_port_tx_flags()
    
    And an enum with a flag: UART_TX_NOSTOP. To NOT call
    __port->ops->stop_tx() when the circular buffer is empty. mxs-uart needs
    this (see the next patch).
    
    Signed-off-by: "Jiri Slaby (SUSE)" <jirislaby@kernel.org>
    Cc: stable <stable@kernel.org>
    Tested-by: Emil Kronborg <emil.kronborg@protonmail.com>
    Link: https://lore.kernel.org/r/20240201105557.28043-1-jirislaby@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 536b2581d3e2..55b1f3ba48ac 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -748,8 +748,17 @@ struct uart_driver {
 
 void uart_write_wakeup(struct uart_port *port);
 
-#define __uart_port_tx(uport, ch, tx_ready, put_char, tx_done, for_test,      \
-		for_post)						      \
+/**
+ * enum UART_TX_FLAGS -- flags for uart_port_tx_flags()
+ *
+ * @UART_TX_NOSTOP: don't call port->ops->stop_tx() on empty buffer
+ */
+enum UART_TX_FLAGS {
+	UART_TX_NOSTOP = BIT(0),
+};
+
+#define __uart_port_tx(uport, ch, flags, tx_ready, put_char, tx_done,	      \
+		       for_test, for_post)				      \
 ({									      \
 	struct uart_port *__port = (uport);				      \
 	struct circ_buf *xmit = &__port->state->xmit;			      \
@@ -777,7 +786,7 @@ void uart_write_wakeup(struct uart_port *port);
 	if (pending < WAKEUP_CHARS) {					      \
 		uart_write_wakeup(__port);				      \
 									      \
-		if (pending == 0)					      \
+		if (!((flags) & UART_TX_NOSTOP) && pending == 0)	      \
 			__port->ops->stop_tx(__port);			      \
 	}								      \
 									      \
@@ -812,7 +821,7 @@ void uart_write_wakeup(struct uart_port *port);
  */
 #define uart_port_tx_limited(port, ch, count, tx_ready, put_char, tx_done) ({ \
 	unsigned int __count = (count);					      \
-	__uart_port_tx(port, ch, tx_ready, put_char, tx_done, __count,	      \
+	__uart_port_tx(port, ch, 0, tx_ready, put_char, tx_done, __count,     \
 			__count--);					      \
 })
 
@@ -826,8 +835,21 @@ void uart_write_wakeup(struct uart_port *port);
  * See uart_port_tx_limited() for more details.
  */
 #define uart_port_tx(port, ch, tx_ready, put_char)			\
-	__uart_port_tx(port, ch, tx_ready, put_char, ({}), true, ({}))
+	__uart_port_tx(port, ch, 0, tx_ready, put_char, ({}), true, ({}))
+
 
+/**
+ * uart_port_tx_flags -- transmit helper for uart_port with flags
+ * @port: uart port
+ * @ch: variable to store a character to be written to the HW
+ * @flags: %UART_TX_NOSTOP or similar
+ * @tx_ready: can HW accept more data function
+ * @put_char: function to write a character
+ *
+ * See uart_port_tx_limited() for more details.
+ */
+#define uart_port_tx_flags(port, ch, flags, tx_ready, put_char)		\
+	__uart_port_tx(port, ch, flags, tx_ready, put_char, ({}), true, ({}))
 /*
  * Baud rate helpers.
  */

commit cb86a3383aa7b9bb891daca691e596f6bfe52d82
Author: Vamshi Gajjela <vamshigajjela@google.com>
Date:   Thu Nov 9 12:04:16 2023 +0530

    serial: core: Update uart_poll_timeout() function to return unsigned long
    
    The function uart_fifo_timeout() returns an unsigned long value, which
    is the number of jiffies. Therefore, change the variable timeout in the
    function uart_poll_timeout() from int to unsigned long.
    Change the return type of the function uart_poll_timeout() from int to
    unsigned long to be consistent with the type of timeout values.
    
    Signed-off-by: Vamshi Gajjela <vamshigajjela@google.com>
    Link: https://lore.kernel.org/r/20231109063417.3971005-2-vamshigajjela@google.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 89f7b6c63598..536b2581d3e2 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -852,9 +852,9 @@ static inline unsigned long uart_fifo_timeout(struct uart_port *port)
 }
 
 /* Base timer interval for polling */
-static inline int uart_poll_timeout(struct uart_port *port)
+static inline unsigned long uart_poll_timeout(struct uart_port *port)
 {
-	int timeout = uart_fifo_timeout(port);
+	unsigned long timeout = uart_fifo_timeout(port);
 
 	return timeout > 6 ? (timeout / 2 - 2) : 1;
 }

commit 29bff582b74ed0bdb7e6986482ad9e6799ea4d2f
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Tue Sep 26 21:41:28 2023 -0700

    serial: core: fix kernel-doc for uart_port_unlock_irqrestore()
    
    Fix the function name to avoid a kernel-doc warning:
    
    include/linux/serial_core.h:666: warning: expecting prototype for uart_port_lock_irqrestore(). Prototype was for uart_port_unlock_irqrestore() instead
    
    Fixes: b0af4bcb4946 ("serial: core: Provide port lock wrappers")
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: John Ogness <john.ogness@linutronix.de>
    Cc: linux-serial@vger.kernel.org
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Jiri Slaby <jirislaby@kernel.org>
    Reviewed-by: John Ogness <john.ogness@linutronix.de>
    Link: https://lore.kernel.org/r/20230927044128.4748-1-rdunlap@infradead.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 3091c62ec37b..89f7b6c63598 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -658,7 +658,7 @@ static inline void uart_port_unlock_irq(struct uart_port *up)
 }
 
 /**
- * uart_port_lock_irqrestore - Unlock the UART port, restore interrupts
+ * uart_port_unlock_irqrestore - Unlock the UART port, restore interrupts
  * @up:		Pointer to UART port structure
  * @flags:	The saved interrupt flags for restore
  */

commit c5cbdb76e8e33ce90fec2946e8eee7d71d68e57a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Sep 14 20:43:19 2023 +0206

    serial: core: Use lock wrappers
    
    When a serial port is used for kernel console output, then all
    modifications to the UART registers which are done from other contexts,
    e.g. getty, termios, are interference points for the kernel console.
    
    So far this has been ignored and the printk output is based on the
    principle of hope. The rework of the console infrastructure which aims to
    support threaded and atomic consoles, requires to mark sections which
    modify the UART registers as unsafe. This allows the atomic write function
    to make informed decisions and eventually to restore operational state. It
    also allows to prevent the regular UART code from modifying UART registers
    while printk output is in progress.
    
    All modifications of UART registers are guarded by the UART port lock,
    which provides an obvious synchronization point with the console
    infrastructure.
    
    To avoid adding this functionality to all UART drivers, wrap the
    spin_[un]lock*() invocations for uart_port::lock into helper functions
    which just contain the spin_[un]lock*() invocations for now. In a
    subsequent step these helpers will gain the console synchronization
    mechanisms.
    
    Converted with coccinelle. No functional change.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
    Signed-off-by: John Ogness <john.ogness@linutronix.de>
    Link: https://lore.kernel.org/r/20230914183831.587273-3-john.ogness@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index f1d5c0d1568c..3091c62ec37b 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -1035,14 +1035,14 @@ static inline void uart_unlock_and_check_sysrq(struct uart_port *port)
 	u8 sysrq_ch;
 
 	if (!port->has_sysrq) {
-		spin_unlock(&port->lock);
+		uart_port_unlock(port);
 		return;
 	}
 
 	sysrq_ch = port->sysrq_ch;
 	port->sysrq_ch = 0;
 
-	spin_unlock(&port->lock);
+	uart_port_unlock(port);
 
 	if (sysrq_ch)
 		handle_sysrq(sysrq_ch);
@@ -1054,14 +1054,14 @@ static inline void uart_unlock_and_check_sysrq_irqrestore(struct uart_port *port
 	u8 sysrq_ch;
 
 	if (!port->has_sysrq) {
-		spin_unlock_irqrestore(&port->lock, flags);
+		uart_port_unlock_irqrestore(port, flags);
 		return;
 	}
 
 	sysrq_ch = port->sysrq_ch;
 	port->sysrq_ch = 0;
 
-	spin_unlock_irqrestore(&port->lock, flags);
+	uart_port_unlock_irqrestore(port, flags);
 
 	if (sysrq_ch)
 		handle_sysrq(sysrq_ch);
@@ -1077,12 +1077,12 @@ static inline int uart_prepare_sysrq_char(struct uart_port *port, u8 ch)
 }
 static inline void uart_unlock_and_check_sysrq(struct uart_port *port)
 {
-	spin_unlock(&port->lock);
+	uart_port_unlock(port);
 }
 static inline void uart_unlock_and_check_sysrq_irqrestore(struct uart_port *port,
 		unsigned long flags)
 {
-	spin_unlock_irqrestore(&port->lock, flags);
+	uart_port_unlock_irqrestore(port, flags);
 }
 #endif	/* CONFIG_MAGIC_SYSRQ_SERIAL */
 

commit b0af4bcb49464c221ad5f95d40f2b1b252ceedcc
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Sep 14 20:43:18 2023 +0206

    serial: core: Provide port lock wrappers
    
    When a serial port is used for kernel console output, then all
    modifications to the UART registers which are done from other contexts,
    e.g. getty, termios, are interference points for the kernel console.
    
    So far this has been ignored and the printk output is based on the
    principle of hope. The rework of the console infrastructure which aims to
    support threaded and atomic consoles, requires to mark sections which
    modify the UART registers as unsafe. This allows the atomic write function
    to make informed decisions and eventually to restore operational state. It
    also allows to prevent the regular UART code from modifying UART registers
    while printk output is in progress.
    
    All modifications of UART registers are guarded by the UART port lock,
    which provides an obvious synchronization point with the console
    infrastructure.
    
    Provide wrapper functions for spin_[un]lock*(port->lock) invocations so
    that the console mechanics can be applied later on at a single place and
    does not require to copy the same logic all over the drivers.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
    Signed-off-by: John Ogness <john.ogness@linutronix.de>
    Link: https://lore.kernel.org/r/20230914183831.587273-2-john.ogness@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index bb6f073bc159..f1d5c0d1568c 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -588,6 +588,85 @@ struct uart_port {
 	void			*private_data;		/* generic platform data pointer */
 };
 
+/**
+ * uart_port_lock - Lock the UART port
+ * @up:		Pointer to UART port structure
+ */
+static inline void uart_port_lock(struct uart_port *up)
+{
+	spin_lock(&up->lock);
+}
+
+/**
+ * uart_port_lock_irq - Lock the UART port and disable interrupts
+ * @up:		Pointer to UART port structure
+ */
+static inline void uart_port_lock_irq(struct uart_port *up)
+{
+	spin_lock_irq(&up->lock);
+}
+
+/**
+ * uart_port_lock_irqsave - Lock the UART port, save and disable interrupts
+ * @up:		Pointer to UART port structure
+ * @flags:	Pointer to interrupt flags storage
+ */
+static inline void uart_port_lock_irqsave(struct uart_port *up, unsigned long *flags)
+{
+	spin_lock_irqsave(&up->lock, *flags);
+}
+
+/**
+ * uart_port_trylock - Try to lock the UART port
+ * @up:		Pointer to UART port structure
+ *
+ * Returns: True if lock was acquired, false otherwise
+ */
+static inline bool uart_port_trylock(struct uart_port *up)
+{
+	return spin_trylock(&up->lock);
+}
+
+/**
+ * uart_port_trylock_irqsave - Try to lock the UART port, save and disable interrupts
+ * @up:		Pointer to UART port structure
+ * @flags:	Pointer to interrupt flags storage
+ *
+ * Returns: True if lock was acquired, false otherwise
+ */
+static inline bool uart_port_trylock_irqsave(struct uart_port *up, unsigned long *flags)
+{
+	return spin_trylock_irqsave(&up->lock, *flags);
+}
+
+/**
+ * uart_port_unlock - Unlock the UART port
+ * @up:		Pointer to UART port structure
+ */
+static inline void uart_port_unlock(struct uart_port *up)
+{
+	spin_unlock(&up->lock);
+}
+
+/**
+ * uart_port_unlock_irq - Unlock the UART port and re-enable interrupts
+ * @up:		Pointer to UART port structure
+ */
+static inline void uart_port_unlock_irq(struct uart_port *up)
+{
+	spin_unlock_irq(&up->lock);
+}
+
+/**
+ * uart_port_lock_irqrestore - Unlock the UART port, restore interrupts
+ * @up:		Pointer to UART port structure
+ * @flags:	The saved interrupt flags for restore
+ */
+static inline void uart_port_unlock_irqrestore(struct uart_port *up, unsigned long flags)
+{
+	spin_unlock_irqrestore(&up->lock, flags);
+}
+
 static inline int serial_port_in(struct uart_port *up, int offset)
 {
 	return up->serial_in(up, offset);

commit 642073c306e66daca108cb630d169129e50a6ba3
Merge: e67d7f60d238 b320441c04c9
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Aug 20 14:29:37 2023 +0200

    Merge commit b320441c04c9 ("Merge tag 'tty-6.5-rc7' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty") into tty-next
    
    We need the serial-core fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit d962de6ae51f9b76ad736220077cda83084090b1
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Jul 25 08:42:11 2023 +0300

    serial: core: Fix serial core port id to not use port->line
    
    The serial core port id should be serial core controller specific port
    instance, which is not always the port->line index.
    
    For example, 8250 driver maps a number of legacy ports, and when a
    hardware specific device driver takes over, we typically have one
    driver instance for each port. Let's instead add port->port_id to
    keep track serial ports mapped to each serial core controller instance.
    
    Currently this is only a cosmetic issue for the serial core port device
    names. The issue can be noticed looking at /sys/bus/serial-base/devices
    for example though. Let's fix the issue to avoid port addressing issues
    later on.
    
    Fixes: 84a9582fd203 ("serial: core: Start managing serial controllers to enable runtime PM")
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Link: https://lore.kernel.org/r/20230725054216.45696-3-tony@atomide.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 201813d888df..a156d2ed8d9e 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -460,6 +460,7 @@ struct uart_port {
 	int			(*iso7816_config)(struct uart_port *,
 						  struct serial_iso7816 *iso7816);
 	unsigned int		ctrl_id;		/* optional serial core controller id */
+	unsigned int		port_id;		/* optional serial core port id */
 	unsigned int		irq;			/* irq number */
 	unsigned long		irqflags;		/* irq flags  */
 	unsigned int		uartclk;		/* base uart clock */

commit 83c35180abfdfb22f3d7703b0c85ad2d442ed2c5
Author: Tony Lindgren <tony@atomide.com>
Date:   Tue Jul 25 08:42:10 2023 +0300

    serial: core: Controller id cannot be negative
    
    The controller id cannot be negative. Let's fix the ctrl_id in preparation
    for adding port_id to fix the device name.
    
    Fixes: 84a9582fd203 ("serial: core: Start managing serial controllers to enable runtime PM")
    Reported-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Link: https://lore.kernel.org/r/20230725054216.45696-2-tony@atomide.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 6d58c57acdaa..201813d888df 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -459,7 +459,7 @@ struct uart_port {
 						struct serial_rs485 *rs485);
 	int			(*iso7816_config)(struct uart_port *,
 						  struct serial_iso7816 *iso7816);
-	int			ctrl_id;		/* optional serial core controller id */
+	unsigned int		ctrl_id;		/* optional serial core controller id */
 	unsigned int		irq;			/* irq number */
 	unsigned long		irqflags;		/* irq flags  */
 	unsigned int		uartclk;		/* base uart clock */

commit df007fa02560435f7ffbc62147cc0084f8241899
Author: Jiri Slaby <jirislaby@kernel.org>
Date:   Wed Jul 12 10:18:07 2023 +0200

    serial: make uart_insert_char() accept u8s
    
    Both the character and flag are 8-bit values. So switch from unsigned
    ints to u8s. The drivers will be cleaned up in the next round.
    
    Signed-off-by: Jiri Slaby (SUSE) <jirislaby@kernel.org>
    Link: https://lore.kernel.org/r/20230712081811.29004-7-jirislaby@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 14dd85ee849e..105d2cdc0126 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -903,7 +903,7 @@ void uart_handle_dcd_change(struct uart_port *uport, bool active);
 void uart_handle_cts_change(struct uart_port *uport, bool active);
 
 void uart_insert_char(struct uart_port *port, unsigned int status,
-		      unsigned int overrun, unsigned int ch, unsigned int flag);
+		      unsigned int overrun, u8 ch, u8 flag);
 
 void uart_xchar_out(struct uart_port *uport, int offset);
 

commit 12ae2359eb2f1b880863b266a2e72f65f043eacd
Author: Jiri Slaby <jirislaby@kernel.org>
Date:   Wed Jul 12 10:18:06 2023 +0200

    serial: convert uart sysrq handling to u8
    
    Propagate u8 from the sysrq code further up to serial's
    uart_handle_sysrq_char() and friends.
    
    Signed-off-by: Jiri Slaby (SUSE) <jirislaby@kernel.org>
    Link: https://lore.kernel.org/r/20230712081811.29004-6-jirislaby@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 6d58c57acdaa..14dd85ee849e 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -569,7 +569,7 @@ struct uart_port {
 	struct serial_port_device *port_dev;		/* serial core port device */
 
 	unsigned long		sysrq;			/* sysrq timeout */
-	unsigned int		sysrq_ch;		/* char for sysrq */
+	u8			sysrq_ch;		/* char for sysrq */
 	unsigned char		has_sysrq;
 	unsigned char		sysrq_seq;		/* index in sysrq_toggle_seq */
 
@@ -910,9 +910,9 @@ void uart_xchar_out(struct uart_port *uport, int offset);
 #ifdef CONFIG_MAGIC_SYSRQ_SERIAL
 #define SYSRQ_TIMEOUT	(HZ * 5)
 
-bool uart_try_toggle_sysrq(struct uart_port *port, unsigned int ch);
+bool uart_try_toggle_sysrq(struct uart_port *port, u8 ch);
 
-static inline int uart_handle_sysrq_char(struct uart_port *port, unsigned int ch)
+static inline int uart_handle_sysrq_char(struct uart_port *port, u8 ch)
 {
 	if (!port->sysrq)
 		return 0;
@@ -931,7 +931,7 @@ static inline int uart_handle_sysrq_char(struct uart_port *port, unsigned int ch
 	return 0;
 }
 
-static inline int uart_prepare_sysrq_char(struct uart_port *port, unsigned int ch)
+static inline int uart_prepare_sysrq_char(struct uart_port *port, u8 ch)
 {
 	if (!port->sysrq)
 		return 0;
@@ -952,7 +952,7 @@ static inline int uart_prepare_sysrq_char(struct uart_port *port, unsigned int c
 
 static inline void uart_unlock_and_check_sysrq(struct uart_port *port)
 {
-	int sysrq_ch;
+	u8 sysrq_ch;
 
 	if (!port->has_sysrq) {
 		spin_unlock(&port->lock);
@@ -971,7 +971,7 @@ static inline void uart_unlock_and_check_sysrq(struct uart_port *port)
 static inline void uart_unlock_and_check_sysrq_irqrestore(struct uart_port *port,
 		unsigned long flags)
 {
-	int sysrq_ch;
+	u8 sysrq_ch;
 
 	if (!port->has_sysrq) {
 		spin_unlock_irqrestore(&port->lock, flags);
@@ -987,11 +987,11 @@ static inline void uart_unlock_and_check_sysrq_irqrestore(struct uart_port *port
 		handle_sysrq(sysrq_ch);
 }
 #else	/* CONFIG_MAGIC_SYSRQ_SERIAL */
-static inline int uart_handle_sysrq_char(struct uart_port *port, unsigned int ch)
+static inline int uart_handle_sysrq_char(struct uart_port *port, u8 ch)
 {
 	return 0;
 }
-static inline int uart_prepare_sysrq_char(struct uart_port *port, unsigned int ch)
+static inline int uart_prepare_sysrq_char(struct uart_port *port, u8 ch)
 {
 	return 0;
 }

commit 84a9582fd203063cd4d301204971ff2cd8327f1a
Author: Tony Lindgren <tony@atomide.com>
Date:   Thu May 25 14:30:30 2023 +0300

    serial: core: Start managing serial controllers to enable runtime PM
    
    We want to enable runtime PM for serial port device drivers in a generic
    way. To do this, we want to have the serial core layer manage the
    registered physical serial controller devices.
    
    To manage serial controllers, let's set up a struct bus and struct device
    for the serial core controller as suggested by Greg and Jiri. The serial
    core controller devices are children of the physical serial port device.
    The serial core controller device is needed to support multiple different
    kind of ports connected to single physical serial port device.
    
    Let's also set up a struct device for the serial core port. The serial
    core port instances are children of the serial core controller device.
    
    With the serial core port device we can now flush pending TX on the
    runtime PM resume as suggested by Johan.
    
    Suggested-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Suggested-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Suggested-by: Jiri Slaby <jirislaby@kernel.org>
    Suggested-by: Johan Hovold <johan@kernel.org>
    Signed-off-by: Tony Lindgren <tony@atomide.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Link: https://lore.kernel.org/r/20230525113034.46880-1-tony@atomide.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index ddcdb5b8523e..6d58c57acdaa 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -28,6 +28,7 @@
 
 struct uart_port;
 struct serial_struct;
+struct serial_port_device;
 struct device;
 struct gpio_desc;
 
@@ -458,6 +459,7 @@ struct uart_port {
 						struct serial_rs485 *rs485);
 	int			(*iso7816_config)(struct uart_port *,
 						  struct serial_iso7816 *iso7816);
+	int			ctrl_id;		/* optional serial core controller id */
 	unsigned int		irq;			/* irq number */
 	unsigned long		irqflags;		/* irq flags  */
 	unsigned int		uartclk;		/* base uart clock */
@@ -563,7 +565,8 @@ struct uart_port {
 	unsigned int		minor;
 	resource_size_t		mapbase;		/* for ioremap */
 	resource_size_t		mapsize;
-	struct device		*dev;			/* parent device */
+	struct device		*dev;			/* serial port physical parent device */
+	struct serial_port_device *port_dev;		/* serial core port device */
 
 	unsigned long		sysrq;			/* sysrq timeout */
 	unsigned int		sysrq_ch;		/* char for sysrq */

commit d5b3d02d0b107345f2a6ecb5b06f98356f5c97ab
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Fri May 12 19:38:10 2023 +0200

    serial: Make uart_remove_one_port() return void
    
    The return value is only ever used as a return value for remove callbacks
    of platform drivers. This return value is ignored by the driver core.
    (The only effect is an error message, but uart_remove_one_port() already
    emitted one in this case.)
    
    So the return value isn't used at all and uart_remove_one_port() can be
    changed to return void without any loss. Also this better matches the
    Linux device model as remove functions are not supposed to fail.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Link: https://lore.kernel.org/r/20230512173810.131447-3-u.kleine-koenig@pengutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 66ecec15a1bf..ddcdb5b8523e 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -853,7 +853,7 @@ void uart_console_write(struct uart_port *port, const char *s,
 int uart_register_driver(struct uart_driver *uart);
 void uart_unregister_driver(struct uart_driver *uart);
 int uart_add_one_port(struct uart_driver *reg, struct uart_port *port);
-int uart_remove_one_port(struct uart_driver *reg, struct uart_port *port);
+void uart_remove_one_port(struct uart_driver *reg, struct uart_port *port);
 bool uart_match_port(const struct uart_port *port1,
 		const struct uart_port *port2);
 

commit b5def43a7b3e7e68d6b49a23166f8b886a26bb54
Author: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
Date:   Thu Mar 9 10:09:21 2023 +0200

    serial: Make hw_stopped bool
    
    Convert hw_stopped in uart_port to bool because its more appropriate
    type for how it is used.
    
    Also convert the local variable in uart_change_line_settings() caching
    old hw_stopped to bool.
    
    Signed-off-by: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
    Link: https://lore.kernel.org/r/20230309080923.11778-7-ilpo.jarvinen@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 05d18a145b3a..66ecec15a1bf 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -553,7 +553,7 @@ struct uart_port {
 #define UPSTAT_AUTOXOFF		((__force upstat_t) (1 << 4))
 #define UPSTAT_SYNC_FIFO	((__force upstat_t) (1 << 5))
 
-	int			hw_stopped;		/* sw-assisted CTS flow state */
+	bool			hw_stopped;		/* sw-assisted CTS flow state */
 	unsigned int		mctrl;			/* current modem ctrl settings */
 	unsigned int		frame_time;		/* frame timing in ns */
 	unsigned int		type;			/* port type */

commit 6229ad9913ac794233fdb3ed20f1e899add0af6b
Author: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
Date:   Thu Mar 9 10:09:18 2023 +0200

    serial: Remove extern from func prototypes in headers
    
    Remove unnecessary externs from function prototypes in serial_8250.h
    and serial_core.h.
    
    Suggested-by: Jiri Slaby <jirislaby@kernel.org>
    Signed-off-by: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
    Link: https://lore.kernel.org/r/20230309080923.11778-4-ilpo.jarvinen@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 9e3e5e0d11b2..05d18a145b3a 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -812,9 +812,8 @@ extern const struct earlycon_id __earlycon_table_end[];
 
 #define EARLYCON_DECLARE(_name, fn)	OF_EARLYCON_DECLARE(_name, "", fn)
 
-extern int of_setup_earlycon(const struct earlycon_id *match,
-			     unsigned long node,
-			     const char *options);
+int of_setup_earlycon(const struct earlycon_id *match, unsigned long node,
+		      const char *options);
 
 #ifdef CONFIG_SERIAL_EARLYCON
 extern bool earlycon_acpi_spcr_enable __initdata;
@@ -897,11 +896,11 @@ static inline bool uart_softcts_mode(struct uart_port *uport)
  * The following are helper functions for the low level drivers.
  */
 
-extern void uart_handle_dcd_change(struct uart_port *uport, bool active);
-extern void uart_handle_cts_change(struct uart_port *uport, bool active);
+void uart_handle_dcd_change(struct uart_port *uport, bool active);
+void uart_handle_cts_change(struct uart_port *uport, bool active);
 
-extern void uart_insert_char(struct uart_port *port, unsigned int status,
-		 unsigned int overrun, unsigned int ch, unsigned int flag);
+void uart_insert_char(struct uart_port *port, unsigned int status,
+		      unsigned int overrun, unsigned int ch, unsigned int flag);
 
 void uart_xchar_out(struct uart_port *uport, int offset);
 

commit 968d64578ec92968e8c79d766eb966efd1f68d7e
Author: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
Date:   Tue Jan 17 11:03:55 2023 +0200

    serial: Make uart_handle_cts_change() status param bool active
    
    Convert uart_handle_cts_change() to bool which is more appropriate
    than unsigned int.
    
    Rename status to active to better describe what the parameter means.
    While at it, make the comment about the active parameter easier to
    parse.
    
    Cleanup callsites from operations that are not necessary with bool.
    
    Reviewed-by: Jiri Slaby <jirislaby@kernel.org>
    Signed-off-by: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
    Link: https://lore.kernel.org/r/20230117090358.4796-10-ilpo.jarvinen@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 8c4187c4884a..9e3e5e0d11b2 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -898,8 +898,7 @@ static inline bool uart_softcts_mode(struct uart_port *uport)
  */
 
 extern void uart_handle_dcd_change(struct uart_port *uport, bool active);
-extern void uart_handle_cts_change(struct uart_port *uport,
-		unsigned int status);
+extern void uart_handle_cts_change(struct uart_port *uport, bool active);
 
 extern void uart_insert_char(struct uart_port *port, unsigned int status,
 		 unsigned int overrun, unsigned int ch, unsigned int flag);

commit 0388a152fc5544be82e736343496f99c4eef8d62
Author: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
Date:   Tue Jan 17 11:03:54 2023 +0200

    tty/serial: Make ->dcd_change()+uart_handle_dcd_change() status bool active
    
    Convert status parameter for ->dcd_change() and
    uart_handle_dcd_change() to bool which matches to how the parameter is
    used.
    
    Rename status to active to better describe what the parameter means.
    
    Acked-by: Rodolfo Giometti <giometti@enneenne.com>
    Reviewed-by: Jiri Slaby <jirislaby@kernel.org>
    Signed-off-by: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
    Link: https://lore.kernel.org/r/20230117090358.4796-9-ilpo.jarvinen@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 0b37a86bedc5..8c4187c4884a 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -897,8 +897,7 @@ static inline bool uart_softcts_mode(struct uart_port *uport)
  * The following are helper functions for the low level drivers.
  */
 
-extern void uart_handle_dcd_change(struct uart_port *uport,
-		unsigned int status);
+extern void uart_handle_dcd_change(struct uart_port *uport, bool active);
 extern void uart_handle_cts_change(struct uart_port *uport,
 		unsigned int status);
 

commit 163f080eb717d237f02d9a8c179b07ed31fdd6ad
Author: Christoph Niedermaier <cniedermaier@dh-electronics.com>
Date:   Fri Dec 2 11:41:25 2022 +0100

    serial: core: Add option to output RS485 RX_DURING_TX state via GPIO
    
    This patch provides a generic GPIO variable for outputting the state
    of RS485 RX_DURING_TX. The GPIO is defined by the devicetree property
    "rs485-rx-during-tx-gpios". To use it in a low level serial driver,
    the evaluation of this variable must be implemented there accordingly.
    
    Signed-off-by: Christoph Niedermaier <cniedermaier@dh-electronics.com>
    Link: https://lore.kernel.org/r/20221202104127.122761-2-cniedermaier@dh-electronics.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 026294c6ccb8..0b37a86bedc5 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -579,6 +579,7 @@ struct uart_port {
 	struct serial_rs485     rs485;
 	struct serial_rs485	rs485_supported;	/* Supported mask for serial_rs485 */
 	struct gpio_desc	*rs485_term_gpio;	/* enable RS485 bus termination */
+	struct gpio_desc	*rs485_rx_during_tx_gpio; /* Output GPIO that sets the state of RS485 RX during TX */
 	struct serial_iso7816   iso7816;
 	void			*private_data;		/* generic platform data pointer */
 };

commit 41000b03af9e15075061cdbeea461cfa5e12a8eb
Author: Ricardo Ribalda <ribalda@chromium.org>
Date:   Thu Nov 24 13:39:08 2022 +0100

    earlycon: Increase options size
    
    Now that the clock frequency is also part of the options, 16 bytes is
    too little.
    
    Without this patch dmesg does not show the whole options, Eg:
    
    earlycon: uart0 at MMIO32 0x00000000fedc9000 (options '115200n8,480000')
    
    instead of: '115200n8,48000000'
    
    Signed-off-by: Ricardo Ribalda <ribalda@chromium.org>
    Reviewed-by: Jiri Slaby <jirislaby@kernel.org>
    Link: https://lore.kernel.org/r/20221123-serial-clk-v3-2-49c516980ae0@chromium.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index fd59f600094a..026294c6ccb8 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -781,7 +781,7 @@ static inline int uart_poll_timeout(struct uart_port *port)
 struct earlycon_device {
 	struct console *con;
 	struct uart_port port;
-	char options[16];		/* e.g., 115200n8 */
+	char options[32];		/* e.g., 115200n8 */
 	unsigned int baud;
 };
 

commit dd6f9b17cd7af68b6a5090deedf1f5e84f66f4e6
Merge: b83a7080d300 6373ab4dfee7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 16 03:31:56 2022 -0800

    Merge tag 'tty-6.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty
    
    Pull tty/serial driver updates from Greg KH:
     "Here is the "big" set of tty/serial driver changes for 6.2-rc1.
    
      As in previous kernel releases, nothing big here at all, just some
      small incremental serial/tty layer cleanups and some individual driver
      additions and fixes. Highlights are:
    
       - serial helper macros from Jiri Slaby to reduce the amount of
         duplicated code in serial drivers
    
       - api cleanups and consolidations from Ilpo Järvinen in lots of
         serial drivers
    
       - the usual set of n_gsm fixes from Daniel Starke as that code gets
         exercised more
    
       - TIOCSTI is finally able to be disabled if requested (security
         hardening feature from Kees Cook)
    
       - fsl_lpuart driver fixes and features added
    
       - other small serial driver additions and fixes
    
      All of these have been in linux-next for a while with no reported
      problems"
    
    * tag 'tty-6.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty: (97 commits)
      serial: atmel: don't stop the transmitter when doing PIO
      serial: atmel: cleanup atmel_start+stop_tx()
      tty: serial: fsl_lpuart: switch to new dmaengine_terminate_* API
      serial: sunsab: Fix error handling in sunsab_init()
      serial: altera_uart: fix locking in polling mode
      serial: pch: Fix PCI device refcount leak in pch_request_dma()
      tty: serial: fsl_lpuart: Use pm_ptr() to avoid need to make pm __maybe_unused
      tty: serial: fsl_lpuart: Add runtime pm support
      tty: serial: fsl_lpuart: enable wakeup source for lpuart
      serdev: Replace poll loop by readx_poll_timeout() macro
      tty: synclink_gt: unwind actions in error path of net device open
      serial: stm32: move dma_request_chan() before clk_prepare_enable()
      dt-bindings: serial: xlnx,opb-uartlite: Drop 'contains' from 'xlnx,use-parity'
      serial: pl011: Do not clear RX FIFO & RX interrupt in unthrottle.
      serial: amba-pl011: avoid SBSA UART accessing DMACR register
      tty: serial: altera_jtaguart: remove struct altera_jtaguart
      tty: serial: altera_jtaguart: use uart_port::read_status_mask
      tty: serial: altera_jtaguart: remove unused altera_jtaguart::sigs
      tty: serial: altera_jtaguart: remove flag from altera_jtaguart_rx_chars()
      n_tty: Rename tail to old_tail in n_tty_read()
      ...

commit 452b9b24754044eced1508f9090611f3d9aa4ca5
Author: John Ogness <john.ogness@linutronix.de>
Date:   Wed Nov 16 17:27:34 2022 +0106

    serial_core: replace uart_console_enabled() with uart_console_registered()
    
    All users of uart_console_enabled() really want to know if a console
    is registered. It is not reliable to check for CON_ENABLED in order
    to identify if a console is registered. Use console_is_registered()
    instead.
    
    A _locked() variant is provided because uart_set_options() is always
    called with the console_list_lock held and must check if a console
    is registered in order to synchronize with kgdboc.
    
    Signed-off-by: John Ogness <john.ogness@linutronix.de>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Signed-off-by: Petr Mladek <pmladek@suse.com>
    Link: https://lore.kernel.org/r/20221116162152.193147-23-john.ogness@linutronix.de

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index d657f2a42a7b..91871464b99d 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -743,9 +743,15 @@ static const bool earlycon_acpi_spcr_enable EARLYCON_USED_OR_UNUSED;
 static inline int setup_earlycon(char *buf) { return 0; }
 #endif
 
-static inline bool uart_console_enabled(struct uart_port *port)
+/* Variant of uart_console_registered() when the console_list_lock is held. */
+static inline bool uart_console_registered_locked(struct uart_port *port)
 {
-	return uart_console(port) && (port->cons->flags & CON_ENABLED);
+	return uart_console(port) && console_is_registered_locked(port->cons);
+}
+
+static inline bool uart_console_registered(struct uart_port *port)
+{
+	return uart_console(port) && console_is_registered(port->cons);
 }
 
 struct uart_port *uart_get_console(struct uart_port *ports, int nr,

commit 8275b48b278096edc1e3ea5aa9cf946a10022f79
Author: Jiri Slaby (SUSE) <jirislaby@kernel.org>
Date:   Tue Oct 4 12:49:25 2022 +0200

    tty: serial: introduce transmit helpers
    
    Many serial drivers do the same thing:
    * send x_char if set
    * keep sending from the xmit circular buffer until either
      - the loop reaches the end of the xmit buffer
      - TX is stopped
      - HW fifo is full
    * check for pending characters and:
      - wake up tty writers to fill for more data into xmit buffer
      - stop TX if there is nothing in the xmit buffer
    
    The only differences are:
    * how to write the character to the HW fifo
    * the check of the end condition:
      - is the HW fifo full?
      - is limit of the written characters reached?
    
    So unify the above into two helpers:
    * uart_port_tx_limited() -- it performs the above taking the written
      characters limit into account, and
    * uart_port_tx() -- the same as above, except it only checks the HW
      readiness, not the characters limit.
    
    The HW specific operations (as stated as "differences" above) are passed
    as arguments to the macros. They are:
    * tx_ready -- returns true if HW can accept more data.
    * put_char -- write a character to the device.
    * tx_done -- when the write loop is done, perform arbitrary action
      before potential invocation of ops->stop_tx() happens.
    
    Note that the above are macros. This means the code is generated in
    place and the above 3 arguments are "inlined". I.e. no added penalty by
    generating call instructions for every single character. Nor any
    indirect calls. (As in some previous versions of this patchset.)
    
    Reviewed-by: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
    Signed-off-by: Jiri Slaby (SUSE) <jirislaby@kernel.org>
    Link: https://lore.kernel.org/r/20221004104927.14361-2-jirislaby@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index d657f2a42a7b..dbbc4408bb19 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -664,6 +664,86 @@ struct uart_driver {
 
 void uart_write_wakeup(struct uart_port *port);
 
+#define __uart_port_tx(uport, ch, tx_ready, put_char, tx_done, for_test,      \
+		for_post)						      \
+({									      \
+	struct uart_port *__port = (uport);				      \
+	struct circ_buf *xmit = &__port->state->xmit;			      \
+	unsigned int pending;						      \
+									      \
+	for (; (for_test) && (tx_ready); (for_post), __port->icount.tx++) {   \
+		if (__port->x_char) {					      \
+			(ch) = __port->x_char;				      \
+			(put_char);					      \
+			__port->x_char = 0;				      \
+			continue;					      \
+		}							      \
+									      \
+		if (uart_circ_empty(xmit) || uart_tx_stopped(__port))	      \
+			break;						      \
+									      \
+		(ch) = xmit->buf[xmit->tail];				      \
+		(put_char);						      \
+		xmit->tail = (xmit->tail + 1) % UART_XMIT_SIZE;		      \
+	}								      \
+									      \
+	(tx_done);							      \
+									      \
+	pending = uart_circ_chars_pending(xmit);			      \
+	if (pending < WAKEUP_CHARS) {					      \
+		uart_write_wakeup(__port);				      \
+									      \
+		if (pending == 0)					      \
+			__port->ops->stop_tx(__port);			      \
+	}								      \
+									      \
+	pending;							      \
+})
+
+/**
+ * uart_port_tx_limited -- transmit helper for uart_port with count limiting
+ * @port: uart port
+ * @ch: variable to store a character to be written to the HW
+ * @count: a limit of characters to send
+ * @tx_ready: can HW accept more data function
+ * @put_char: function to write a character
+ * @tx_done: function to call after the loop is done
+ *
+ * This helper transmits characters from the xmit buffer to the hardware using
+ * @put_char(). It does so until @count characters are sent and while @tx_ready
+ * evaluates to true.
+ *
+ * Returns: the number of characters in the xmit buffer when done.
+ *
+ * The expression in macro parameters shall be designed as follows:
+ *  * **tx_ready:** should evaluate to true if the HW can accept more data to
+ *    be sent. This parameter can be %true, which means the HW is always ready.
+ *  * **put_char:** shall write @ch to the device of @port.
+ *  * **tx_done:** when the write loop is done, this can perform arbitrary
+ *    action before potential invocation of ops->stop_tx() happens. If the
+ *    driver does not need to do anything, use e.g. ({}).
+ *
+ * For all of them, @port->lock is held, interrupts are locally disabled and
+ * the expressions must not sleep.
+ */
+#define uart_port_tx_limited(port, ch, count, tx_ready, put_char, tx_done) ({ \
+	unsigned int __count = (count);					      \
+	__uart_port_tx(port, ch, tx_ready, put_char, tx_done, __count,	      \
+			__count--);					      \
+})
+
+/**
+ * uart_port_tx -- transmit helper for uart_port
+ * @port: uart port
+ * @ch: variable to store a character to be written to the HW
+ * @tx_ready: can HW accept more data function
+ * @put_char: function to write a character
+ *
+ * See uart_port_tx_limited() for more details.
+ */
+#define uart_port_tx(port, ch, tx_ready, put_char)			\
+	__uart_port_tx(port, ch, tx_ready, put_char, ({}), true, ({}))
+
 /*
  * Baud rate helpers.
  */

commit 7c7f9bc986e698873b489c371a08f206979d06b7
Author: Lukas Wunner <lukas@wunner.de>
Date:   Thu Sep 22 18:27:33 2022 +0200

    serial: Deassert Transmit Enable on probe in driver-specific way
    
    When a UART port is newly registered, uart_configure_port() seeks to
    deassert RS485 Transmit Enable by setting the RTS bit in port->mctrl.
    However a number of UART drivers interpret a set RTS bit as *assertion*
    instead of deassertion:  Affected drivers include those using
    serial8250_em485_config() (except 8250_bcm2835aux.c) and some using
    mctrl_gpio (e.g. imx.c).
    
    Since the interpretation of the RTS bit is driver-specific, it is not
    suitable as a means to centrally deassert Transmit Enable in the serial
    core.  Instead, the serial core must call on drivers to deassert it in
    their driver-specific way.  One way to achieve that is to call
    ->rs485_config().  It implicitly deasserts Transmit Enable.
    
    So amend uart_configure_port() and uart_resume_port() to invoke
    uart_rs485_config().  That allows removing calls to uart_rs485_config()
    from drivers' ->probe() hooks and declaring the function static.
    
    Skip any invocation of ->set_mctrl() if RS485 is enabled.  RS485 has no
    hardware flow control, so the modem control lines are irrelevant and
    need not be touched.  When leaving RS485 mode, reset the modem control
    lines to the state stored in port->mctrl.  That way, UARTs which are
    muxed between RS485 and RS232 transceivers drive the lines correctly
    when switched to RS232.  (serial8250_do_startup() historically raises
    the OUT1 modem signal because otherwise interrupts are not signaled on
    ancient PC UARTs, but I believe that no longer applies to modern,
    RS485-capable UARTs and is thus safe to be skipped.)
    
    imx.c modifies port->mctrl whenever Transmit Enable is asserted and
    deasserted.  Stop it from doing that so port->mctrl reflects the RS232
    line state.
    
    8250_omap.c deasserts Transmit Enable on ->runtime_resume() by calling
    ->set_mctrl().  Because that is now a no-op in RS485 mode, amend the
    function to call serial8250_em485_stop_tx().
    
    fsl_lpuart.c retrieves and applies the RS485 device tree properties
    after registering the UART port.  Because applying now happens on
    registration in uart_configure_port(), move retrieval of the properties
    ahead of uart_add_one_port().
    
    Link: https://lore.kernel.org/all/20220329085050.311408-1-matthias.schiffer@ew.tq-group.com/
    Link: https://lore.kernel.org/all/8f538a8903795f22f9acc94a9a31b03c9c4ccacb.camel@ginzinger.com/
    Fixes: d3b3404df318 ("serial: Fix incorrect rs485 polarity on uart open")
    Cc: stable@vger.kernel.org # v4.14+
    Reported-by: Matthias Schiffer <matthias.schiffer@ew.tq-group.com>
    Reported-by: Roosen Henri <Henri.Roosen@ginzinger.com>
    Tested-by: Matthias Schiffer <matthias.schiffer@ew.tq-group.com>
    Reviewed-by: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://lore.kernel.org/r/2de36eba3fbe11278d5002e4e501afe0ceaca039.1663863805.git.lukas@wunner.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index b4c21f84ad79..d657f2a42a7b 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -951,5 +951,4 @@ static inline int uart_handle_break(struct uart_port *port)
 					 !((cflag) & CLOCAL))
 
 int uart_get_rs485_mode(struct uart_port *port);
-int uart_rs485_config(struct uart_port *port);
 #endif /* LINUX_SERIAL_CORE_H */

commit a12c689209185c1ad872723a644d0cd27e52d49c
Merge: 4c8928850c9d 7e2cd21e02b3
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Sep 25 09:22:13 2022 +0200

    Merge 7e2cd21e02b3 ("Merge tag 'tty-6.0-rc7' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty") into tty-next
    
    We need the tty fixes and api additions in this branch.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 46a8973c4d9d7b12e0e4dd9f589d08d420fb6c0d
Author: Maciej W. Rozycki <macro@orcam.me.uk>
Date:   Wed Sep 21 00:35:42 2022 +0100

    serial: 8250: Switch UART port flags to using BIT_ULL
    
    Use BIT_ULL rather than encoding bits explicitly where applicable with
    UART port flags.  This makes a (__force upf_t) cast redundant, but keep
    it for visual consistency with the flags defined in terms of userspace
    macros.
    
    Signed-off-by: Maciej W. Rozycki <macro@orcam.me.uk>
    Link: https://lore.kernel.org/r/alpine.DEB.2.21.2209210007030.41633@angie.orcam.me.uk
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 2ae182f0f1de..9e0a9d379390 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -513,24 +513,24 @@ struct uart_port {
 #define UPF_BUGGY_UART		((__force upf_t) ASYNC_BUGGY_UART     /* 14 */ )
 #define UPF_MAGIC_MULTIPLIER	((__force upf_t) ASYNC_MAGIC_MULTIPLIER /* 16 */ )
 
-#define UPF_NO_THRE_TEST	((__force upf_t) (1 << 19))
+#define UPF_NO_THRE_TEST	((__force upf_t) BIT_ULL(19))
 /* Port has hardware-assisted h/w flow control */
-#define UPF_AUTO_CTS		((__force upf_t) (1 << 20))
-#define UPF_AUTO_RTS		((__force upf_t) (1 << 21))
+#define UPF_AUTO_CTS		((__force upf_t) BIT_ULL(20))
+#define UPF_AUTO_RTS		((__force upf_t) BIT_ULL(21))
 #define UPF_HARD_FLOW		((__force upf_t) (UPF_AUTO_CTS | UPF_AUTO_RTS))
 /* Port has hardware-assisted s/w flow control */
-#define UPF_SOFT_FLOW		((__force upf_t) (1 << 22))
-#define UPF_CONS_FLOW		((__force upf_t) (1 << 23))
-#define UPF_SHARE_IRQ		((__force upf_t) (1 << 24))
-#define UPF_EXAR_EFR		((__force upf_t) (1 << 25))
-#define UPF_BUG_THRE		((__force upf_t) (1 << 26))
+#define UPF_SOFT_FLOW		((__force upf_t) BIT_ULL(22))
+#define UPF_CONS_FLOW		((__force upf_t) BIT_ULL(23))
+#define UPF_SHARE_IRQ		((__force upf_t) BIT_ULL(24))
+#define UPF_EXAR_EFR		((__force upf_t) BIT_ULL(25))
+#define UPF_BUG_THRE		((__force upf_t) BIT_ULL(26))
 /* The exact UART type is known and should not be probed.  */
-#define UPF_FIXED_TYPE		((__force upf_t) (1 << 27))
-#define UPF_BOOT_AUTOCONF	((__force upf_t) (1 << 28))
-#define UPF_FIXED_PORT		((__force upf_t) (1 << 29))
-#define UPF_DEAD		((__force upf_t) (1 << 30))
-#define UPF_IOREMAP		((__force upf_t) (1 << 31))
-#define UPF_FULL_PROBE		((__force upf_t) (1ULL << 32))
+#define UPF_FIXED_TYPE		((__force upf_t) BIT_ULL(27))
+#define UPF_BOOT_AUTOCONF	((__force upf_t) BIT_ULL(28))
+#define UPF_FIXED_PORT		((__force upf_t) BIT_ULL(29))
+#define UPF_DEAD		((__force upf_t) BIT_ULL(30))
+#define UPF_IOREMAP		((__force upf_t) BIT_ULL(31))
+#define UPF_FULL_PROBE		((__force upf_t) BIT_ULL(32))
 
 #define __UPF_CHANGE_MASK	0x17fff
 #define UPF_CHANGE_MASK		((__force upf_t) __UPF_CHANGE_MASK)

commit 9906890c89e4dbd900ed87ad3040080339a7f411
Author: Maciej W. Rozycki <macro@orcam.me.uk>
Date:   Wed Sep 21 00:35:32 2022 +0100

    serial: 8250: Let drivers request full 16550A feature probing
    
    A SERIAL_8250_16550A_VARIANTS configuration option has been recently
    defined that lets one request the 8250 driver not to probe for 16550A
    device features so as to reduce the driver's device startup time in
    virtual machines.
    
    Some actual hardware devices require these features to have been fully
    determined however for their driver to work correctly, so define a flag
    to let drivers request full 16550A feature probing on a device-by-device
    basis if required regardless of the SERIAL_8250_16550A_VARIANTS option
    setting chosen.
    
    Fixes: dc56ecb81a0a ("serial: 8250: Support disabling mdelay-filled probes of 16550A variants")
    Cc: stable@vger.kernel.org # v5.6+
    Reported-by: Anders Blomdell <anders.blomdell@control.lth.se>
    Signed-off-by: Maciej W. Rozycki <macro@orcam.me.uk>
    Link: https://lore.kernel.org/r/alpine.DEB.2.21.2209202357520.41633@angie.orcam.me.uk
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 02a4299b7d42..2ae182f0f1de 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -422,7 +422,7 @@ struct uart_icount {
 	__u32	buf_overrun;
 };
 
-typedef unsigned int __bitwise upf_t;
+typedef u64 __bitwise upf_t;
 typedef unsigned int __bitwise upstat_t;
 
 struct uart_port {
@@ -530,6 +530,7 @@ struct uart_port {
 #define UPF_FIXED_PORT		((__force upf_t) (1 << 29))
 #define UPF_DEAD		((__force upf_t) (1 << 30))
 #define UPF_IOREMAP		((__force upf_t) (1 << 31))
+#define UPF_FULL_PROBE		((__force upf_t) (1ULL << 32))
 
 #define __UPF_CHANGE_MASK	0x17fff
 #define UPF_CHANGE_MASK		((__force upf_t) __UPF_CHANGE_MASK)

commit e77cab77f2cb3a1ca2ba8df4af45bb35617ac16d
Author: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
Date:   Thu Sep 1 17:39:32 2022 +0300

    serial: Create uart_xmit_advance()
    
    A very common pattern in the drivers is to advance xmit tail
    index and do bookkeeping of Tx'ed characters. Create
    uart_xmit_advance() to handle it.
    
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
    Link: https://lore.kernel.org/r/20220901143934.8850-2-ilpo.jarvinen@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 6e4f4765d209..1eaea9fe44d8 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -624,6 +624,23 @@ struct uart_state {
 /* number of characters left in xmit buffer before we ask for more */
 #define WAKEUP_CHARS		256
 
+/**
+ * uart_xmit_advance - Advance xmit buffer and account Tx'ed chars
+ * @up: uart_port structure describing the port
+ * @chars: number of characters sent
+ *
+ * This function advances the tail of circular xmit buffer by the number of
+ * @chars transmitted and handles accounting of transmitted bytes (into
+ * @up's icount.tx).
+ */
+static inline void uart_xmit_advance(struct uart_port *up, unsigned int chars)
+{
+	struct circ_buf *xmit = &up->state->xmit;
+
+	xmit->tail = (xmit->tail + chars) & (UART_XMIT_SIZE - 1);
+	up->icount.tx += chars;
+}
+
 struct module;
 struct tty_driver;
 

commit 35f2e3c267f07a42bc1bf08081e963b3a33e6d7c
Merge: e4cdd25cafac 7e18e42e4b28
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Sep 5 07:59:28 2022 +0200

    Merge 6.0-rc4 into tty-next
    
    We need the tty/serial fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit bec5b814d46c2a704c3c8148752e62a33e9fa6dc
Author: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
Date:   Tue Aug 16 14:57:37 2022 +0300

    serial: Make ->set_termios() old ktermios const
    
    There should be no reason to adjust old ktermios which is going to get
    discarded anyway.
    
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
    Link: https://lore.kernel.org/r/20220816115739.10928-7-ilpo.jarvinen@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index aef3145f2032..0e9bc943bfa8 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -379,7 +379,7 @@ struct uart_ops {
 	void		(*shutdown)(struct uart_port *);
 	void		(*flush_buffer)(struct uart_port *);
 	void		(*set_termios)(struct uart_port *, struct ktermios *new,
-				       struct ktermios *old);
+				       const struct ktermios *old);
 	void		(*set_ldisc)(struct uart_port *, struct ktermios *);
 	void		(*pm)(struct uart_port *, unsigned int state,
 			      unsigned int oldstate);
@@ -425,7 +425,7 @@ struct uart_port {
 	void			(*serial_out)(struct uart_port *, int, int);
 	void			(*set_termios)(struct uart_port *,
 				               struct ktermios *new,
-				               struct ktermios *old);
+				               const struct ktermios *old);
 	void			(*set_ldisc)(struct uart_port *,
 					     struct ktermios *);
 	unsigned int		(*get_mctrl)(struct uart_port *);
@@ -644,7 +644,7 @@ void uart_write_wakeup(struct uart_port *port);
 void uart_update_timeout(struct uart_port *port, unsigned int cflag,
 			 unsigned int baud);
 unsigned int uart_get_baud_rate(struct uart_port *port, struct ktermios *termios,
-				struct ktermios *old, unsigned int min,
+				const struct ktermios *old, unsigned int min,
 				unsigned int max);
 unsigned int uart_get_divisor(struct uart_port *port, unsigned int baud);
 

commit b5a5b9d5f28d23b84f06b45c61dcad95b07d41bc
Author: Mauro Carvalho Chehab <mchehab@kernel.org>
Date:   Thu Aug 18 15:38:58 2022 +0200

    serial: document start_rx member at struct uart_ops
    
    Fix this doc build warning:
            ./include/linux/serial_core.h:397: warning: Function parameter or member 'start_rx' not described in 'uart_ops'
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@kernel.org>
    Link: https://lore.kernel.org/r/5d07ae2eec8fbad87e623160f9926b178bef2744.1660829433.git.mchehab@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index aef3145f2032..6e4f4765d209 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -141,6 +141,14 @@ struct gpio_desc;
  *	Locking: none.
  *	Interrupts: caller dependent.
  *
+ * @start_rx: ``void ()(struct uart_port *port)``
+ *
+ *	Start receiving characters.
+ *
+ *	Locking: @port->lock taken.
+ *	Interrupts: locally disabled.
+ *	This call must not sleep
+ *
  * @stop_rx: ``void ()(struct uart_port *port)``
  *
  *	Stop receiving characters; the @port is in the process of being closed.

commit 607ca0f742b7d990b6efb3c3e7a52830f7e96419
Merge: 1daf117f1d6b 0fec518018cc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 8 11:31:40 2022 -0700

    Merge tag 'tty-6.0-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty
    
    Pull tty / serial driver updates from Greg KH:
     "Here is the big set of tty and serial driver changes for 6.0-rc1.
    
      It was delayed from last week as I wanted to make sure the last commit
      here got some good testing in linux-next and elsewhere as it seemed to
      show up only late in testing for some reason.
    
      Nothing major here, just lots of cleanups from Jiri and Ilpo to make
      the tty core cleaner (Jiri) and the rs485 code simpler to use (Ilpo).
    
      Also included in here is the obligatory n_gsm updates from Daniel
      Starke and lots of tiny driver updates and minor fixes and tweaks for
      other smaller serial drivers.
    
      All of these have been in linux-next for a while with no reported
      problems"
    
    * tag 'tty-6.0-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/tty: (186 commits)
      tty: serial: qcom-geni-serial: Fix %lu -> %u in print statements
      tty: amiserial: Fix comment typo
      tty: serial: document uart_get_console()
      tty: serial: serial_core, reformat kernel-doc for functions
      Documentation: serial: link uart_ops properly
      Documentation: serial: move GPIO kernel-doc to the functions
      Documentation: serial: dedup kernel-doc for uart functions
      Documentation: serial: move uart_ops documentation to the struct
      dt-bindings: serial: snps-dw-apb-uart: Document Rockchip RV1126
      serial: mvebu-uart: uart2 error bits clearing
      tty: serial: fsl_lpuart: correct the count of break characters
      serial: stm32: make info structs static to avoid sparse warnings
      serial: fsl_lpuart: zero out parity bit in CS7 mode
      tty: serial: qcom-geni-serial: Fix get_clk_div_rate() which otherwise could return a sub-optimal clock rate.
      serial: 8250_bcm2835aux: Add missing clk_disable_unprepare()
      tty: vt: initialize unicode screen buffer
      serial: remove VR41XX serial driver
      serial: 8250: lpc18xx: Remove redundant sanity check for RS485 flags
      serial: 8250_dwlib: remove redundant sanity check for RS485 flags
      dt_bindings: rs485: Correct delay values
      ...

commit e60a7233684aa8bbe9090537720fe6a1e901d823
Author: Jiri Slaby <jirislaby@kernel.org>
Date:   Thu Jul 28 08:10:51 2022 +0200

    Documentation: serial: move uart_ops documentation to the struct
    
    While it's a lot of text, it always helps to keep it up to date when
    it's by the source. (And not in a separate file.)
    
    The documentation tooling also makes sure that all members of the
    structure are documented. (If not, it complains loudly.)
    
    Finally, there needs to be no comments inlined in the structure, so they
    are dropped as they are superfluous now.
    
    The compilation time of this header (tested with serial_core.c) didn't
    change in my testing at all.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Link: https://lore.kernel.org/r/20220728061056.20799-1-jslaby@suse.cz
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index a6fa7c40c330..35d2f9e8027d 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -31,9 +31,336 @@ struct serial_struct;
 struct device;
 struct gpio_desc;
 
-/*
+/**
+ * struct uart_ops -- interface between serial_core and the driver
+ *
  * This structure describes all the operations that can be done on the
- * physical hardware.  See Documentation/driver-api/serial/driver.rst for details.
+ * physical hardware.
+ *
+ * @tx_empty: ``unsigned int ()(struct uart_port *port)``
+ *
+ *	This function tests whether the transmitter fifo and shifter for the
+ *	@port is empty. If it is empty, this function should return
+ *	%TIOCSER_TEMT, otherwise return 0. If the port does not support this
+ *	operation, then it should return %TIOCSER_TEMT.
+ *
+ *	Locking: none.
+ *	Interrupts: caller dependent.
+ *	This call must not sleep
+ *
+ * @set_mctrl: ``void ()(struct uart_port *port, unsigned int mctrl)``
+ *
+ *	This function sets the modem control lines for @port to the state
+ *	described by @mctrl. The relevant bits of @mctrl are:
+ *
+ *		- %TIOCM_RTS	RTS signal.
+ *		- %TIOCM_DTR	DTR signal.
+ *		- %TIOCM_OUT1	OUT1 signal.
+ *		- %TIOCM_OUT2	OUT2 signal.
+ *		- %TIOCM_LOOP	Set the port into loopback mode.
+ *
+ *	If the appropriate bit is set, the signal should be driven
+ *	active.  If the bit is clear, the signal should be driven
+ *	inactive.
+ *
+ *	Locking: @port->lock taken.
+ *	Interrupts: locally disabled.
+ *	This call must not sleep
+ *
+ * @get_mctrl: ``unsigned int ()(struct uart_port *port)``
+ *
+ *	Returns the current state of modem control inputs of @port. The state
+ *	of the outputs should not be returned, since the core keeps track of
+ *	their state. The state information should include:
+ *
+ *		- %TIOCM_CAR	state of DCD signal
+ *		- %TIOCM_CTS	state of CTS signal
+ *		- %TIOCM_DSR	state of DSR signal
+ *		- %TIOCM_RI	state of RI signal
+ *
+ *	The bit is set if the signal is currently driven active.  If
+ *	the port does not support CTS, DCD or DSR, the driver should
+ *	indicate that the signal is permanently active. If RI is
+ *	not available, the signal should not be indicated as active.
+ *
+ *	Locking: @port->lock taken.
+ *	Interrupts: locally disabled.
+ *	This call must not sleep
+ *
+ * @stop_tx: ``void ()(struct uart_port *port)``
+ *
+ *	Stop transmitting characters. This might be due to the CTS line
+ *	becoming inactive or the tty layer indicating we want to stop
+ *	transmission due to an %XOFF character.
+ *
+ *	The driver should stop transmitting characters as soon as possible.
+ *
+ *	Locking: @port->lock taken.
+ *	Interrupts: locally disabled.
+ *	This call must not sleep
+ *
+ * @start_tx: ``void ()(struct uart_port *port)``
+ *
+ *	Start transmitting characters.
+ *
+ *	Locking: @port->lock taken.
+ *	Interrupts: locally disabled.
+ *	This call must not sleep
+ *
+ * @throttle: ``void ()(struct uart_port *port)``
+ *
+ *	Notify the serial driver that input buffers for the line discipline are
+ *	close to full, and it should somehow signal that no more characters
+ *	should be sent to the serial port.
+ *	This will be called only if hardware assisted flow control is enabled.
+ *
+ *	Locking: serialized with @unthrottle() and termios modification by the
+ *	tty layer.
+ *
+ * @unthrottle: ``void ()(struct uart_port *port)``
+ *
+ *	Notify the serial driver that characters can now be sent to the serial
+ *	port without fear of overrunning the input buffers of the line
+ *	disciplines.
+ *
+ *	This will be called only if hardware assisted flow control is enabled.
+ *
+ *	Locking: serialized with @throttle() and termios modification by the
+ *	tty layer.
+ *
+ * @send_xchar: ``void ()(struct uart_port *port, char ch)``
+ *
+ *	Transmit a high priority character, even if the port is stopped. This
+ *	is used to implement XON/XOFF flow control and tcflow(). If the serial
+ *	driver does not implement this function, the tty core will append the
+ *	character to the circular buffer and then call start_tx() / stop_tx()
+ *	to flush the data out.
+ *
+ *	Do not transmit if @ch == '\0' (%__DISABLED_CHAR).
+ *
+ *	Locking: none.
+ *	Interrupts: caller dependent.
+ *
+ * @stop_rx: ``void ()(struct uart_port *port)``
+ *
+ *	Stop receiving characters; the @port is in the process of being closed.
+ *
+ *	Locking: @port->lock taken.
+ *	Interrupts: locally disabled.
+ *	This call must not sleep
+ *
+ * @enable_ms: ``void ()(struct uart_port *port)``
+ *
+ *	Enable the modem status interrupts.
+ *
+ *	This method may be called multiple times. Modem status interrupts
+ *	should be disabled when the @shutdown() method is called.
+ *
+ *	Locking: @port->lock taken.
+ *	Interrupts: locally disabled.
+ *	This call must not sleep
+ *
+ * @break_ctl: ``void ()(struct uart_port *port, int ctl)``
+ *
+ *	Control the transmission of a break signal. If @ctl is nonzero, the
+ *	break signal should be transmitted. The signal should be terminated
+ *	when another call is made with a zero @ctl.
+ *
+ *	Locking: caller holds tty_port->mutex
+ *
+ * @startup: ``int ()(struct uart_port *port)``
+ *
+ *	Grab any interrupt resources and initialise any low level driver state.
+ *	Enable the port for reception. It should not activate RTS nor DTR;
+ *	this will be done via a separate call to @set_mctrl().
+ *
+ *	This method will only be called when the port is initially opened.
+ *
+ *	Locking: port_sem taken.
+ *	Interrupts: globally disabled.
+ *
+ * @shutdown: ``void ()(struct uart_port *port)``
+ *
+ *	Disable the @port, disable any break condition that may be in effect,
+ *	and free any interrupt resources. It should not disable RTS nor DTR;
+ *	this will have already been done via a separate call to @set_mctrl().
+ *
+ *	Drivers must not access @port->state once this call has completed.
+ *
+ *	This method will only be called when there are no more users of this
+ *	@port.
+ *
+ *	Locking: port_sem taken.
+ *	Interrupts: caller dependent.
+ *
+ * @flush_buffer: ``void ()(struct uart_port *port)``
+ *
+ *	Flush any write buffers, reset any DMA state and stop any ongoing DMA
+ *	transfers.
+ *
+ *	This will be called whenever the @port->state->xmit circular buffer is
+ *	cleared.
+ *
+ *	Locking: @port->lock taken.
+ *	Interrupts: locally disabled.
+ *	This call must not sleep
+ *
+ * @set_termios: ``void ()(struct uart_port *port, struct ktermios *new,
+ *			struct ktermios *old)``
+ *
+ *	Change the @port parameters, including word length, parity, stop bits.
+ *	Update @port->read_status_mask and @port->ignore_status_mask to
+ *	indicate the types of events we are interested in receiving. Relevant
+ *	ktermios::c_cflag bits are:
+ *
+ *	- %CSIZE - word size
+ *	- %CSTOPB - 2 stop bits
+ *	- %PARENB - parity enable
+ *	- %PARODD - odd parity (when %PARENB is in force)
+ *	- %ADDRB - address bit (changed through uart_port::rs485_config()).
+ *	- %CREAD - enable reception of characters (if not set, still receive
+ *	  characters from the port, but throw them away).
+ *	- %CRTSCTS - if set, enable CTS status change reporting.
+ *	- %CLOCAL - if not set, enable modem status change reporting.
+ *
+ *	Relevant ktermios::c_iflag bits are:
+ *
+ *	- %INPCK - enable frame and parity error events to be passed to the TTY
+ *	  layer.
+ *	- %BRKINT / %PARMRK - both of these enable break events to be passed to
+ *	  the TTY layer.
+ *	- %IGNPAR - ignore parity and framing errors.
+ *	- %IGNBRK - ignore break errors. If %IGNPAR is also set, ignore overrun
+ *	  errors as well.
+ *
+ *	The interaction of the ktermios::c_iflag bits is as follows (parity
+ *	error given as an example):
+ *
+ *	============ ======= ======= =========================================
+ *	Parity error INPCK   IGNPAR
+ *	============ ======= ======= =========================================
+ *	n/a	     0	     n/a     character received, marked as %TTY_NORMAL
+ *	None	     1	     n/a     character received, marked as %TTY_NORMAL
+ *	Yes	     1	     0	     character received, marked as %TTY_PARITY
+ *	Yes	     1	     1	     character discarded
+ *	============ ======= ======= =========================================
+ *
+ *	Other flags may be used (eg, xon/xoff characters) if your hardware
+ *	supports hardware "soft" flow control.
+ *
+ *	Locking: caller holds tty_port->mutex
+ *	Interrupts: caller dependent.
+ *	This call must not sleep
+ *
+ * @set_ldisc: ``void ()(struct uart_port *port, struct ktermios *termios)``
+ *
+ *	Notifier for discipline change. See
+ *	Documentation/driver-api/tty/tty_ldisc.rst.
+ *
+ *	Locking: caller holds tty_port->mutex
+ *
+ * @pm: ``void ()(struct uart_port *port, unsigned int state,
+ *		 unsigned int oldstate)``
+ *
+ *	Perform any power management related activities on the specified @port.
+ *	@state indicates the new state (defined by enum uart_pm_state),
+ *	@oldstate indicates the previous state.
+ *
+ *	This function should not be used to grab any resources.
+ *
+ *	This will be called when the @port is initially opened and finally
+ *	closed, except when the @port is also the system console. This will
+ *	occur even if %CONFIG_PM is not set.
+ *
+ *	Locking: none.
+ *	Interrupts: caller dependent.
+ *
+ * @type: ``const char *()(struct uart_port *port)``
+ *
+ *	Return a pointer to a string constant describing the specified @port,
+ *	or return %NULL, in which case the string 'unknown' is substituted.
+ *
+ *	Locking: none.
+ *	Interrupts: caller dependent.
+ *
+ * @release_port: ``void ()(struct uart_port *port)``
+ *
+ *	Release any memory and IO region resources currently in use by the
+ *	@port.
+ *
+ *	Locking: none.
+ *	Interrupts: caller dependent.
+ *
+ * @request_port: ``int ()(struct uart_port *port)``
+ *
+ *	Request any memory and IO region resources required by the port. If any
+ *	fail, no resources should be registered when this function returns, and
+ *	it should return -%EBUSY on failure.
+ *
+ *	Locking: none.
+ *	Interrupts: caller dependent.
+ *
+ * @config_port: ``void ()(struct uart_port *port, int type)``
+ *
+ *	Perform any autoconfiguration steps required for the @port. @type
+ *	contains a bit mask of the required configuration. %UART_CONFIG_TYPE
+ *	indicates that the port requires detection and identification.
+ *	@port->type should be set to the type found, or %PORT_UNKNOWN if no
+ *	port was detected.
+ *
+ *	%UART_CONFIG_IRQ indicates autoconfiguration of the interrupt signal,
+ *	which should be probed using standard kernel autoprobing techniques.
+ *	This is not necessary on platforms where ports have interrupts
+ *	internally hard wired (eg, system on a chip implementations).
+ *
+ *	Locking: none.
+ *	Interrupts: caller dependent.
+ *
+ * @verify_port: ``int ()(struct uart_port *port,
+ *			struct serial_struct *serinfo)``
+ *
+ *	Verify the new serial port information contained within @serinfo is
+ *	suitable for this port type.
+ *
+ *	Locking: none.
+ *	Interrupts: caller dependent.
+ *
+ * @ioctl: ``int ()(struct uart_port *port, unsigned int cmd,
+ *		unsigned long arg)``
+ *
+ *	Perform any port specific IOCTLs. IOCTL commands must be defined using
+ *	the standard numbering system found in <asm/ioctl.h>.
+ *
+ *	Locking: none.
+ *	Interrupts: caller dependent.
+ *
+ * @poll_init: ``int ()(struct uart_port *port)``
+ *
+ *	Called by kgdb to perform the minimal hardware initialization needed to
+ *	support @poll_put_char() and @poll_get_char(). Unlike @startup(), this
+ *	should not request interrupts.
+ *
+ *	Locking: %tty_mutex and tty_port->mutex taken.
+ *	Interrupts: n/a.
+ *
+ * @poll_put_char: ``void ()(struct uart_port *port, unsigned char ch)``
+ *
+ *	Called by kgdb to write a single character @ch directly to the serial
+ *	@port. It can and should block until there is space in the TX FIFO.
+ *
+ *	Locking: none.
+ *	Interrupts: caller dependent.
+ *	This call must not sleep
+ *
+ * @poll_get_char: ``int ()(struct uart_port *port)``
+ *
+ *	Called by kgdb to read a single character directly from the serial
+ *	port. If data is available, it should be returned; otherwise the
+ *	function should return %NO_POLL_CHAR immediately.
+ *
+ *	Locking: none.
+ *	Interrupts: caller dependent.
+ *	This call must not sleep
  */
 struct uart_ops {
 	unsigned int	(*tx_empty)(struct uart_port *);
@@ -56,22 +383,8 @@ struct uart_ops {
 	void		(*set_ldisc)(struct uart_port *, struct ktermios *);
 	void		(*pm)(struct uart_port *, unsigned int state,
 			      unsigned int oldstate);
-
-	/*
-	 * Return a string describing the type of the port
-	 */
 	const char	*(*type)(struct uart_port *);
-
-	/*
-	 * Release IO and memory resources used by the port.
-	 * This includes iounmap if necessary.
-	 */
 	void		(*release_port)(struct uart_port *);
-
-	/*
-	 * Request IO and memory resources used by the port.
-	 * This includes iomapping the port if necessary.
-	 */
 	int		(*request_port)(struct uart_port *);
 	void		(*config_port)(struct uart_port *, int);
 	int		(*verify_port)(struct uart_port *, struct serial_struct *);

commit 0139da50dc53f0ce2804e83566d290c7e626fd17
Author: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
Date:   Mon Jul 4 12:45:14 2022 +0300

    serial: Embed rs485_supported to uart_port
    
    Embed rs485_supported to uart_port to allow serial core to tweak it as
    needed.
    
    Reviewed-by: Lino Sanfilippo <l.sanfilippo@kunbus.com>
    Signed-off-by: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
    Link: https://lore.kernel.org/r/20220704094515.6831-2-ilpo.jarvinen@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index b7b86ee3cb12..a6fa7c40c330 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -255,7 +255,7 @@ struct uart_port {
 	struct attribute_group	*attr_group;		/* port specific attributes */
 	const struct attribute_group **tty_groups;	/* all attributes (serial core use only) */
 	struct serial_rs485     rs485;
-	const struct serial_rs485	*rs485_supported;	/* Supported mask for serial_rs485 */
+	struct serial_rs485	rs485_supported;	/* Supported mask for serial_rs485 */
 	struct gpio_desc	*rs485_term_gpio;	/* enable RS485 bus termination */
 	struct serial_iso7816   iso7816;
 	void			*private_data;		/* generic platform data pointer */

commit f9b11229b79c0fb2100b5bb4628a101b1d37fbf6
Author: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
Date:   Wed Jun 29 12:48:41 2022 +0300

    serial: 8250: Fix PM usage_count for console handover
    
    When console is enabled, univ8250_console_setup() calls
    serial8250_console_setup() before .dev is set to uart_port. Therefore,
    it will not call pm_runtime_get_sync(). Later, when the actual driver
    is going to take over univ8250_console_exit() is called. As .dev is
    already set, serial8250_console_exit() makes pm_runtime_put_sync() call
    with usage count being zero triggering PM usage count warning
    (extra debug for univ8250_console_setup(), univ8250_console_exit(), and
    serial8250_register_ports()):
    
    [    0.068987] univ8250_console_setup ttyS0 nodev
    [    0.499670] printk: console [ttyS0] enabled
    [    0.717955] printk: console [ttyS0] printing thread started
    [    1.960163] serial8250_register_ports assigned dev for ttyS0
    [    1.976830] printk: console [ttyS0] disabled
    [    1.976888] printk: console [ttyS0] printing thread stopped
    [    1.977073] univ8250_console_exit ttyS0 usage:0
    [    1.977075] serial8250 serial8250: Runtime PM usage count underflow!
    [    1.977429] dw-apb-uart.6: ttyS0 at MMIO 0x4010006000 (irq = 33, base_baud = 115200) is a 16550A
    [    1.977812] univ8250_console_setup ttyS0 usage:2
    [    1.978167] printk: console [ttyS0] printing thread started
    [    1.978203] printk: console [ttyS0] enabled
    
    To fix the issue, call pm_runtime_get_sync() in
    serial8250_register_ports() as soon as .dev is set for an uart_port
    if it has console enabled.
    
    This problem became apparent only recently because 82586a721595 ("PM:
    runtime: Avoid device usage count underflows") added the warning
    printout. I confirmed this problem also occurs with v5.18 (w/o the
    warning printout, obviously).
    
    Fixes: bedb404e91bb ("serial: 8250_port: Don't use power management for kernel console")
    Cc: stable <stable@kernel.org>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
    Link: https://lore.kernel.org/r/b4f428e9-491f-daf2-2232-819928dc276e@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 657a0fc68a3f..fde258b3decd 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -390,6 +390,11 @@ static const bool earlycon_acpi_spcr_enable EARLYCON_USED_OR_UNUSED;
 static inline int setup_earlycon(char *buf) { return 0; }
 #endif
 
+static inline bool uart_console_enabled(struct uart_port *port)
+{
+	return uart_console(port) && (port->cons->flags & CON_ENABLED);
+}
+
 struct uart_port *uart_get_console(struct uart_port *ports, int nr,
 				   struct console *c);
 int uart_parse_earlycon(char *p, unsigned char *iotype, resource_size_t *addr,

commit ae50bb2752836277ae15aa4e9d99074d6d947946
Author: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
Date:   Fri Jun 24 23:42:08 2022 +0300

    serial: take termios_rwsem for ->rs485_config() & pass termios as param
    
    To be able to alter ADDRB within ->rs485_config(), take termios_rwsem
    before calling ->rs485_config() and pass termios.
    
    Signed-off-by: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
    Link: https://lore.kernel.org/r/20220624204210.11112-5-ilpo.jarvinen@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index faaf2372c60d..b7b86ee3cb12 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -133,6 +133,7 @@ struct uart_port {
 				      unsigned int old);
 	void			(*handle_break)(struct uart_port *);
 	int			(*rs485_config)(struct uart_port *,
+						struct ktermios *termios,
 						struct serial_rs485 *rs485);
 	int			(*iso7816_config)(struct uart_port *,
 						  struct serial_iso7816 *iso7816);

commit f9008285bb69e4713918a665250ab2d356b731ba
Author: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
Date:   Mon Jun 13 14:39:05 2022 +0300

    serial: Drop timeout from uart_port
    
    Since commit 31f6bd7fad3b ("serial: Store character timing information
    to uart_port"), per frame timing information is available on uart_port.
    Uart port's timeout can be derived from frame_time by multiplying with
    fifosize.
    
    Most callers of uart_poll_timeout are not made under port's lock. To be
    on the safe side, make sure frame_time is only accessed once. As
    fifo_size is effectively a constant, it shouldn't cause any issues.
    
    Signed-off-by: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
    Link: https://lore.kernel.org/r/20220613113905.22962-1-ilpo.jarvinen@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 8032ffa741ed..faaf2372c60d 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -232,7 +232,6 @@ struct uart_port {
 
 	int			hw_stopped;		/* sw-assisted CTS flow state */
 	unsigned int		mctrl;			/* current modem ctrl settings */
-	unsigned int		timeout;		/* character-based timeout */
 	unsigned int		frame_time;		/* frame timing in ns */
 	unsigned int		type;			/* port type */
 	const struct uart_ops	*ops;
@@ -335,10 +334,23 @@ unsigned int uart_get_baud_rate(struct uart_port *port, struct ktermios *termios
 				unsigned int max);
 unsigned int uart_get_divisor(struct uart_port *port, unsigned int baud);
 
+/*
+ * Calculates FIFO drain time.
+ */
+static inline unsigned long uart_fifo_timeout(struct uart_port *port)
+{
+	u64 fifo_timeout = (u64)READ_ONCE(port->frame_time) * port->fifosize;
+
+	/* Add .02 seconds of slop */
+	fifo_timeout += 20 * NSEC_PER_MSEC;
+
+	return max(nsecs_to_jiffies(fifo_timeout), 1UL);
+}
+
 /* Base timer interval for polling */
 static inline int uart_poll_timeout(struct uart_port *port)
 {
-	int timeout = port->timeout;
+	int timeout = uart_fifo_timeout(port);
 
 	return timeout > 6 ? (timeout / 2 - 2) : 1;
 }

commit df36f3e3fbb76d30d623a1623e31e3ce9c2fa750
Merge: 65534736d9a5 a111daf0c53a
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jun 20 09:32:47 2022 +0200

    Merge tag 'v5.19-rc3' into tty-next
    
    We need the tty/serial fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 8925c31c1ac2f1e05da988581f2a70a2a8c4d638
Author: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
Date:   Mon Jun 6 13:04:00 2022 +0300

    serial: Add rs485_supported to uart_port
    
    Preparing to move serial_rs485 struct sanitization into serial core,
    each driver has to provide what fields/flags it supports. This
    information is pointed into by rs485_supported.
    
    Signed-off-by: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
    Link: https://lore.kernel.org/r/20220606100433.13793-4-ilpo.jarvinen@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index d3ebb4db2d80..5518b70177b3 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -254,6 +254,7 @@ struct uart_port {
 	struct attribute_group	*attr_group;		/* port specific attributes */
 	const struct attribute_group **tty_groups;	/* all attributes (serial core use only) */
 	struct serial_rs485     rs485;
+	const struct serial_rs485	*rs485_supported;	/* Supported mask for serial_rs485 */
 	struct gpio_desc	*rs485_term_gpio;	/* enable RS485 bus termination */
 	struct serial_iso7816   iso7816;
 	void			*private_data;		/* generic platform data pointer */

commit 8322b1f527159de578aab277629296575a11eb3c
Author: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
Date:   Mon Jun 6 13:03:58 2022 +0300

    serial: Add uart_rs485_config()
    
    A few serial drivers make a call to rs485_config() themselves (all
    these seem to relate to init). Convert them all to use a common helper
    which makes it easy to make adjustments on tasks related to it as
    serial_rs485 struct sanitization is going to be added.
    
    In pci_fintek_setup() (in 8250_pci.c), the rs485_config() call was made
    with NULL, however, it can be changed to pass uart_port's rs485 struct.
    No other callers should pass NULL into rs485_config() so the NULL check
    can now be eliminated.
    
    Signed-off-by: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
    Link: https://lore.kernel.org/r/20220606100433.13793-2-ilpo.jarvinen@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index cbd5070bc87f..d3ebb4db2d80 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -592,4 +592,5 @@ static inline int uart_handle_break(struct uart_port *port)
 					 !((cflag) & CLOCAL))
 
 int uart_get_rs485_mode(struct uart_port *port);
+int uart_rs485_config(struct uart_port *port);
 #endif /* LINUX_SERIAL_CORE_H */

commit cfab87c2c2715763dc7e43d9968bdaa01cde4bc3
Author: Vijaya Krishna Nivarthi <quic_vnivarth@quicinc.com>
Date:   Wed Jun 8 00:22:44 2022 +0530

    serial: core: Introduce callback for start_rx and do stop_rx in suspend only if this callback implementation is present.
    
    In suspend sequence there is a need to perform stop_rx during suspend
    sequence to prevent any asynchronous data over rx line. However this
    can cause problem to drivers which dont do re-start_rx during set_termios.
    
    Add new callback start_rx and perform stop_rx only when implementation of
    start_rx is present. Also add call to start_rx in resume sequence so that
    drivers who come across this problem can make use of this framework.
    
    Fixes: c9d2325cdb92 ("serial: core: Do stop_rx in suspend path for console if console_suspend is disabled")
    Reviewed-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Vijaya Krishna Nivarthi <quic_vnivarth@quicinc.com>
    Link: https://lore.kernel.org/r/1654627965-1461-2-git-send-email-quic_vnivarth@quicinc.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index cbd5070bc87f..657a0fc68a3f 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -45,6 +45,7 @@ struct uart_ops {
 	void		(*unthrottle)(struct uart_port *);
 	void		(*send_xchar)(struct uart_port *, char ch);
 	void		(*stop_rx)(struct uart_port *);
+	void		(*start_rx)(struct uart_port *);
 	void		(*enable_ms)(struct uart_port *);
 	void		(*break_ctl)(struct uart_port *, int ctl);
 	int		(*startup)(struct uart_port *);

commit 31f6bd7fad3b149a1eb6f67fc2e742e4df369b3d
Author: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
Date:   Mon Apr 25 17:33:58 2022 +0300

    serial: Store character timing information to uart_port
    
    Struct uart_port currently stores FIFO timeout. Having character timing
    information readily available is useful. Even serial core itself
    determines char_time from port->timeout using inverse calculation.
    
    Store frame_time directly into uart_port. Character time is stored in
    nanoseconds to have reasonable precision with high rates. To avoid
    overflow, 64-bit math is necessary.
    
    It might be possible to determine timeout from frame_time by
    multiplying it with fifosize as needed but only part of the users seem
    to be protected by a lock. Thus, this patch does not pursue storing
    only frame_time in uart_port.
    
    Signed-off-by: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
    Link: https://lore.kernel.org/r/20220425143410.12703-2-ilpo.jarvinen@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index d4828e69087a..cbd5070bc87f 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -232,6 +232,7 @@ struct uart_port {
 	int			hw_stopped;		/* sw-assisted CTS flow state */
 	unsigned int		mctrl;			/* current modem ctrl settings */
 	unsigned int		timeout;		/* character-based timeout */
+	unsigned int		frame_time;		/* frame timing in ns */
 	unsigned int		type;			/* port type */
 	const struct uart_ops	*ops;
 	unsigned int		custom_divisor;

commit f58c252e30cf74f68b0054293adc03b5923b9f0e
Author: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
Date:   Mon Mar 14 11:14:32 2022 +0200

    serial: 8250: fix XOFF/XON sending when DMA is used
    
    When 8250 UART is using DMA, x_char (XON/XOFF) is never sent
    to the wire. After this change, x_char is injected correctly.
    
    Create uart_xchar_out() helper for sending the x_char out and
    accounting related to it. It seems that almost every driver
    does these same steps with x_char. Except for 8250, however,
    almost all currently lack .serial_out so they cannot immediately
    take advantage of this new helper.
    
    The downside of this patch is that it might reintroduce
    the problems some devices faced with mixed DMA/non-DMA transfer
    which caused revert f967fc8f165f (Revert "serial: 8250_dma:
    don't bother DMA with small transfers"). However, the impact
    should be limited to cases with XON/XOFF (that didn't work
    with DMA capable devices to begin with so this problem is not
    very likely to cause a major issue, if any at all).
    
    Fixes: 9ee4b83e51f74 ("serial: 8250: Add support for dmaengine")
    Reported-by: Gilles Buloz <gilles.buloz@kontron.com>
    Tested-by: Gilles Buloz <gilles.buloz@kontron.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Ilpo Järvinen <ilpo.jarvinen@linux.intel.com>
    Link: https://lore.kernel.org/r/20220314091432.4288-2-ilpo.jarvinen@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 14ae35f68abb..d4828e69087a 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -458,6 +458,8 @@ extern void uart_handle_cts_change(struct uart_port *uport,
 extern void uart_insert_char(struct uart_port *port, unsigned int status,
 		 unsigned int overrun, unsigned int ch, unsigned int flag);
 
+void uart_xchar_out(struct uart_port *uport, int offset);
+
 #ifdef CONFIG_MAGIC_SYSRQ_SERIAL
 #define SYSRQ_TIMEOUT	(HZ * 5)
 

commit 3f8bab174cb26aa5a8053c4457cc733881e3ad88
Author: Jiri Slaby <jirislaby@kernel.org>
Date:   Thu Mar 3 09:08:31 2022 +0100

    serial: make uart_console_write->putchar()'s character an unsigned char
    
    Currently, uart_console_write->putchar's second parameter (the
    character) is of type int. It makes little sense, provided uart_console_write()
    accepts the input string as "const char *s" and passes its content -- the
    characters -- to putchar(). So switch the character's type to unsigned
    char.
    
    We don't use char as that is signed on some platforms. That would cause
    troubles for drivers which (implicitly) cast the char to u16 when
    writing to the device. Sign extension would happen in that case and the
    value written would be completely different to the provided char. DZ is
    an example of such a driver -- on MIPS, it uses u16 for dz_out in
    dz_console_putchar().
    
    Note we do the char -> uchar conversion implicitly in
    uart_console_write(). Provided we do not change size of the data type,
    sign extension does not happen there, so the problem is void.
    
    This makes the types consistent and unified with the rest of the uart
    layer, which uses unsigned char in most places already. One exception is
    xmit_buf, but that is going to be converted later.
    
    Cc: Paul Cercueil <paul@crapouillou.net>
    Cc: Tobias Klauser <tklauser@distanz.ch>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Vineet Gupta <vgupta@kernel.org>
    Cc: Nicolas Ferre <nicolas.ferre@microchip.com>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Ludovic Desroches <ludovic.desroches@microchip.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: bcm-kernel-feedback-list@broadcom.com
    Cc: Alexander Shiyan <shc_work@mail.ru>
    Cc: Baruch Siach <baruch@tkos.co.il>
    Cc: "Maciej W. Rozycki" <macro@orcam.me.uk>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Palmer Dabbelt <palmer@dabbelt.com>
    Cc: Albert Ou <aou@eecs.berkeley.edu>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Pengutronix Kernel Team <kernel@pengutronix.de>
    Cc: Fabio Estevam <festevam@gmail.com>
    Cc: NXP Linux Team <linux-imx@nxp.com>
    Cc: Karol Gugala <kgugala@antmicro.com>
    Cc: Mateusz Holenko <mholenko@antmicro.com>
    Cc: Vladimir Zapolskiy <vz@mleia.com>
    Cc: Neil Armstrong <narmstrong@baylibre.com>
    Cc: Kevin Hilman <khilman@baylibre.com>
    Cc: Jerome Brunet <jbrunet@baylibre.com>
    Cc: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
    Cc: Taichi Sugaya <sugaya.taichi@socionext.com>
    Cc: Takao Orito <orito.takao@socionext.com>
    Cc: Liviu Dudau <liviu.dudau@arm.com>
    Cc: Sudeep Holla <sudeep.holla@arm.com>
    Cc: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Cc: "Andreas Färber" <afaerber@suse.de>
    Cc: Manivannan Sadhasivam <mani@kernel.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Andy Gross <agross@kernel.org>
    Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
    Cc: Krzysztof Kozlowski <krzysztof.kozlowski@canonical.com>
    Cc: Orson Zhai <orsonzhai@gmail.com>
    Cc: Baolin Wang <baolin.wang7@gmail.com>
    Cc: Chunyan Zhang <zhang.lyra@gmail.com>
    Cc: Patrice Chotard <patrice.chotard@foss.st.com>
    Cc: Maxime Coquelin <mcoquelin.stm32@gmail.com>
    Cc: Alexandre Torgue <alexandre.torgue@foss.st.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Peter Korsgaard <peter@korsgaard.com>
    Cc: Michal Simek <michal.simek@xilinx.com>
    Acked-by: Richard Genoud <richard.genoud@gmail.com> [atmel_serial]
    Acked-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Acked-by: Paul Cercueil <paul@crapouillou.net>
    Acked-by: Neil Armstrong <narmstrong@baylibre.com> # meson_serial
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Link: https://lore.kernel.org/r/20220303080831.21783-1-jslaby@suse.cz
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 31f7fe527395..14ae35f68abb 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -399,7 +399,7 @@ int uart_set_options(struct uart_port *port, struct console *co, int baud,
 struct tty_driver *uart_console_device(struct console *co, int *index);
 void uart_console_write(struct uart_port *port, const char *s,
 			unsigned int count,
-			void (*putchar)(struct uart_port *, int));
+			void (*putchar)(struct uart_port *, unsigned char));
 
 /*
  * Port/driver registration/removal

commit 916acbf6b4b9262df7de1d2b6208a4efa209a88f
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Thu Feb 3 16:45:21 2022 +0200

    serial: core: Fix the definition name in the comment of UPF_* flags
    
    From day 1 the UPF_LAST_USER wasn't defined, a specific number of
    the last bit for userspace. Instead the code always relies on
    ASYNCB_LAST_USER. Fix comment accordingly.
    
    Fixes: 904326ecac02 ("tty,serial: Unify UPF_* and ASYNC_* flag definitions")
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Link: https://lore.kernel.org/r/20220203144521.16457-1-andriy.shevchenko@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index c58cc142d23f..31f7fe527395 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -171,7 +171,7 @@ struct uart_port {
 	 * assigned from the serial_struct flags in uart_set_info()
 	 * [for bit definitions in the UPF_CHANGE_MASK]
 	 *
-	 * Bits [0..UPF_LAST_USER] are userspace defined/visible/changeable
+	 * Bits [0..ASYNCB_LAST_USER] are userspace defined/visible/changeable
 	 * The remaining bits are serial-core specific and not modifiable by
 	 * userspace.
 	 */

commit 853a9ae29e978d37f5dfa72622a68c9ae3d7fa89
Author: Johan Hovold <johan@kernel.org>
Date:   Wed Jul 14 10:04:27 2021 +0200

    serial: 8250: fix handle_irq locking
    
    The 8250 handle_irq callback is not just called from the interrupt
    handler but also from a timer callback when polling (e.g. for ports
    without an interrupt line). Consequently the callback must explicitly
    disable interrupts to avoid a potential deadlock with another interrupt
    in polled mode.
    
    Add back an irqrestore-version of the sysrq port-unlock helper and use
    it in the 8250 callbacks that need it.
    
    Fixes: 75f4e830fa9c ("serial: do not restore interrupt state in sysrq helper")
    Cc: stable@vger.kernel.org      # 5.13
    Cc: Joel Stanley <joel@jms.id.au>
    Cc: Andrew Jeffery <andrew@aj.id.au>
    Reported-by: kernel test robot <oliver.sang@intel.com>
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Link: https://lore.kernel.org/r/20210714080427.28164-1-johan@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 52d7fb92a69d..c58cc142d23f 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -518,6 +518,25 @@ static inline void uart_unlock_and_check_sysrq(struct uart_port *port)
 	if (sysrq_ch)
 		handle_sysrq(sysrq_ch);
 }
+
+static inline void uart_unlock_and_check_sysrq_irqrestore(struct uart_port *port,
+		unsigned long flags)
+{
+	int sysrq_ch;
+
+	if (!port->has_sysrq) {
+		spin_unlock_irqrestore(&port->lock, flags);
+		return;
+	}
+
+	sysrq_ch = port->sysrq_ch;
+	port->sysrq_ch = 0;
+
+	spin_unlock_irqrestore(&port->lock, flags);
+
+	if (sysrq_ch)
+		handle_sysrq(sysrq_ch);
+}
 #else	/* CONFIG_MAGIC_SYSRQ_SERIAL */
 static inline int uart_handle_sysrq_char(struct uart_port *port, unsigned int ch)
 {
@@ -531,6 +550,11 @@ static inline void uart_unlock_and_check_sysrq(struct uart_port *port)
 {
 	spin_unlock(&port->lock);
 }
+static inline void uart_unlock_and_check_sysrq_irqrestore(struct uart_port *port,
+		unsigned long flags)
+{
+	spin_unlock_irqrestore(&port->lock, flags);
+}
 #endif	/* CONFIG_MAGIC_SYSRQ_SERIAL */
 
 /*

commit b8be5db573b822920b0f6230498d900752bede17
Author: Jiri Slaby <jirislaby@kernel.org>
Date:   Wed May 19 09:21:50 2021 +0200

    tty/serial: clean up uart_match_port
    
    * make parameters const (as they are only read)
    * return bool (as comparison results are returned)
    * add \n before final return
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Link: https://lore.kernel.org/r/20210519072153.3859-1-jslaby@suse.cz
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 7445c8fd88c0..52d7fb92a69d 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -408,7 +408,8 @@ int uart_register_driver(struct uart_driver *uart);
 void uart_unregister_driver(struct uart_driver *uart);
 int uart_add_one_port(struct uart_driver *reg, struct uart_port *port);
 int uart_remove_one_port(struct uart_driver *reg, struct uart_port *port);
-int uart_match_port(struct uart_port *port1, struct uart_port *port2);
+bool uart_match_port(const struct uart_port *port1,
+		const struct uart_port *port2);
 
 /*
  * Power Management

commit 6e94dbc7a4e49a028b81302d755bba1a518f973b
Author: Jiri Slaby <jirislaby@kernel.org>
Date:   Wed May 5 11:19:05 2021 +0200

    tty: cumulate and document tty_struct::flow* members
    
    Group the flow flags under a single struct called flow. The new struct
    contains 'stopped' and 'tco_stopped' bools which used to be bits in a
    bitfield. The struct also contains the lock protecting them to
    potentially share the same cache line.
    
    Note that commit c545b66c6922b (tty: Serialize tcflow() with other tty
    flow control changes) added a padding to the original bitfield. It was
    for the bitfield to occupy a whole 64b word to avoid interferring stores
    on Alpha (cannot we evaporate this arch with weird implications to C
    code yet?). But it doesn't work as expected as the padding
    (tty_struct::unused) is aligned to a 8B boundary too and occupies some
    bytes from the next word.
    
    So make it reliable by:
    1) setting __aligned of the struct -- that aligns the start, and
    2) making 'unsigned long unused[0]' as the last member of the struct --
       pads the end.
    
    This is also the perfect time to start the documentation of tty_struct
    where all this lives. So we start by documenting what these bools
    actually serve for. And why we do all the alignment dances. Only the few
    up-to-date information from the Theodore's comment made it into this new
    Kerneldoc comment.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Jakub Kicinski <kuba@kernel.org>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Ulf Hansson <ulf.hansson@linaro.org>
    Cc: Heiko Carstens <hca@linux.ibm.com>
    Cc: Vasily Gorbik <gor@linux.ibm.com>
    Cc: Christian Borntraeger <borntraeger@de.ibm.com>
    Cc: Shawn Guo <shawnguo@kernel.org>
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: "Maciej W. Rozycki" <macro@orcam.me.uk>
    Link: https://lore.kernel.org/r/20210505091928.22010-13-jslaby@suse.cz
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index d7ed00f1594e..7445c8fd88c0 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -428,7 +428,7 @@ int uart_resume_port(struct uart_driver *reg, struct uart_port *port);
 static inline int uart_tx_stopped(struct uart_port *port)
 {
 	struct tty_struct *tty = port->state->port.tty;
-	if ((tty && tty->stopped) || port->hw_stopped)
+	if ((tty && tty->flow.stopped) || port->hw_stopped)
 		return 1;
 	return 0;
 }

commit 75f4e830fa9c47637054a3b7201765f2a314bda2
Author: Johan Hovold <johan@kernel.org>
Date:   Fri Apr 16 16:05:55 2021 +0200

    serial: do not restore interrupt state in sysrq helper
    
    The uart_unlock_and_check_sysrq() helper can be used to defer processing
    of sysrq until the interrupt handler has released the port lock and is
    about to return.
    
    Since commit 81e2073c175b ("genirq: Disable interrupts for force
    threaded handlers") interrupt handlers that are not explicitly requested
    as threaded are always called with interrupts disabled and there is no
    need to save the interrupt state when taking the port lock.
    
    Instead of adding another sysrq helper for when the interrupt state has
    not needlessly been saved, drop the state parameter from
    uart_unlock_and_check_sysrq() and update its callers to no longer
    explicitly disable interrupts in their interrupt handlers.
    
    Cc: Joel Stanley <joel@jms.id.au>
    Cc: Andrew Jeffery <andrew@aj.id.au>
    Cc: Andy Gross <agross@kernel.org>
    Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Link: https://lore.kernel.org/r/20210416140557.25177-2-johan@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index e1b684e33841..d7ed00f1594e 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -500,19 +500,19 @@ static inline int uart_prepare_sysrq_char(struct uart_port *port, unsigned int c
 	return 0;
 }
 
-static inline void uart_unlock_and_check_sysrq(struct uart_port *port, unsigned long irqflags)
+static inline void uart_unlock_and_check_sysrq(struct uart_port *port)
 {
 	int sysrq_ch;
 
 	if (!port->has_sysrq) {
-		spin_unlock_irqrestore(&port->lock, irqflags);
+		spin_unlock(&port->lock);
 		return;
 	}
 
 	sysrq_ch = port->sysrq_ch;
 	port->sysrq_ch = 0;
 
-	spin_unlock_irqrestore(&port->lock, irqflags);
+	spin_unlock(&port->lock);
 
 	if (sysrq_ch)
 		handle_sysrq(sysrq_ch);
@@ -526,9 +526,9 @@ static inline int uart_prepare_sysrq_char(struct uart_port *port, unsigned int c
 {
 	return 0;
 }
-static inline void uart_unlock_and_check_sysrq(struct uart_port *port, unsigned long irqflags)
+static inline void uart_unlock_and_check_sysrq(struct uart_port *port)
 {
-	spin_unlock_irqrestore(&port->lock, irqflags);
+	spin_unlock(&port->lock);
 }
 #endif	/* CONFIG_MAGIC_SYSRQ_SERIAL */
 

commit 76437b340b242fd21952f54ba8965d21a1ffa8c8
Author: Johan Hovold <johan@kernel.org>
Date:   Mon Dec 7 10:16:01 2020 +0100

    earlycon: drop semicolon from earlycon macro
    
    Drop the trailing semicolon from the OF_EARLYCON_DECLARE() macro
    definition which was left when removing the array-of-pointer
    indirection.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Link: https://lore.kernel.org/r/20201207091601.5202-1-johan@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 3e32b788c28d..e1b684e33841 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -372,7 +372,7 @@ extern const struct earlycon_id __earlycon_table_end[];
 		__aligned(__alignof__(struct earlycon_id))		\
 		= { .name = __stringify(_name),				\
 		    .compatible = compat,				\
-		    .setup = fn };
+		    .setup = fn }
 
 #define EARLYCON_DECLARE(_name, fn)	OF_EARLYCON_DECLARE(_name, "", fn)
 

commit 62dcd9c59f324e484c1d655884e0101a988f6671
Author: Johan Hovold <johan@kernel.org>
Date:   Mon Nov 23 11:23:13 2020 +0100

    earlycon: simplify earlycon-table implementation
    
    Instead of using the array-of-pointers trick to avoid having gcc mess up
    the earlycon array stride, specify type alignment when declaring entries
    to prevent gcc from increasing alignment.
    
    This is essentially an alternative (one-line) fix to the problem
    addressed by commit dd709e72cb93 ("earlycon: Use a pointer table to fix
    __earlycon_table stride").
    
    gcc can increase the alignment of larger objects with static extent as
    an optimisation, but this can be suppressed by using the aligned
    attribute when declaring variables.
    
    Note that we have been relying on this behaviour for kernel parameters
    for 16 years and it indeed hasn't changed since the introduction of the
    aligned attribute in gcc-3.1.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Link: https://lore.kernel.org/r/20201123102319.8090-3-johan@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index ff63c2963359..3e32b788c28d 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -357,8 +357,8 @@ struct earlycon_id {
 	int	(*setup)(struct earlycon_device *, const char *options);
 };
 
-extern const struct earlycon_id *__earlycon_table[];
-extern const struct earlycon_id *__earlycon_table_end[];
+extern const struct earlycon_id __earlycon_table[];
+extern const struct earlycon_id __earlycon_table_end[];
 
 #if defined(CONFIG_SERIAL_EARLYCON) && !defined(MODULE)
 #define EARLYCON_USED_OR_UNUSED	__used
@@ -366,19 +366,13 @@ extern const struct earlycon_id *__earlycon_table_end[];
 #define EARLYCON_USED_OR_UNUSED	__maybe_unused
 #endif
 
-#define _OF_EARLYCON_DECLARE(_name, compat, fn, unique_id)		\
-	static const struct earlycon_id unique_id			\
-	     EARLYCON_USED_OR_UNUSED __initconst			\
+#define OF_EARLYCON_DECLARE(_name, compat, fn)				\
+	static const struct earlycon_id __UNIQUE_ID(__earlycon_##_name) \
+		EARLYCON_USED_OR_UNUSED  __section("__earlycon_table")  \
+		__aligned(__alignof__(struct earlycon_id))		\
 		= { .name = __stringify(_name),				\
 		    .compatible = compat,				\
-		    .setup = fn  };					\
-	static const struct earlycon_id EARLYCON_USED_OR_UNUSED		\
-		__section("__earlycon_table")				\
-		* const __PASTE(__p, unique_id) = &unique_id
-
-#define OF_EARLYCON_DECLARE(_name, compat, fn)				\
-	_OF_EARLYCON_DECLARE(_name, compat, fn,				\
-			     __UNIQUE_ID(__earlycon_##_name))
+		    .setup = fn };
 
 #define EARLYCON_DECLARE(_name, fn)	OF_EARLYCON_DECLARE(_name, "", fn)
 

commit 33def8498fdde180023444b08e12b72a9efed41d
Author: Joe Perches <joe@perches.com>
Date:   Wed Oct 21 19:36:07 2020 -0700

    treewide: Convert macro and uses of __section(foo) to __section("foo")
    
    Use a more generic form for __section that requires quotes to avoid
    complications with clang and gcc differences.
    
    Remove the quote operator # from compiler_attributes.h __section macro.
    
    Convert all unquoted __section(foo) uses to quoted __section("foo").
    Also convert __attribute__((section("foo"))) uses to __section("foo")
    even if the __attribute__ has multiple list entry forms.
    
    Conversion done using the script at:
    
        https://lore.kernel.org/lkml/75393e5ddc272dc7403de74d645e6c6e0f4e70eb.camel@perches.com/2-convert_section.pl
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Reviewed-by: Nick Desaulniers <ndesaulniers@gooogle.com>
    Reviewed-by: Miguel Ojeda <ojeda@kernel.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 8a99279a579b..ff63c2963359 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -373,7 +373,7 @@ extern const struct earlycon_id *__earlycon_table_end[];
 		    .compatible = compat,				\
 		    .setup = fn  };					\
 	static const struct earlycon_id EARLYCON_USED_OR_UNUSED		\
-		__section(__earlycon_table)				\
+		__section("__earlycon_table")				\
 		* const __PASTE(__p, unique_id) = &unique_id
 
 #define OF_EARLYCON_DECLARE(_name, compat, fn)				\

commit e0830dbf71f191851ed3772d2760f007b7c5bc3a
Author: Johan Hovold <johan@kernel.org>
Date:   Wed Sep 9 16:31:01 2020 +0200

    serial: core: fix console port-lock regression
    
    Fix the port-lock initialisation regression introduced by commit
    a3cb39d258ef ("serial: core: Allow detach and attach serial device for
    console") by making sure that the lock is again initialised during
    console setup.
    
    The console may be registered before the serial controller has been
    probed in which case the port lock needs to be initialised during
    console setup by a call to uart_set_options(). The console-detach
    changes introduced a regression in several drivers by effectively
    removing that initialisation by not initialising the lock when the port
    is used as a console (which is always the case during console setup).
    
    Add back the early lock initialisation and instead use a new
    console-reinit flag to handle the case where a console is being
    re-attached through sysfs.
    
    The question whether the console-detach interface should have been added
    in the first place is left for another discussion.
    
    Note that the console-enabled check in uart_set_options() is not
    redundant because of kgdboc, which can end up reinitialising an already
    enabled console (see commit 42b6a1baa3ec ("serial_core: Don't
    re-initialize a previously initialized spinlock.")).
    
    Fixes: a3cb39d258ef ("serial: core: Allow detach and attach serial device for console")
    Cc: stable <stable@vger.kernel.org>     # 5.7
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Link: https://lore.kernel.org/r/20200909143101.15389-3-johan@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 01fc4d9c9c54..8a99279a579b 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -248,6 +248,7 @@ struct uart_port {
 
 	unsigned char		hub6;			/* this should be in the 8250 driver */
 	unsigned char		suspended;
+	unsigned char		console_reinit;
 	const char		*name;			/* port name */
 	struct attribute_group	*attr_group;		/* port specific attributes */
 	const struct attribute_group **tty_groups;	/* all attributes (serial core use only) */

commit 6f2c6599ba70da7ca9603f8026c4e3cdc273ee02
Merge: ea1be1e59b19 ba47d845d715
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Jul 20 09:39:11 2020 +0200

    Merge 5.8-rc6 into tty-next
    
    We need the serial/tty fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 225385657b7d81a99e17e04cd01f9ed5bb3109a8
Author: Johan Hovold <johan@kernel.org>
Date:   Wed Jun 10 17:22:32 2020 +0200

    serial: core: drop redundant sysrq checks
    
    The sysrq timestamp will never be set unless port->has_sysrq is set (see
    uart_handle_break()) so drop the redundant checks that were added by
    commit 1997e9dfdc84 ("serial_core: Un-ifdef sysrq SUPPORT_SYSRQ").
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Dmitry Safonov <0x7f454c46@gmail.com>
    Link: https://lore.kernel.org/r/20200610152232.16925-4-johan@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 03fa7b967103..791f4844efeb 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -469,7 +469,7 @@ bool uart_try_toggle_sysrq(struct uart_port *port, unsigned int ch);
 
 static inline int uart_handle_sysrq_char(struct uart_port *port, unsigned int ch)
 {
-	if (!port->has_sysrq || !port->sysrq)
+	if (!port->sysrq)
 		return 0;
 
 	if (ch && time_before(jiffies, port->sysrq)) {
@@ -488,7 +488,7 @@ static inline int uart_handle_sysrq_char(struct uart_port *port, unsigned int ch
 
 static inline int uart_prepare_sysrq_char(struct uart_port *port, unsigned int ch)
 {
-	if (!port->has_sysrq || !port->sysrq)
+	if (!port->sysrq)
 		return 0;
 
 	if (ch && time_before(jiffies, port->sysrq)) {

commit 08d5470308ac3598e7709d08b8979ce6e9de8da2
Author: Johan Hovold <johan@kernel.org>
Date:   Wed Jun 10 17:22:31 2020 +0200

    serial: core: fix sysrq overhead regression
    
    Commit 8e20fc391711 ("serial_core: Move sysrq functions from header
    file") converted the inline sysrq helpers to exported functions which
    are now called for every received character, interrupt and break signal
    also on systems without CONFIG_MAGIC_SYSRQ_SERIAL instead of being
    optimised away by the compiler.
    
    Inlining these helpers again also avoids the function call overhead when
    CONFIG_MAGIC_SYSRQ_SERIAL is enabled (e.g. when the port is not used as
    a console).
    
    Fixes: 8e20fc391711 ("serial_core: Move sysrq functions from header file")
    Cc: Dmitry Safonov <0x7f454c46@gmail.com>
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Cc: stable <stable@vger.kernel.org>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Dmitry Safonov <0x7f454c46@gmail.com>
    Link: https://lore.kernel.org/r/20200610152232.16925-3-johan@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index ef4921ddbe97..03fa7b967103 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -462,11 +462,104 @@ extern void uart_handle_cts_change(struct uart_port *uport,
 extern void uart_insert_char(struct uart_port *port, unsigned int status,
 		 unsigned int overrun, unsigned int ch, unsigned int flag);
 
-extern int uart_handle_sysrq_char(struct uart_port *port, unsigned int ch);
-extern int uart_prepare_sysrq_char(struct uart_port *port, unsigned int ch);
-extern void uart_unlock_and_check_sysrq(struct uart_port *port,
-					unsigned long irqflags);
-extern int uart_handle_break(struct uart_port *port);
+#ifdef CONFIG_MAGIC_SYSRQ_SERIAL
+#define SYSRQ_TIMEOUT	(HZ * 5)
+
+bool uart_try_toggle_sysrq(struct uart_port *port, unsigned int ch);
+
+static inline int uart_handle_sysrq_char(struct uart_port *port, unsigned int ch)
+{
+	if (!port->has_sysrq || !port->sysrq)
+		return 0;
+
+	if (ch && time_before(jiffies, port->sysrq)) {
+		if (sysrq_mask()) {
+			handle_sysrq(ch);
+			port->sysrq = 0;
+			return 1;
+		}
+		if (uart_try_toggle_sysrq(port, ch))
+			return 1;
+	}
+	port->sysrq = 0;
+
+	return 0;
+}
+
+static inline int uart_prepare_sysrq_char(struct uart_port *port, unsigned int ch)
+{
+	if (!port->has_sysrq || !port->sysrq)
+		return 0;
+
+	if (ch && time_before(jiffies, port->sysrq)) {
+		if (sysrq_mask()) {
+			port->sysrq_ch = ch;
+			port->sysrq = 0;
+			return 1;
+		}
+		if (uart_try_toggle_sysrq(port, ch))
+			return 1;
+	}
+	port->sysrq = 0;
+
+	return 0;
+}
+
+static inline void uart_unlock_and_check_sysrq(struct uart_port *port, unsigned long irqflags)
+{
+	int sysrq_ch;
+
+	if (!port->has_sysrq) {
+		spin_unlock_irqrestore(&port->lock, irqflags);
+		return;
+	}
+
+	sysrq_ch = port->sysrq_ch;
+	port->sysrq_ch = 0;
+
+	spin_unlock_irqrestore(&port->lock, irqflags);
+
+	if (sysrq_ch)
+		handle_sysrq(sysrq_ch);
+}
+#else	/* CONFIG_MAGIC_SYSRQ_SERIAL */
+static inline int uart_handle_sysrq_char(struct uart_port *port, unsigned int ch)
+{
+	return 0;
+}
+static inline int uart_prepare_sysrq_char(struct uart_port *port, unsigned int ch)
+{
+	return 0;
+}
+static inline void uart_unlock_and_check_sysrq(struct uart_port *port, unsigned long irqflags)
+{
+	spin_unlock_irqrestore(&port->lock, irqflags);
+}
+#endif	/* CONFIG_MAGIC_SYSRQ_SERIAL */
+
+/*
+ * We do the SysRQ and SAK checking like this...
+ */
+static inline int uart_handle_break(struct uart_port *port)
+{
+	struct uart_state *state = port->state;
+
+	if (port->handle_break)
+		port->handle_break(port);
+
+#ifdef CONFIG_MAGIC_SYSRQ_SERIAL
+	if (port->has_sysrq && uart_console(port)) {
+		if (!port->sysrq) {
+			port->sysrq = jiffies + SYSRQ_TIMEOUT;
+			return 1;
+		}
+		port->sysrq = 0;
+	}
+#endif
+	if (port->flags & UPF_SAK)
+		do_SAK(state->port.tty);
+	return 0;
+}
 
 /*
  *	UART_ENABLE_MS - determine if port should enable modem status irqs

commit 10652a9e9fe3fbcaca090f99cd3060ac3fee2913
Author: Johan Hovold <johan@kernel.org>
Date:   Wed Jun 10 17:22:30 2020 +0200

    Revert "serial: core: Refactor uart_unlock_and_check_sysrq()"
    
    This reverts commit da9a5aa3402db0ff3b57216d8dbf2478e1046cae.
    
    In order to ease backporting a fix for a sysrq regression, revert this
    rewrite which was since added on top.
    
    The other sysrq helpers now bail out early when sysrq is not enabled;
    it's better to keep that pattern here as well.
    
    Note that the __releases() attribute won't be needed after the follow-on
    fix either.
    
    Fixes: da9a5aa3402d ("serial: core: Refactor uart_unlock_and_check_sysrq()")
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Link: https://lore.kernel.org/r/20200610152232.16925-2-johan@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 9fd550e7946a..ef4921ddbe97 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -464,7 +464,8 @@ extern void uart_insert_char(struct uart_port *port, unsigned int status,
 
 extern int uart_handle_sysrq_char(struct uart_port *port, unsigned int ch);
 extern int uart_prepare_sysrq_char(struct uart_port *port, unsigned int ch);
-extern void uart_unlock_and_check_sysrq(struct uart_port *port, unsigned long flags);
+extern void uart_unlock_and_check_sysrq(struct uart_port *port,
+					unsigned long irqflags);
 extern int uart_handle_break(struct uart_port *port);
 
 /*

commit 167cbce27444be3203081b97ea65178c4088b062
Author: Johan Hovold <johan@kernel.org>
Date:   Wed Jun 10 17:51:21 2020 +0200

    serial: core: drop unnecessary gpio include
    
    Drop the recently added gpio include from the serial-core header in
    favour of a forward declaration and instead include the gpio header only
    where needed.
    
    Signed-off-by: Johan Hovold <johan@kernel.org>
    Link: https://lore.kernel.org/r/20200610155121.14014-1-johan@kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 9fd550e7946a..653c653ad0c2 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -10,7 +10,6 @@
 #include <linux/bitops.h>
 #include <linux/compiler.h>
 #include <linux/console.h>
-#include <linux/gpio/consumer.h>
 #include <linux/interrupt.h>
 #include <linux/circ_buf.h>
 #include <linux/spinlock.h>
@@ -30,6 +29,7 @@
 struct uart_port;
 struct serial_struct;
 struct device;
+struct gpio_desc;
 
 /*
  * This structure describes all the operations that can be done on the

commit d58a2df3d8877b91ecbfb936a15da364251a228f
Author: Lukas Wunner <lukas@wunner.de>
Date:   Mon May 18 16:45:02 2020 +0200

    serial: 8250: Support rs485 bus termination GPIO
    
    Commit e8759ad17d41 ("serial: uapi: Add support for bus termination")
    introduced the ability to enable rs485 bus termination from user space.
    So far the feature is only used by a single driver, 8250_exar.c, using a
    hardcoded GPIO pin specific to Siemens IOT2040 products.
    
    Provide for a more generic solution by allowing specification of an
    rs485 bus termination GPIO pin in the device tree:  Amend the serial
    core to retrieve the GPIO from the device tree (or ACPI table) and amend
    the default ->rs485_config() callback for 8250 drivers to change the
    GPIO on request from user space.
    
    Perhaps 8250_exar.c can be converted to the generic approach in a
    follow-up patch.
    
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Cc: Jan Kiszka <jan.kiszka@siemens.com>
    Link: https://lore.kernel.org/r/94c6c800d1ca9fa04766dd1d43a8272c5ad4bedd.1589811297.git.lukas@wunner.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index b649a2b894e7..9fd550e7946a 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -10,6 +10,7 @@
 #include <linux/bitops.h>
 #include <linux/compiler.h>
 #include <linux/console.h>
+#include <linux/gpio/consumer.h>
 #include <linux/interrupt.h>
 #include <linux/circ_buf.h>
 #include <linux/spinlock.h>
@@ -251,6 +252,7 @@ struct uart_port {
 	struct attribute_group	*attr_group;		/* port specific attributes */
 	const struct attribute_group **tty_groups;	/* all attributes (serial core use only) */
 	struct serial_rs485     rs485;
+	struct gpio_desc	*rs485_term_gpio;	/* enable RS485 bus termination */
 	struct serial_iso7816   iso7816;
 	void			*private_data;		/* generic platform data pointer */
 };

commit c150c0f362c1e51c0e3216c9912b85b71d00e70d
Author: Lukas Wunner <lukas@wunner.de>
Date:   Tue May 12 14:40:02 2020 +0200

    serial: Allow uart_get_rs485_mode() to return errno
    
    We're about to amend uart_get_rs485_mode() to support a GPIO pin for
    rs485 bus termination.  Retrieving the GPIO descriptor may fail, so
    allow uart_get_rs485_mode() to return an errno and change all callers
    to check for failure.
    
    The GPIO descriptor is going to be stored in struct uart_port.  Pass
    that struct to uart_get_rs485_mode() in lieu of a struct device and
    struct serial_rs485, both of which are directly accessible from struct
    uart_port.
    
    A few drivers call uart_get_rs485_mode() before setting the struct
    device pointer in struct uart_port.  Shuffle those calls around where
    necessary.
    
    [Heiko Stuebner did the ar933x_uart.c portion, hence his Signed-off-by.]
    
    Signed-off-by: Heiko Stuebner <heiko@sntech.de>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Link: https://lore.kernel.org/r/271e814af4b0db3bffbbb74abf2b46b75add4516.1589285873.git.lukas@wunner.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 92f5eba86052..b649a2b894e7 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -472,5 +472,5 @@ extern int uart_handle_break(struct uart_port *port);
 					 (cflag) & CRTSCTS || \
 					 !((cflag) & CLOCAL))
 
-void uart_get_rs485_mode(struct device *dev, struct serial_rs485 *rs485conf);
+int uart_get_rs485_mode(struct uart_port *port);
 #endif /* LINUX_SERIAL_CORE_H */

commit da9a5aa3402db0ff3b57216d8dbf2478e1046cae
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Mar 10 19:43:37 2020 +0200

    serial: core: Refactor uart_unlock_and_check_sysrq()
    
    Refactor uart_unlock_and_check_sysrq() to:
    
      - explicitly show that we release a port lock which makes
        static analyzers happy:
    
    CHECK   drivers/tty/serial/serial_core.c
    .../serial_core.c:3290:17: warning: context imbalance in 'uart_unlock_and_check_sysrq' - unexpected unlock
    
      - use flags instead of irqflags to avoid confusion with IRQ flags
    
      - provide one return point
    
      - be more compact
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Dmitry Safonov <0x7f454c46@gmail.com>
    Link: https://lore.kernel.org/r/20200310174337.74109-4-andriy.shevchenko@linux.intel.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 1f4443db5474..92f5eba86052 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -462,8 +462,7 @@ extern void uart_insert_char(struct uart_port *port, unsigned int status,
 
 extern int uart_handle_sysrq_char(struct uart_port *port, unsigned int ch);
 extern int uart_prepare_sysrq_char(struct uart_port *port, unsigned int ch);
-extern void uart_unlock_and_check_sysrq(struct uart_port *port,
-					unsigned long irqflags);
+extern void uart_unlock_and_check_sysrq(struct uart_port *port, unsigned long flags);
 extern int uart_handle_break(struct uart_port *port);
 
 /*

commit 68af43173d3fcece70bef49cb992c64c4c68ff23
Author: Dmitry Safonov <0x7f454c46@gmail.com>
Date:   Mon Mar 2 17:51:35 2020 +0000

    serial/sysrq: Add MAGIC_SYSRQ_SERIAL_SEQUENCE
    
    Many embedded boards have a disconnected TTL level serial which can
    generate some garbage that can lead to spurious false sysrq detects.
    
    Currently, sysrq can be either completely disabled for serial console
    or always disabled (with CONFIG_MAGIC_SYSRQ_SERIAL), since
    commit 732dbf3a6104 ("serial: do not accept sysrq characters via serial port")
    
    At Arista, we have such boards that can generate BREAK and random
    garbage. While disabling sysrq for serial console would solve
    the problem with spurious false sysrq triggers, it's also desirable
    to have a way to enable sysrq back.
    
    As a measure of balance between on and off options, add
    MAGIC_SYSRQ_SERIAL_SEQUENCE which is a string sequence that can enable
    sysrq if it follows BREAK on a serial line. The longer the string - the
    less likely it may be in the garbage.
    
    Having the way to enable sysrq was beneficial to debug lockups with
    a manual investigation in field and on the other side preventing false
    sysrq detections.
    
    Based-on-patch-by: Vasiliy Khoruzhick <vasilykh@arista.com>
    Signed-off-by: Dmitry Safonov <dima@arista.com>
    Link: https://lore.kernel.org/r/20200302175135.269397-3-dima@arista.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 52404ef1694e..1f4443db5474 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -243,6 +243,7 @@ struct uart_port {
 	unsigned long		sysrq;			/* sysrq timeout */
 	unsigned int		sysrq_ch;		/* char for sysrq */
 	unsigned char		has_sysrq;
+	unsigned char		sysrq_seq;		/* index in sysrq_toggle_seq */
 
 	unsigned char		hub6;			/* this should be in the 8250 driver */
 	unsigned char		suspended;

commit 7788f549ed8cfbecd75c10e1a1988812adba49d8
Author: Dmitry Safonov <0x7f454c46@gmail.com>
Date:   Tue Jan 14 17:19:12 2020 +0000

    serial_core: Remove unused member in uart_port
    
    It should remove the align-padding before @name.
    
    [yes, there's a "hole" in the structure now, but that's fine, no one
    cares.  If they do care, the whole thing should be restructured using
    pahole to find a better ordering.  Removing this field is good as some
    drivers have been known to abuse it for other things when they shouldn't
    have been doing that. -- gregkh]
    
    Signed-off-by: Dmitry Safonov <dima@arista.com>
    Link: https://lore.kernel.org/r/20200114171912.261787-4-dima@arista.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 255e86a474e9..52404ef1694e 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -246,7 +246,6 @@ struct uart_port {
 
 	unsigned char		hub6;			/* this should be in the 8250 driver */
 	unsigned char		suspended;
-	unsigned char		unused;
 	const char		*name;			/* port name */
 	struct attribute_group	*attr_group;		/* port specific attributes */
 	const struct attribute_group **tty_groups;	/* all attributes (serial core use only) */

commit 8e20fc3917117b42de316e87f073a1ca43d94c9f
Author: Dmitry Safonov <0x7f454c46@gmail.com>
Date:   Thu Jan 9 21:54:42 2020 +0000

    serial_core: Move sysrq functions from header file
    
    It's not worth to have them in every serial driver and I'm about to add
    another helper function.
    
    Signed-off-by: Dmitry Safonov <dima@arista.com>
    Link: https://lore.kernel.org/r/20200109215444.95995-2-dima@arista.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 9cf1682dc580..255e86a474e9 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -460,85 +460,11 @@ extern void uart_handle_cts_change(struct uart_port *uport,
 extern void uart_insert_char(struct uart_port *port, unsigned int status,
 		 unsigned int overrun, unsigned int ch, unsigned int flag);
 
-static inline int
-uart_handle_sysrq_char(struct uart_port *port, unsigned int ch)
-{
-	if (!IS_ENABLED(CONFIG_MAGIC_SYSRQ_SERIAL))
-		return 0;
-
-	if (!port->has_sysrq || !port->sysrq)
-		return 0;
-
-	if (ch && time_before(jiffies, port->sysrq)) {
-		handle_sysrq(ch);
-		port->sysrq = 0;
-		return 1;
-	}
-	port->sysrq = 0;
-
-	return 0;
-}
-static inline int
-uart_prepare_sysrq_char(struct uart_port *port, unsigned int ch)
-{
-	if (!IS_ENABLED(CONFIG_MAGIC_SYSRQ_SERIAL))
-		return 0;
-
-	if (!port->has_sysrq || !port->sysrq)
-		return 0;
-
-	if (ch && time_before(jiffies, port->sysrq)) {
-		port->sysrq_ch = ch;
-		port->sysrq = 0;
-		return 1;
-	}
-	port->sysrq = 0;
-
-	return 0;
-}
-static inline void
-uart_unlock_and_check_sysrq(struct uart_port *port, unsigned long irqflags)
-{
-	int sysrq_ch;
-
-	if (!port->has_sysrq) {
-		spin_unlock_irqrestore(&port->lock, irqflags);
-		return;
-	}
-
-	sysrq_ch = port->sysrq_ch;
-	port->sysrq_ch = 0;
-
-	spin_unlock_irqrestore(&port->lock, irqflags);
-
-	if (sysrq_ch)
-		handle_sysrq(sysrq_ch);
-}
-
-/*
- * We do the SysRQ and SAK checking like this...
- */
-static inline int uart_handle_break(struct uart_port *port)
-{
-	struct uart_state *state = port->state;
-
-	if (port->handle_break)
-		port->handle_break(port);
-
-	if (port->has_sysrq) {
-		if (port->cons && port->cons->index == port->line) {
-			if (!port->sysrq) {
-				port->sysrq = jiffies + HZ*5;
-				return 1;
-			}
-			port->sysrq = 0;
-		}
-	}
-
-	if (port->flags & UPF_SAK)
-		do_SAK(state->port.tty);
-	return 0;
-}
+extern int uart_handle_sysrq_char(struct uart_port *port, unsigned int ch);
+extern int uart_prepare_sysrq_char(struct uart_port *port, unsigned int ch);
+extern void uart_unlock_and_check_sysrq(struct uart_port *port,
+					unsigned long irqflags);
+extern int uart_handle_break(struct uart_port *port);
 
 /*
  *	UART_ENABLE_MS - determine if port should enable modem status irqs

commit 82cfd2e62b354840af6a045e084f6e9e7c49584d
Author: Dmitry Safonov <0x7f454c46@gmail.com>
Date:   Fri Dec 13 00:06:53 2019 +0000

    serial_core: Remove SUPPORT_SYSRQ ifdeffery
    
    No one defines it anymore.
    
    Signed-off-by: Dmitry Safonov <dima@arista.com>
    Link: https://lore.kernel.org/r/20191213000657.931618-55-dima@arista.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 5f761c399282..9cf1682dc580 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -466,10 +466,7 @@ uart_handle_sysrq_char(struct uart_port *port, unsigned int ch)
 	if (!IS_ENABLED(CONFIG_MAGIC_SYSRQ_SERIAL))
 		return 0;
 
-	if (!port->has_sysrq && !IS_ENABLED(SUPPORT_SYSRQ))
-		return 0;
-
-	if (!port->sysrq)
+	if (!port->has_sysrq || !port->sysrq)
 		return 0;
 
 	if (ch && time_before(jiffies, port->sysrq)) {
@@ -487,10 +484,7 @@ uart_prepare_sysrq_char(struct uart_port *port, unsigned int ch)
 	if (!IS_ENABLED(CONFIG_MAGIC_SYSRQ_SERIAL))
 		return 0;
 
-	if (!port->has_sysrq && !IS_ENABLED(SUPPORT_SYSRQ))
-		return 0;
-
-	if (!port->sysrq)
+	if (!port->has_sysrq || !port->sysrq)
 		return 0;
 
 	if (ch && time_before(jiffies, port->sysrq)) {
@@ -507,7 +501,7 @@ uart_unlock_and_check_sysrq(struct uart_port *port, unsigned long irqflags)
 {
 	int sysrq_ch;
 
-	if (!port->has_sysrq && !IS_ENABLED(SUPPORT_SYSRQ)) {
+	if (!port->has_sysrq) {
 		spin_unlock_irqrestore(&port->lock, irqflags);
 		return;
 	}
@@ -531,7 +525,7 @@ static inline int uart_handle_break(struct uart_port *port)
 	if (port->handle_break)
 		port->handle_break(port);
 
-	if (port->has_sysrq || IS_ENABLED(SUPPORT_SYSRQ)) {
+	if (port->has_sysrq) {
 		if (port->cons && port->cons->index == port->line) {
 			if (!port->sysrq) {
 				port->sysrq = jiffies + HZ*5;

commit 1997e9dfdc84c8f73d6fc318355cf9e313aba183
Author: Dmitry Safonov <0x7f454c46@gmail.com>
Date:   Fri Dec 13 00:06:02 2019 +0000

    serial_core: Un-ifdef sysrq SUPPORT_SYSRQ
    
    The SUPPORT_SYSRQ is messy: every .c source should define it before
    including "serial_core.h" if sysrq is supported or struct uart_port will
    differ in sizes. Also this prevents moving to serial_core.c functions:
    uart_handle_sysrq_char(), uart_prepare_sysrq_char(),
    uart_unlock_and_check_sysrq().
    
    It doesn't save many bytes in the structure, and a better way to reduce
    it's size would be making rs485 and iso7816 pointers.
    
    Introduce `has_sysrq` member to be used by serial line drivers further.
    
    Signed-off-by: Dmitry Safonov <dima@arista.com>
    Link: https://lore.kernel.org/r/20191213000657.931618-4-dima@arista.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index bbbe57bf5163..5f761c399282 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -240,14 +240,13 @@ struct uart_port {
 	resource_size_t		mapsize;
 	struct device		*dev;			/* parent device */
 
-#if defined(CONFIG_SERIAL_CORE_CONSOLE) || defined(SUPPORT_SYSRQ)
 	unsigned long		sysrq;			/* sysrq timeout */
 	unsigned int		sysrq_ch;		/* char for sysrq */
-#endif
+	unsigned char		has_sysrq;
 
 	unsigned char		hub6;			/* this should be in the 8250 driver */
 	unsigned char		suspended;
-	unsigned char		unused[2];
+	unsigned char		unused;
 	const char		*name;			/* port name */
 	struct attribute_group	*attr_group;		/* port specific attributes */
 	const struct attribute_group **tty_groups;	/* all attributes (serial core use only) */
@@ -461,31 +460,46 @@ extern void uart_handle_cts_change(struct uart_port *uport,
 extern void uart_insert_char(struct uart_port *port, unsigned int status,
 		 unsigned int overrun, unsigned int ch, unsigned int flag);
 
-#if defined(SUPPORT_SYSRQ) && defined(CONFIG_MAGIC_SYSRQ_SERIAL)
 static inline int
 uart_handle_sysrq_char(struct uart_port *port, unsigned int ch)
 {
-	if (port->sysrq) {
-		if (ch && time_before(jiffies, port->sysrq)) {
-			handle_sysrq(ch);
-			port->sysrq = 0;
-			return 1;
-		}
+	if (!IS_ENABLED(CONFIG_MAGIC_SYSRQ_SERIAL))
+		return 0;
+
+	if (!port->has_sysrq && !IS_ENABLED(SUPPORT_SYSRQ))
+		return 0;
+
+	if (!port->sysrq)
+		return 0;
+
+	if (ch && time_before(jiffies, port->sysrq)) {
+		handle_sysrq(ch);
 		port->sysrq = 0;
+		return 1;
 	}
+	port->sysrq = 0;
+
 	return 0;
 }
 static inline int
 uart_prepare_sysrq_char(struct uart_port *port, unsigned int ch)
 {
-	if (port->sysrq) {
-		if (ch && time_before(jiffies, port->sysrq)) {
-			port->sysrq_ch = ch;
-			port->sysrq = 0;
-			return 1;
-		}
+	if (!IS_ENABLED(CONFIG_MAGIC_SYSRQ_SERIAL))
+		return 0;
+
+	if (!port->has_sysrq && !IS_ENABLED(SUPPORT_SYSRQ))
+		return 0;
+
+	if (!port->sysrq)
+		return 0;
+
+	if (ch && time_before(jiffies, port->sysrq)) {
+		port->sysrq_ch = ch;
 		port->sysrq = 0;
+		return 1;
 	}
+	port->sysrq = 0;
+
 	return 0;
 }
 static inline void
@@ -493,6 +507,11 @@ uart_unlock_and_check_sysrq(struct uart_port *port, unsigned long irqflags)
 {
 	int sysrq_ch;
 
+	if (!port->has_sysrq && !IS_ENABLED(SUPPORT_SYSRQ)) {
+		spin_unlock_irqrestore(&port->lock, irqflags);
+		return;
+	}
+
 	sysrq_ch = port->sysrq_ch;
 	port->sysrq_ch = 0;
 
@@ -501,17 +520,6 @@ uart_unlock_and_check_sysrq(struct uart_port *port, unsigned long irqflags)
 	if (sysrq_ch)
 		handle_sysrq(sysrq_ch);
 }
-#else
-static inline int
-uart_handle_sysrq_char(struct uart_port *port, unsigned int ch) { return 0; }
-static inline int
-uart_prepare_sysrq_char(struct uart_port *port, unsigned int ch) { return 0; }
-static inline void
-uart_unlock_and_check_sysrq(struct uart_port *port, unsigned long irqflags)
-{
-	spin_unlock_irqrestore(&port->lock, irqflags);
-}
-#endif
 
 /*
  * We do the SysRQ and SAK checking like this...
@@ -523,15 +531,16 @@ static inline int uart_handle_break(struct uart_port *port)
 	if (port->handle_break)
 		port->handle_break(port);
 
-#ifdef SUPPORT_SYSRQ
-	if (port->cons && port->cons->index == port->line) {
-		if (!port->sysrq) {
-			port->sysrq = jiffies + HZ*5;
-			return 1;
+	if (port->has_sysrq || IS_ENABLED(SUPPORT_SYSRQ)) {
+		if (port->cons && port->cons->index == port->line) {
+			if (!port->sysrq) {
+				port->sysrq = jiffies + HZ*5;
+				return 1;
+			}
+			port->sysrq = 0;
 		}
-		port->sysrq = 0;
 	}
-#endif
+
 	if (port->flags & UPF_SAK)
 		do_SAK(state->port.tty);
 	return 0;

commit 7e5ed9f5e012f21a1514edcf8c35b9b4cfbd96c3
Author: Dmitry Safonov <0x7f454c46@gmail.com>
Date:   Fri Dec 13 00:06:01 2019 +0000

    serial: Move sysrq members above
    
    At the current place members those follow are:
    :       upf_t                   flags;
    :       upstat_t                status;
    :       int                     hw_stopped;
    :       unsigned int            mctrl;
    :       unsigned int            timeout;
    :       unsigned int            type;
    :       const struct uart_ops   *ops;
    
    Together, they give (*ops) 8-byte align on 64-bit platforms.
    And `sysrq_ch` introduces 4-byte padding.
    
    On the other side, above:
    :       struct device           *dev;
    :       unsigned char           hub6;
    :       unsigned char           suspended;
    :       unsigned char           unused[2];
    :       const char              *name;
    
    Adds another 4-byte padding.
    
    Moving sysrq members just before `hub6` allows to save 8 bytes
    per-uart_port on 64-bit platforms:
    On my gcc, x86_64 sizeof(struct uart_port) goes from 528 to 520.
    
    Signed-off-by: Dmitry Safonov <dima@arista.com>
    Link: https://lore.kernel.org/r/20191213000657.931618-3-dima@arista.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 2b78cc734719..bbbe57bf5163 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -161,11 +161,6 @@ struct uart_port {
 	struct uart_icount	icount;			/* statistics */
 
 	struct console		*cons;			/* struct console, if any */
-#if defined(CONFIG_SERIAL_CORE_CONSOLE) || defined(SUPPORT_SYSRQ)
-	unsigned long		sysrq;			/* sysrq timeout */
-	unsigned int		sysrq_ch;		/* char for sysrq */
-#endif
-
 	/* flags must be updated while holding port mutex */
 	upf_t			flags;
 
@@ -244,6 +239,12 @@ struct uart_port {
 	resource_size_t		mapbase;		/* for ioremap */
 	resource_size_t		mapsize;
 	struct device		*dev;			/* parent device */
+
+#if defined(CONFIG_SERIAL_CORE_CONSOLE) || defined(SUPPORT_SYSRQ)
+	unsigned long		sysrq;			/* sysrq timeout */
+	unsigned int		sysrq_ch;		/* char for sysrq */
+#endif
+
 	unsigned char		hub6;			/* this should be in the 8250 driver */
 	unsigned char		suspended;
 	unsigned char		unused[2];

commit 65388dad1bbb51a4eb6cc91b9fa865b57646fb67
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Thu Jun 27 16:31:35 2019 -0300

    docs: serial: move it to the driver-api
    
    The contents of this directory is mostly driver-api stuff.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 05b179015d6c..2b78cc734719 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -32,7 +32,7 @@ struct device;
 
 /*
  * This structure describes all the operations that can be done on the
- * physical hardware.  See Documentation/serial/driver.rst for details.
+ * physical hardware.  See Documentation/driver-api/serial/driver.rst for details.
  */
 struct uart_ops {
 	unsigned int	(*tx_empty)(struct uart_port *);

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index fea2216a893f..05b179015d6c 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -1,21 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  *  linux/drivers/char/serial_core.h
  *
  *  Copyright (C) 2000 Deep Blue Solutions Ltd.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 #ifndef LINUX_SERIAL_CORE_H
 #define LINUX_SERIAL_CORE_H

commit f137401780278c5a257945330936607701fbd2fd
Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
Date:   Mon Apr 22 10:27:22 2019 -0300

    docs: serial: convert docs to ReST and rename to *.rst
    
    The converted files are focused at the Kernel internal API,
    so, this is a good candidate for the kernel API set of books.
    
    The conversion is actually:
      - add blank lines and identation in order to identify paragraphs;
      - fix tables markups;
      - add some lists markups;
      - mark literal blocks;
      - adjust title markups.
    
    At its new index.rst, let's add a :orphan: while this is not linked to
    the main index.rst file, in order to avoid build warnings.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 5fe2b037e833..fea2216a893f 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -45,7 +45,7 @@ struct device;
 
 /*
  * This structure describes all the operations that can be done on the
- * physical hardware.  See Documentation/serial/driver for details.
+ * physical hardware.  See Documentation/serial/driver.rst for details.
  */
 struct uart_ops {
 	unsigned int	(*tx_empty)(struct uart_port *);

commit 3e6f88068314ffdba61a19f48ab0118f50424348
Author: Douglas Anderson <dianders@chromium.org>
Date:   Tue Oct 30 15:11:06 2018 -0700

    serial: core: Include console.h from serial_core.h
    
    In the static inline function uart_handle_break() in serial_core.h we
    dereference port->cons.  That gives an error unless console.h is also
    included.
    
    This error hasn't shown up till now because everyone who has defined
    SUPPORT_SYSRQ has also included console.h, but it's a bit ugly to make
    this requirement.  Let's make the include explicit.
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 78de9d929762..5fe2b037e833 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -22,6 +22,7 @@
 
 #include <linux/bitops.h>
 #include <linux/compiler.h>
+#include <linux/console.h>
 #include <linux/interrupt.h>
 #include <linux/circ_buf.h>
 #include <linux/spinlock.h>

commit d6e1935819db0c91ce4a5af82466f3ab50d17346
Author: Douglas Anderson <dianders@chromium.org>
Date:   Tue Oct 30 15:11:04 2018 -0700

    serial: core: Allow processing sysrq at port unlock time
    
    Right now serial drivers process sysrq keys deep in their character
    receiving code.  This means that they've already grabbed their
    port->lock spinlock.  This can end up getting in the way if we've go
    to do serial stuff (especially kgdb) in response to the sysrq.
    
    Serial drivers have various hacks in them to handle this.  Looking at
    '8250_port.c' you can see that the console_write() skips locking if
    we're in the sysrq handler.  Looking at 'msm_serial.c' you can see
    that the port lock is dropped around uart_handle_sysrq_char().
    
    It turns out that these hacks aren't exactly perfect.  If you have
    lockdep turned on and use something like the 8250_port hack you'll get
    a splat that looks like:
    
      WARNING: possible circular locking dependency detected
      [...] is trying to acquire lock:
      ... (console_owner){-.-.}, at: console_unlock+0x2e0/0x5e4
    
      but task is already holding lock:
      ... (&port_lock_key){-.-.}, at: serial8250_handle_irq+0x30/0xe4
    
      which lock already depends on the new lock.
    
      the existing dependency chain (in reverse order) is:
    
      -> #1 (&port_lock_key){-.-.}:
             _raw_spin_lock_irqsave+0x58/0x70
             serial8250_console_write+0xa8/0x250
             univ8250_console_write+0x40/0x4c
             console_unlock+0x528/0x5e4
             register_console+0x2c4/0x3b0
             uart_add_one_port+0x350/0x478
             serial8250_register_8250_port+0x350/0x3a8
             dw8250_probe+0x67c/0x754
             platform_drv_probe+0x58/0xa4
             really_probe+0x150/0x294
             driver_probe_device+0xac/0xe8
             __driver_attach+0x98/0xd0
             bus_for_each_dev+0x84/0xc8
             driver_attach+0x2c/0x34
             bus_add_driver+0xf0/0x1ec
             driver_register+0xb4/0x100
             __platform_driver_register+0x60/0x6c
             dw8250_platform_driver_init+0x20/0x28
             ...
    
      -> #0 (console_owner){-.-.}:
             lock_acquire+0x1e8/0x214
             console_unlock+0x35c/0x5e4
             vprintk_emit+0x230/0x274
             vprintk_default+0x7c/0x84
             vprintk_func+0x190/0x1bc
             printk+0x80/0xa0
             __handle_sysrq+0x104/0x21c
             handle_sysrq+0x30/0x3c
             serial8250_read_char+0x15c/0x18c
             serial8250_rx_chars+0x34/0x74
             serial8250_handle_irq+0x9c/0xe4
             dw8250_handle_irq+0x98/0xcc
             serial8250_interrupt+0x50/0xe8
             ...
    
      other info that might help us debug this:
    
       Possible unsafe locking scenario:
    
             CPU0                    CPU1
             ----                    ----
        lock(&port_lock_key);
                                     lock(console_owner);
                                     lock(&port_lock_key);
        lock(console_owner);
    
       *** DEADLOCK ***
    
    The hack used in 'msm_serial.c' doesn't cause the above splats but it
    seems a bit ugly to unlock / lock our spinlock deep in our irq
    handler.
    
    It seems like we could defer processing the sysrq until the end of the
    interrupt handler right after we've unlocked the port.  With this
    scheme if a whole batch of sysrq characters comes in one irq then we
    won't handle them all, but that seems like it should be a fine
    compromise.
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 047fa67d039b..78de9d929762 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -175,6 +175,7 @@ struct uart_port {
 	struct console		*cons;			/* struct console, if any */
 #if defined(CONFIG_SERIAL_CORE_CONSOLE) || defined(SUPPORT_SYSRQ)
 	unsigned long		sysrq;			/* sysrq timeout */
+	unsigned int		sysrq_ch;		/* char for sysrq */
 #endif
 
 	/* flags must be updated while holding port mutex */
@@ -485,8 +486,42 @@ uart_handle_sysrq_char(struct uart_port *port, unsigned int ch)
 	}
 	return 0;
 }
+static inline int
+uart_prepare_sysrq_char(struct uart_port *port, unsigned int ch)
+{
+	if (port->sysrq) {
+		if (ch && time_before(jiffies, port->sysrq)) {
+			port->sysrq_ch = ch;
+			port->sysrq = 0;
+			return 1;
+		}
+		port->sysrq = 0;
+	}
+	return 0;
+}
+static inline void
+uart_unlock_and_check_sysrq(struct uart_port *port, unsigned long irqflags)
+{
+	int sysrq_ch;
+
+	sysrq_ch = port->sysrq_ch;
+	port->sysrq_ch = 0;
+
+	spin_unlock_irqrestore(&port->lock, irqflags);
+
+	if (sysrq_ch)
+		handle_sysrq(sysrq_ch);
+}
 #else
-#define uart_handle_sysrq_char(port,ch) ({ (void)port; 0; })
+static inline int
+uart_handle_sysrq_char(struct uart_port *port, unsigned int ch) { return 0; }
+static inline int
+uart_prepare_sysrq_char(struct uart_port *port, unsigned int ch) { return 0; }
+static inline void
+uart_unlock_and_check_sysrq(struct uart_port *port, unsigned long irqflags)
+{
+	spin_unlock_irqrestore(&port->lock, irqflags);
+}
 #endif
 
 /*

commit 817e9bc8cc04e5c70592525b96812c46c1aa1c46
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Thu Oct 4 09:57:23 2018 -0700

    Revert "serial:serial_core: Allow use of CTS for PPS line discipline"
    
    This reverts commit c550f01c810f2197c98e6e3103f81797f5e063be.
    
    Turns out the samsung tty driver is mucking around in the "unused" port
    fields and this patch breaks that code :(
    
    So we need to fix that driver up before this can be accepted.
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Steve Sakoman <steve@sakoman.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 4e2ba4894dcc..047fa67d039b 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -257,8 +257,7 @@ struct uart_port {
 	struct device		*dev;			/* parent device */
 	unsigned char		hub6;			/* this should be in the 8250 driver */
 	unsigned char		suspended;
-	unsigned char		pps_4wire;		/* CTS instead of DCD */
-	unsigned char		unused;
+	unsigned char		unused[2];
 	const char		*name;			/* port name */
 	struct attribute_group	*attr_group;		/* port specific attributes */
 	const struct attribute_group **tty_groups;	/* all attributes (serial core use only) */

commit ad8c0eaa0a418ae8ef3f9217638bb86439399eac
Author: Nicolas Ferre <nicolas.ferre@microchip.com>
Date:   Wed Sep 26 14:58:47 2018 +0200

    tty/serial_core: add ISO7816 infrastructure
    
    Add the ISO7816 ioctl and associated accessors and data structure.
    Drivers can then use this common implementation to handle ISO7816
    (smart cards).
    
    Signed-off-by: Nicolas Ferre <nicolas.ferre@microchip.com>
    [ludovic.desroches@microchip.com: squash and rebase, removal of gpios, checkpatch fixes]
    Signed-off-by: Ludovic Desroches <ludovic.desroches@microchip.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 079793e5d3fa..4e2ba4894dcc 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -144,6 +144,8 @@ struct uart_port {
 	void			(*handle_break)(struct uart_port *);
 	int			(*rs485_config)(struct uart_port *,
 						struct serial_rs485 *rs485);
+	int			(*iso7816_config)(struct uart_port *,
+						  struct serial_iso7816 *iso7816);
 	unsigned int		irq;			/* irq number */
 	unsigned long		irqflags;		/* irq flags  */
 	unsigned int		uartclk;		/* base uart clock */
@@ -261,6 +263,7 @@ struct uart_port {
 	struct attribute_group	*attr_group;		/* port specific attributes */
 	const struct attribute_group **tty_groups;	/* all attributes (serial core use only) */
 	struct serial_rs485     rs485;
+	struct serial_iso7816   iso7816;
 	void			*private_data;		/* generic platform data pointer */
 };
 

commit c550f01c810f2197c98e6e3103f81797f5e063be
Author: Steve Sakoman <steve@sakoman.com>
Date:   Thu Sep 20 09:20:34 2018 -1000

    serial:serial_core: Allow use of CTS for PPS line discipline
    
    Add a "pps_4wire" file to serial ports in sysfs in case the kernel is
    configured with CONFIG_PPS_CLIENT_LDISC. Writing 1 to the file enables
    the use of CTS instead of DCD for PPS signal input. This is necessary
    in case a serial port is not completely wired.
    Though this affects PPS processing the patch is against the serial core
    as the source of the serial port PPS event dispatching has to be
    modified. Furthermore it should be possible to modify the source of
    serial port PPS event dispatching before changing the line discipline.
    
    Signed-off-by: Andreas Steinmetz <ast@domdv.de>
    Signed-off-by: Steve Sakoman <steve@sakoman.com>
    Tested-by: Steve Sakoman <steve@sakoman.com>
    Tested-by: Eric Gallimore <egallimore@ucsd.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 406edae44ca3..079793e5d3fa 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -255,7 +255,8 @@ struct uart_port {
 	struct device		*dev;			/* parent device */
 	unsigned char		hub6;			/* this should be in the 8250 driver */
 	unsigned char		suspended;
-	unsigned char		unused[2];
+	unsigned char		pps_4wire;		/* CTS instead of DCD */
+	unsigned char		unused;
 	const char		*name;			/* port name */
 	struct attribute_group	*attr_group;		/* port specific attributes */
 	const struct attribute_group **tty_groups;	/* all attributes (serial core use only) */

commit 0238d2b4a4c7bb1b2268e1ef789629878e16ab02
Author: Jisheng Zhang <jszhang@kernel.org>
Date:   Thu Jul 12 09:57:00 2018 +0800

    serial: 8250: introduce get_divisor() and set_divisor() hook
    
    Add these two hooks so that they can be overridden with driver specific
    implementations.
    
    Signed-off-by: Jisheng Zhang <Jisheng.Zhang@synaptics.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 06ea4eeb09ab..406edae44ca3 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -127,6 +127,13 @@ struct uart_port {
 					     struct ktermios *);
 	unsigned int		(*get_mctrl)(struct uart_port *);
 	void			(*set_mctrl)(struct uart_port *, unsigned int);
+	unsigned int		(*get_divisor)(struct uart_port *,
+					       unsigned int baud,
+					       unsigned int *frac);
+	void			(*set_divisor)(struct uart_port *,
+					       unsigned int baud,
+					       unsigned int quot,
+					       unsigned int quot_frac);
 	int			(*startup)(struct uart_port *port);
 	void			(*shutdown)(struct uart_port *port);
 	void			(*throttle)(struct uart_port *port);

commit 7b6c81f46c5dd7af316bf09aa1991ceed7e53dcd
Merge: 0a84bae7edfb 6da6c0db5316
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Apr 30 05:14:55 2018 -0700

    Merge 4.17-rc3 into tty-next
    
    We want the tty and serial driver fixes in here as well.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit c1c734cb1f54b062f7e67ffc9656d82f5b412b9c
Author: Douglas Anderson <dianders@chromium.org>
Date:   Fri Mar 23 10:58:31 2018 -0700

    serial: core: Make sure compiler barfs for 16-byte earlycon names
    
    As part of bringup I ended up wanting to call an earlycon driver by a
    name that was exactly 16-bytes big, specifically "qcom_geni_serial".
    
    Unfortunately, when I tried this I found that things compiled just
    fine.  They just didn't work.
    
    Specifically the compiler felt perfectly justified in initting the
    ".name" field of "struct earlycon_id" with the full 16-bytes and just
    skipping the '\0'.  Needless to say, that behavior didn't seem ideal,
    but I guess someone must have allowed it for a reason.
    
    One way to fix this is to shorten the name field to 15 bytes and then
    add an extra byte after that nobody touches.  This should always be
    initted to 0 and we're golden.
    
    There are, of course, other ways to fix this too.  We could audit all
    the users of the "name" field and make them stop at both null
    termination or at 16 bytes.  We could also just make the name field
    much bigger so that we're not likely to run into this.  ...but both
    seem like we'll just hit the bug again.
    
    Signed-off-by: Douglas Anderson <dianders@chromium.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index d224961e1346..d2a2e4bc2435 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -349,7 +349,8 @@ struct earlycon_device {
 };
 
 struct earlycon_id {
-	char	name[16];
+	char	name[15];
+	char	name_term;	/* In case compiler didn't '\0' term name */
 	char	compatible[128];
 	int	(*setup)(struct earlycon_device *, const char *options);
 } __aligned(32);

commit c5f78b1fe4e5baf4c4ca30377c2d7e06e2e391ec
Author: Jeremy Kerr <jk@ozlabs.org>
Date:   Tue Mar 27 11:48:24 2018 +0800

    serial: Introduce UPSTAT_SYNC_FIFO for synchronised FIFOs
    
    This change adds a flag to indicate that a UART is has an external means
    of synchronising its FIFO, without needing CTSRTS or XON/XOFF.
    
    This allows us to use the throttle/unthrottle callbacks, without having
    to claim other methods of flow control.
    
    Signed-off-by: Jeremy Kerr <jk@ozlabs.org>
    Tested-by: Eddie James <eajames@linux.vnet.ibm.com>
    Tested-by: Joel Stanley <joel@jms.id.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 1d356105f25a..d224961e1346 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -233,6 +233,7 @@ struct uart_port {
 #define UPSTAT_AUTORTS		((__force upstat_t) (1 << 2))
 #define UPSTAT_AUTOCTS		((__force upstat_t) (1 << 3))
 #define UPSTAT_AUTOXOFF		((__force upstat_t) (1 << 4))
+#define UPSTAT_SYNC_FIFO	((__force upstat_t) (1 << 5))
 
 	int			hw_stopped;		/* sw-assisted CTS flow state */
 	unsigned int		mctrl;			/* current modem ctrl settings */

commit dd709e72cb934eefd44de8d9969097173fbf45dc
Author: Daniel Kurtz <djkurtz@chromium.org>
Date:   Fri Apr 6 17:21:53 2018 -0600

    earlycon: Use a pointer table to fix __earlycon_table stride
    
    Commit 99492c39f39f ("earlycon: Fix __earlycon_table stride") tried to fix
    __earlycon_table stride by forcing the earlycon_id struct alignment to 32
    and asking the linker to 32-byte align the __earlycon_table symbol.  This
    fix was based on commit 07fca0e57fca92 ("tracing: Properly align linker
    defined symbols") which tried a similar fix for the tracing subsystem.
    
    However, this fix doesn't quite work because there is no guarantee that
    gcc will place structures packed into an array format.  In fact, gcc 4.9
    chooses to 64-byte align these structs by inserting additional padding
    between the entries because it has no clue that they are supposed to be in
    an array.  If we are unlucky, the linker will assign symbol
    "__earlycon_table" to a 32-byte aligned address which does not correspond
    to the 64-byte aligned contents of section "__earlycon_table".
    
    To address this same problem, the fix to the tracing system was
    subsequently re-implemented using a more robust table of pointers approach
    by commits:
     3d56e331b653 ("tracing: Replace syscall_meta_data struct array with pointer array")
     654986462939 ("tracepoints: Fix section alignment using pointer array")
     e4a9ea5ee7c8 ("tracing: Replace trace_event struct array with pointer array")
    
    Let's use this same "array of pointers to structs" approach for
    EARLYCON_TABLE.
    
    Fixes: 99492c39f39f ("earlycon: Fix __earlycon_table stride")
    Signed-off-by: Daniel Kurtz <djkurtz@chromium.org>
    Suggested-by: Aaron Durbin <adurbin@chromium.org>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Tested-by: Guenter Roeck <groeck@chromium.org>
    Reviewed-by: Guenter Roeck <groeck@chromium.org>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 1d356105f25a..b4c9fda9d833 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -351,10 +351,10 @@ struct earlycon_id {
 	char	name[16];
 	char	compatible[128];
 	int	(*setup)(struct earlycon_device *, const char *options);
-} __aligned(32);
+};
 
-extern const struct earlycon_id __earlycon_table[];
-extern const struct earlycon_id __earlycon_table_end[];
+extern const struct earlycon_id *__earlycon_table[];
+extern const struct earlycon_id *__earlycon_table_end[];
 
 #if defined(CONFIG_SERIAL_EARLYCON) && !defined(MODULE)
 #define EARLYCON_USED_OR_UNUSED	__used
@@ -362,12 +362,19 @@ extern const struct earlycon_id __earlycon_table_end[];
 #define EARLYCON_USED_OR_UNUSED	__maybe_unused
 #endif
 
-#define OF_EARLYCON_DECLARE(_name, compat, fn)				\
-	static const struct earlycon_id __UNIQUE_ID(__earlycon_##_name)	\
-	     EARLYCON_USED_OR_UNUSED __section(__earlycon_table)	\
+#define _OF_EARLYCON_DECLARE(_name, compat, fn, unique_id)		\
+	static const struct earlycon_id unique_id			\
+	     EARLYCON_USED_OR_UNUSED __initconst			\
 		= { .name = __stringify(_name),				\
 		    .compatible = compat,				\
-		    .setup = fn  }
+		    .setup = fn  };					\
+	static const struct earlycon_id EARLYCON_USED_OR_UNUSED		\
+		__section(__earlycon_table)				\
+		* const __PASTE(__p, unique_id) = &unique_id
+
+#define OF_EARLYCON_DECLARE(_name, compat, fn)				\
+	_OF_EARLYCON_DECLARE(_name, compat, fn,				\
+			     __UNIQUE_ID(__earlycon_##_name))
 
 #define EARLYCON_DECLARE(_name, fn)	OF_EARLYCON_DECLARE(_name, "", fn)
 

commit 219c7b06f3da9ac2b51ed671881b20f1b127daef
Author: Mathieu Malaterre <malat@debian.org>
Date:   Sat Mar 10 19:06:45 2018 +0100

    powerpc: Mark the variable earlycon_acpi_spcr_enable maybe_unused
    
    Re-use the object-like macro EARLYCON_USED_OR_UNUSED to mark
    `earlycon_acpi_spcr_enable` as maybe_unused.
    
    Fix the following warning (treated as error in W=1)
    
      CC      arch/powerpc/kernel/setup-common.o
    In file included from ./include/linux/serial_8250.h:14:0,
                     from arch/powerpc/kernel/setup-common.c:33:
    ./include/linux/serial_core.h:382:19: error: ‘earlycon_acpi_spcr_enable’ defined but not used [-Werror=unused-const-variable=]
     static const bool earlycon_acpi_spcr_enable;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
    cc1: all warnings being treated as errors
    
    Signed-off-by: Mathieu Malaterre <malat@debian.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index b32df49a3bd5..1d356105f25a 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -379,7 +379,7 @@ extern int of_setup_earlycon(const struct earlycon_id *match,
 extern bool earlycon_acpi_spcr_enable __initdata;
 int setup_earlycon(char *buf);
 #else
-static const bool earlycon_acpi_spcr_enable;
+static const bool earlycon_acpi_spcr_enable EARLYCON_USED_OR_UNUSED;
 static inline int setup_earlycon(char *buf) { return 0; }
 #endif
 

commit 54ce685cae30c106f062d714c11e644ab1b93b51
Merge: a051c14b8db3 d4abd46b7e72
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Feb 9 09:44:25 2018 -0800

    Merge tag 'acpi-part2-4.16-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm
    
    Pull more ACPI updates from Rafael Wysocki:
     "These are mostly fixes and cleanups, a few new quirks, a couple of
      updates related to the handling of ACPI tables and ACPICA copyrights
      refreshment.
    
      Specifics:
    
       - Update the ACPICA kernel code to upstream revision 20180105
         including:
           * Assorted fixes (Jung-uk Kim)
           * Support for X32 ABI compilation (Anuj Mittal)
           * Update of ACPICA copyrights to 2018 (Bob Moore)
    
       - Prepare for future modifications to avoid executing the _STA
         control method too early (Hans de Goede)
    
       - Make the processor performance control library code ignore _PPC
         notifications if they cannot be handled and fix up the C1 idle
         state definition when it is used as a fallback state (Chen Yu,
         Yazen Ghannam)
    
       - Make it possible to use the SPCR table on x86 and to replace the
         original IORT table with a new one from initrd (Prarit Bhargava,
         Shunyong Yang)
    
       - Add battery-related quirks for Asus UX360UA and UX410UAK and add
         quirks for table parsing on Dell XPS 9570 and Precision M5530 (Kai
         Heng Feng)
    
       - Address static checker warnings in the CPPC code (Gustavo Silva)
    
       - Avoid printing a raw pointer to the kernel log in the smart battery
         driver (Greg Kroah-Hartman)"
    
    * tag 'acpi-part2-4.16-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/rafael/linux-pm:
      ACPI: sbshc: remove raw pointer from printk() message
      ACPI: SPCR: Make SPCR available to x86
      ACPI / CPPC: Use 64-bit arithmetic instead of 32-bit
      ACPI / tables: Add IORT to injectable table list
      ACPI / bus: Parse tables as term_list for Dell XPS 9570 and Precision M5530
      ACPICA: Update version to 20180105
      ACPICA: All acpica: Update copyrights to 2018
      ACPI / processor: Set default C1 idle state description
      ACPI / battery: Add quirk for Asus UX360UA and UX410UAK
      ACPI: processor_perflib: Do not send _PPC change notification if not ready
      ACPI / scan: Use acpi_bus_get_status() to initialize ACPI_TYPE_DEVICE devs
      ACPI / bus: Do not call _STA on battery devices with unmet dependencies
      PCI: acpiphp_ibm: prepare for acpi_get_object_info() no longer returning status
      ACPI: export acpi_bus_get_status_handle()
      ACPICA: Add a missing pair of parentheses
      ACPICA: Prefer ACPI_TO_POINTER() over ACPI_ADD_PTR()
      ACPICA: Avoid NULL pointer arithmetic
      ACPICA: Linux: add support for X32 ABI compilation
      ACPI / video: Use true for boolean value

commit 0231d00082f61cfe03f2b7c27e5356f8cdf0312c
Author: Prarit Bhargava <prarit@redhat.com>
Date:   Thu Jan 18 10:09:51 2018 -0500

    ACPI: SPCR: Make SPCR available to x86
    
    SPCR is currently only enabled or ARM64 and x86 can use SPCR to setup
    an early console.
    
    General fixes include updating Documentation & Kconfig (for x86),
    updating comments, and changing parse_spcr() to acpi_parse_spcr(),
    and earlycon_init_is_deferred to earlycon_acpi_spcr_enable to be
    more descriptive.
    
    On x86, many systems have a valid SPCR table but the table version is
    not 2 so the table version check must be a warning.
    
    On ARM64 when the kernel parameter earlycon is used both the early console
    and console are enabled.  On x86, only the earlycon should be enabled by
    by default.  Modify acpi_parse_spcr() to allow options for initializing
    the early console and console separately.
    
    Signed-off-by: Prarit Bhargava <prarit@redhat.com>
    Acked-by: Ingo Molnar <mingo@kernel.org>
    Reviewed-by: Mark Salter <msalter@redhat.com>
    Tested-by: Mark Salter <msalter@redhat.com>
    Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 37b044e78333..aefd0e5115da 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -376,10 +376,10 @@ extern int of_setup_earlycon(const struct earlycon_id *match,
 			     const char *options);
 
 #ifdef CONFIG_SERIAL_EARLYCON
-extern bool earlycon_init_is_deferred __initdata;
+extern bool earlycon_acpi_spcr_enable __initdata;
 int setup_earlycon(char *buf);
 #else
-static const bool earlycon_init_is_deferred;
+static const bool earlycon_acpi_spcr_enable;
 static inline int setup_earlycon(char *buf) { return 0; }
 #endif
 

commit 0f646b63a1b2ede7885e45cf6e986128e001f91b
Author: Paul Cercueil <paul@crapouillou.net>
Date:   Thu Dec 28 14:07:07 2017 +0100

    serial: core: Make uart_parse_options take const char* argument
    
    The pointed string is never modified from within uart_parse_options, so
    it should be marked as const in the function prototype.
    
    Signed-off-by: Paul Cercueil <paul@crapouillou.net>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index b60b225c0a59..4c310c34ddad 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -387,7 +387,7 @@ struct uart_port *uart_get_console(struct uart_port *ports, int nr,
 				   struct console *c);
 int uart_parse_earlycon(char *p, unsigned char *iotype, resource_size_t *addr,
 			char **options);
-void uart_parse_options(char *options, int *baud, int *parity, int *bits,
+void uart_parse_options(const char *options, int *baud, int *parity, int *bits,
 			int *flow);
 int uart_set_options(struct uart_port *port, struct console *co, int baud,
 		     int parity, int bits, int flow);

commit 743f93f822be1b54f3f9bd53d13f02192e65ce0b
Author: Lukas Wunner <lukas@wunner.de>
Date:   Fri Nov 24 23:26:40 2017 +0100

    serial: Make retrieval of rs485 properties platform-agnostic
    
    Commit ef838a81dd4d ("serial: Add common rs485 device tree parsing
    function") consolidated retrieval of rs485 OF properties in a common
    helper function but did not #ifdef it to CONFIG_OF.  The function is
    therefore included on ACPI platforms as well even though it's not used.
    
    On the other hand ACPI platforms with rs485 do exist (e.g. Siemens
    IOT2040) and they may leverage _DSD to store rs485 properties.  Likewise,
    UART platform devices instantiated from an MFD should be able to specify
    rs485 properties.  In fact, the tty subsystem maintainer had asked for
    a "generic" function during review of commit ef838a81dd4d:
    https://marc.info/?l=linux-serial&m=150143441725194&w=4
    
    Thus, instead of constraining the helper to OF platforms, make it
    platform-agnostic by converting it to device_property_*() functions
    and renaming it accordingly.
    
    In imx.c, move the invocation of uart_get_rs485_mode() from
    serial_imx_probe_dt() to serial_imx_probe() so that it also gets called
    for non-OF devices.
    
    In omap-serial.c, move its invocation further up within
    serial_omap_probe_rs485() so that the RTS polarity can be overridden
    with the driver-specific "rs485-rts-active-high" property once we
    introduce a generic "rs485-rts-active-low" property.
    
    Cc: Jan Kiszka <jan.kiszka@siemens.com>
    Cc: Richard Genoud <richard.genoud@gmail.com>
    Cc: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Lukas Wunner <lukas@wunner.de>
    Acked-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 37b044e78333..b60b225c0a59 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -501,9 +501,5 @@ static inline int uart_handle_break(struct uart_port *port)
 					 (cflag) & CRTSCTS || \
 					 !((cflag) & CLOCAL))
 
-/*
- * Common device tree parsing helpers
- */
-void of_get_rs485_mode(struct device_node *np, struct serial_rs485 *rs485conf);
-
+void uart_get_rs485_mode(struct device *dev, struct serial_rs485 *rs485conf);
 #endif /* LINUX_SERIAL_CORE_H */

commit ef838a81dd4de1e08454406812e42d7b9b417c4d
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Wed Sep 13 10:18:27 2017 +0200

    serial: Add common rs485 device tree parsing function
    
    Several drivers have the same device tree parsing code. Create
    a common helper function for it.
    
    This patch bases on work done by Sascha Hauer.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 5553e04e59c9..37b044e78333 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -501,4 +501,9 @@ static inline int uart_handle_break(struct uart_port *port)
 					 (cflag) & CRTSCTS || \
 					 !((cflag) & CLOCAL))
 
+/*
+ * Common device tree parsing helpers
+ */
+void of_get_rs485_mode(struct device_node *np, struct serial_rs485 *rs485conf);
+
 #endif /* LINUX_SERIAL_CORE_H */

commit aef3ad103a686f21b746977d4ed21cc1af36f589
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Sun Aug 13 17:47:42 2017 +0300

    serial: core: remove unneeded irq_wake flag
    
    There is no need to duplicate a flag which IRQ core takes care of.
    
    Replace custom flag by IRQ core API that retrieves its state.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 8dc24c855a70..5553e04e59c9 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -247,7 +247,6 @@ struct uart_port {
 	struct device		*dev;			/* parent device */
 	unsigned char		hub6;			/* this should be in the 8250 driver */
 	unsigned char		suspended;
-	unsigned char		irq_wake;
 	unsigned char		unused[2];
 	const char		*name;			/* port name */
 	struct attribute_group	*attr_group;		/* port specific attributes */

commit c7ac15ce89242e3c25fcc49fa4d00028285fab05
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue Jul 25 20:39:58 2017 +0300

    serial: core: move UPF_NO_TXEN_TEST to quirks and rename
    
    First 16 bits in the flags field are user-visible except
    UPF_NO_TXEN_TEST. To keep it clean we introduce internal quirks and move
    UPF_NO_TXEN_TEST to them. Rename the constant to UPQ_NO_TXEN_TEST to
    distinguish with port flags. Users are converted accordingly.
    
    The quirks field might be extended later to hold the additional ones.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 1775500294bb..8dc24c855a70 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -20,7 +20,7 @@
 #ifndef LINUX_SERIAL_CORE_H
 #define LINUX_SERIAL_CORE_H
 
-
+#include <linux/bitops.h>
 #include <linux/compiler.h>
 #include <linux/interrupt.h>
 #include <linux/circ_buf.h>
@@ -144,7 +144,7 @@ struct uart_port {
 	unsigned char		x_char;			/* xon/xoff char */
 	unsigned char		regshift;		/* reg offset shift */
 	unsigned char		iotype;			/* io access style */
-	unsigned char		unused1;
+	unsigned char		quirks;			/* internal quirks */
 
 #define UPIO_PORT		(SERIAL_IO_PORT)	/* 8b I/O port access */
 #define UPIO_HUB6		(SERIAL_IO_HUB6)	/* Hub6 ISA card */
@@ -155,6 +155,9 @@ struct uart_port {
 #define UPIO_MEM32BE		(SERIAL_IO_MEM32BE)	/* 32b big endian */
 #define UPIO_MEM16		(SERIAL_IO_MEM16)	/* 16b little endian */
 
+	/* quirks must be updated while holding port mutex */
+#define UPQ_NO_TXEN_TEST	BIT(0)
+
 	unsigned int		read_status_mask;	/* driver specific */
 	unsigned int		ignore_status_mask;	/* driver specific */
 	struct uart_state	*state;			/* pointer to parent state */
@@ -175,7 +178,6 @@ struct uart_port {
 	 * [for bit definitions in the UPF_CHANGE_MASK]
 	 *
 	 * Bits [0..UPF_LAST_USER] are userspace defined/visible/changeable
-	 * except bit 15 (UPF_NO_TXEN_TEST) which is masked off.
 	 * The remaining bits are serial-core specific and not modifiable by
 	 * userspace.
 	 */
@@ -192,7 +194,6 @@ struct uart_port {
 #define UPF_SPD_SHI		((__force upf_t) ASYNC_SPD_SHI        /* 12 */ )
 #define UPF_LOW_LATENCY		((__force upf_t) ASYNC_LOW_LATENCY    /* 13 */ )
 #define UPF_BUGGY_UART		((__force upf_t) ASYNC_BUGGY_UART     /* 14 */ )
-#define UPF_NO_TXEN_TEST	((__force upf_t) (1 << 15))
 #define UPF_MAGIC_MULTIPLIER	((__force upf_t) ASYNC_MAGIC_MULTIPLIER /* 16 */ )
 
 #define UPF_NO_THRE_TEST	((__force upf_t) (1 << 19))

commit ea5244e2af3b4813bf3d90ba6a6481d1a3c33d15
Author: Joel Stanley <joel@jms.id.au>
Date:   Tue May 2 17:15:42 2017 +0930

    serial: 8250: Add flag so drivers can avoid THRE probe
    
    The probing of THRE irq behaviour assumes the other end will be reading
    bytes out of the buffer in order to probe the port at driver init. In
    some cases the other end cannot be relied upon to read these bytes, so
    provide a flag for them to skip this step.
    
    Bit 19 was chosen as the flags are a int and the top bits are taken.
    
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Joel Stanley <joel@jms.id.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 64d892f1e5cd..1775500294bb 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -195,6 +195,7 @@ struct uart_port {
 #define UPF_NO_TXEN_TEST	((__force upf_t) (1 << 15))
 #define UPF_MAGIC_MULTIPLIER	((__force upf_t) ASYNC_MAGIC_MULTIPLIER /* 16 */ )
 
+#define UPF_NO_THRE_TEST	((__force upf_t) (1 << 19))
 /* Port has hardware-assisted h/w flow control */
 #define UPF_AUTO_CTS		((__force upf_t) (1 << 20))
 #define UPF_AUTO_RTS		((__force upf_t) (1 << 21))

commit 2e94d5ae5da1d2e798045a53b5e234a42b090908
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Mar 31 21:35:17 2017 +0300

    serial: core: constify struct uart_port {name} field
    
    Don't allow modifications of port name. It's serial core's business only.
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 60530678c633..64d892f1e5cd 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -247,7 +247,7 @@ struct uart_port {
 	unsigned char		suspended;
 	unsigned char		irq_wake;
 	unsigned char		unused[2];
-	char			*name;			/* port name */
+	const char		*name;			/* port name */
 	struct attribute_group	*attr_group;		/* port specific attributes */
 	const struct attribute_group **tty_groups;	/* all attributes (serial core use only) */
 	struct serial_rs485     rs485;

commit f7048b15900f36fe21398fba94777b8aab3b376d
Author: Vignesh R <vigneshr@ti.com>
Date:   Fri Mar 24 10:57:59 2017 +0530

    tty: serial_core: Add name field to uart_port struct
    
    Introduce a field to store name of uart_port that can be used to easily
    identify UART port instances on a system that has more than one UART
    instance. The name is of the form ttyXN(eg. ttyS0, ttyAMA0,..) where N
    is number that particular UART instance.
    This field will be useful when printing debug info for a particular port
    or in register IRQs with unique IRQ name. Port name is populated during
    uart_add_one_port().
    
    Signed-off-by: Vignesh R <vigneshr@ti.com>
    Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 58484fb35cc8..60530678c633 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -247,6 +247,7 @@ struct uart_port {
 	unsigned char		suspended;
 	unsigned char		irq_wake;
 	unsigned char		unused[2];
+	char			*name;			/* port name */
 	struct attribute_group	*attr_group;		/* port specific attributes */
 	const struct attribute_group **tty_groups;	/* all attributes (serial core use only) */
 	struct serial_rs485     rs485;

commit 732dbf3a6104a3abfcfcd066dcaf89e5054ce009
Author: Felix Fietkau <nbd@nbd.name>
Date:   Thu Dec 22 08:31:34 2016 +0100

    serial: do not accept sysrq characters via serial port
    
    many embedded boards have a disconnected TTL level serial which can
    generate some garbage that can lead to spurious false sysrq detects.
    
    Signed-off-by: John Crispin <john@phrozen.org>
    Signed-off-by: Felix Fietkau <nbd@nbd.name>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 5def8e830fb0..58484fb35cc8 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -450,7 +450,7 @@ extern void uart_handle_cts_change(struct uart_port *uport,
 extern void uart_insert_char(struct uart_port *port, unsigned int status,
 		 unsigned int overrun, unsigned int ch, unsigned int flag);
 
-#ifdef SUPPORT_SYSRQ
+#if defined(SUPPORT_SYSRQ) && defined(CONFIG_MAGIC_SYSRQ_SERIAL)
 static inline int
 uart_handle_sysrq_char(struct uart_port *port, unsigned int ch)
 {

commit 9efeccacd3a486128d3add611dd4cefb5b60a58c
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Sun Dec 11 06:34:53 2016 +0200

    linux: drop __bitwise__ everywhere
    
    __bitwise__ used to mean "yes, please enable sparse checks
    unconditionally", but now that we dropped __CHECK_ENDIAN__
    __bitwise is exactly the same.
    There aren't many users, replace it by __bitwise everywhere.
    
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Acked-by: Stefan Schmidt <stefan@osg.samsung.com>
    Acked-by: Krzysztof Kozlowski <krzk@kernel.org>
    Akced-by: Lee Duncan <lduncan@suse.com>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 5d494888a612..5def8e830fb0 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -111,8 +111,8 @@ struct uart_icount {
 	__u32	buf_overrun;
 };
 
-typedef unsigned int __bitwise__ upf_t;
-typedef unsigned int __bitwise__ upstat_t;
+typedef unsigned int __bitwise upf_t;
+typedef unsigned int __bitwise upstat_t;
 
 struct uart_port {
 	spinlock_t		lock;			/* port lock */

commit db405a8f8bf70daf57ed88808a2bf9c5fe308c70
Author: Ed Blake <ed.blake@imgtec.com>
Date:   Thu Nov 10 18:07:55 2016 +0000

    serial: 8250: Expose set_ldisc function
    
    Expose set_ldisc() function so that it can be overridden with a
    platform specific implementation.
    
    Signed-off-by: Ed Blake <ed.blake@imgtec.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 344201437017..5d494888a612 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -123,6 +123,8 @@ struct uart_port {
 	void			(*set_termios)(struct uart_port *,
 				               struct ktermios *new,
 				               struct ktermios *old);
+	void			(*set_ldisc)(struct uart_port *,
+					     struct ktermios *);
 	unsigned int		(*get_mctrl)(struct uart_port *);
 	void			(*set_mctrl)(struct uart_port *, unsigned int);
 	int			(*startup)(struct uart_port *port);

commit ad1696f6f09daacfdf2bf04bc83cd8f48d80e34a
Author: Aleksey Makarov <aleksey.makarov@linaro.org>
Date:   Tue Sep 27 23:54:13 2016 +0300

    ACPI: parse SPCR and enable matching console
    
    'ARM Server Base Boot Requiremets' [1] mentions SPCR (Serial Port
    Console Redirection Table) [2] as a mandatory ACPI table that
    specifies the configuration of serial console.
    
    Defer initialization of DT earlycon until ACPI/DT decision is made.
    
    Parse the ACPI SPCR table, setup earlycon if required,
    enable specified console.
    
    Thanks to Peter Hurley for explaining how this should work.
    
    [1] http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0044a/index.html
    [2] https://msdn.microsoft.com/en-us/library/windows/hardware/dn639132(v=vs.85).aspx
    
    Signed-off-by: Aleksey Makarov <aleksey.makarov@linaro.org>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Reviewed-by: Peter Hurley <peter@hurleysoftware.com>
    Tested-by: Kefeng Wang <wangkefeng.wang@huawei.com>
    Tested-by: Christopher Covington <cov@codeaurora.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 378d80a8dd43..344201437017 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -367,11 +367,18 @@ extern const struct earlycon_id __earlycon_table_end[];
 
 #define EARLYCON_DECLARE(_name, fn)	OF_EARLYCON_DECLARE(_name, "", fn)
 
-extern int setup_earlycon(char *buf);
 extern int of_setup_earlycon(const struct earlycon_id *match,
 			     unsigned long node,
 			     const char *options);
 
+#ifdef CONFIG_SERIAL_EARLYCON
+extern bool earlycon_init_is_deferred __initdata;
+int setup_earlycon(char *buf);
+#else
+static const bool earlycon_init_is_deferred;
+static inline int setup_earlycon(char *buf) { return 0; }
+#endif
+
 struct uart_port *uart_get_console(struct uart_port *ports, int nr,
 				   struct console *c);
 int uart_parse_earlycon(char *p, unsigned char *iotype, resource_size_t *addr,

commit a727b025f43d7952c0697562f5cecda9f42758aa
Author: Rob Herring <robh@kernel.org>
Date:   Fri Sep 9 17:37:02 2016 -0500

    tty: serial_core: add tty NULL check to uart_tx_stopped
    
    Commit 761ed4a94582 ("tty: serial_core: convert uart_close to use
    tty_port_close") created a case where a port used for a console does not
    get shutdown on tty closing. Then a call to uart_tx_stopped() segfaults
    because the tty is NULL. This could be fixed to restore old behavior,
    but we also want to allow tty_ports to work without a tty attached. So
    this change to allow a NULL tty_struct is needed either way.
    
    Fixes: 761ed4a94582 ("tty: serial_core: convert uart_close to use tty_port_close")
    Reported-by: kernel test robot <xiaolong.ye@intel.com>
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index cdba6f144f72..378d80a8dd43 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -412,7 +412,7 @@ int uart_resume_port(struct uart_driver *reg, struct uart_port *port);
 static inline int uart_tx_stopped(struct uart_port *port)
 {
 	struct tty_struct *tty = port->state->port.tty;
-	if (tty->stopped || port->hw_stopped)
+	if ((tty && tty->stopped) || port->hw_stopped)
 		return 1;
 	return 0;
 }

commit 46e36683f433528bfb7e5754ca5c5c86c204c40a
Author: Alexander Sverdlin <alexander.sverdlin@nokia.com>
Date:   Fri Sep 2 13:20:21 2016 +0200

    serial: earlycon: Extend earlycon command line option to support 64-bit addresses
    
    earlycon implementation used "unsigned long" internally, but there are systems
    (ARM with LPAE) where sizeof(unsigned long) == 4 and uart is mapped beyond 4GiB
    address range.
    
    Switch to resource_size_t internally and replace obsoleted simple_strtoul() with
    kstrtoull().
    
    Signed-off-by: Alexander Sverdlin <alexander.sverdlin@nokia.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 2f44e2013654..cdba6f144f72 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -374,7 +374,7 @@ extern int of_setup_earlycon(const struct earlycon_id *match,
 
 struct uart_port *uart_get_console(struct uart_port *ports, int nr,
 				   struct console *c);
-int uart_parse_earlycon(char *p, unsigned char *iotype, unsigned long *addr,
+int uart_parse_earlycon(char *p, unsigned char *iotype, resource_size_t *addr,
 			char **options);
 void uart_parse_options(char *options, int *baud, int *parity, int *bits,
 			int *flow);

commit f8ba3647f30ab22daeb5110453e2dad8a2c1d841
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Jun 6 18:41:00 2016 +0900

    earlycon: mark earlycon code as __used iif the caller is built-in
    
    Keep earlycon related symbols only when CONFIG_SERIAL_EARLYCON is
    enabled and the driver is built-in.  This will be helpful to clean
    up ifdefs surrounding earlycon code in serial drivers.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index a3d7c0d4a03e..2f44e2013654 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -352,9 +352,15 @@ struct earlycon_id {
 extern const struct earlycon_id __earlycon_table[];
 extern const struct earlycon_id __earlycon_table_end[];
 
+#if defined(CONFIG_SERIAL_EARLYCON) && !defined(MODULE)
+#define EARLYCON_USED_OR_UNUSED	__used
+#else
+#define EARLYCON_USED_OR_UNUSED	__maybe_unused
+#endif
+
 #define OF_EARLYCON_DECLARE(_name, compat, fn)				\
 	static const struct earlycon_id __UNIQUE_ID(__earlycon_##_name)	\
-	     __used __section(__earlycon_table)				\
+	     EARLYCON_USED_OR_UNUSED __section(__earlycon_table)	\
 		= { .name = __stringify(_name),				\
 		    .compatible = compat,				\
 		    .setup = fn  }

commit 144ef5c2df9b473dad7eab375adcf5b11d0b1e47
Author: Wan Ahmad Zainie <wan.ahmad.zainie.wan.mohamad@intel.com>
Date:   Wed Apr 6 12:06:51 2016 +0800

    serial: 8250: export get_mctrl function
    
    Exposes get_mctrl() function so that it can be overriden with platform
    specific implementation.
    
    Signed-off-by: Wan Ahmad Zainie <wan.ahmad.zainie.wan.mohamad@intel.com>
    Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Reviewed-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index fd4ad4dce11a..a3d7c0d4a03e 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -123,6 +123,7 @@ struct uart_port {
 	void			(*set_termios)(struct uart_port *,
 				               struct ktermios *new,
 				               struct ktermios *old);
+	unsigned int		(*get_mctrl)(struct uart_port *);
 	void			(*set_mctrl)(struct uart_port *, unsigned int);
 	int			(*startup)(struct uart_port *port);
 	void			(*shutdown)(struct uart_port *port);

commit 9ed19428a51d53477e2b79be3303fa08f8575749
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sat Apr 9 18:56:34 2016 -0700

    serial: core: Prevent unsafe uart port access, part 2
    
    For serial core operations not already excluded by holding port->mutex,
    use reference counting to protect deferencing the state->uart_port.
    
    Introduce helper functions, uart_port_ref() and uart_port_deref(), to
    wrap uart_port access, and helper macros, uart_port_lock() and
    uart_port_unlock(), to wrap combination uart_port access with uart
    port lock sections.
    
    Port removal in uart_remove_one_port() waits for reference count to
    drop to zero before detaching the uart port from struct uart_state.
    
    For functions only reading the tx circular buffer indexes (where the
    uart port lock is claimed to prevent concurrent users), a NULL uart
    port is simply ignored and the operation completes normally.
    
    For functions change the tx circular buffer indexes (where the uart
    port lock is claimed to prevent concurrent users), the operation is
    aborted if the uart port is NULL (ie., has been detached).
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index cbfcf38e220d..fd4ad4dce11a 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -281,6 +281,8 @@ struct uart_state {
 	enum uart_pm_state	pm_state;
 	struct circ_buf		xmit;
 
+	atomic_t		refcount;
+	wait_queue_head_t	remove_wait;
 	struct uart_port	*uart_port;
 };
 

commit c90fe9c0394b068ceca16f66e9f35bcd8d948295
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sat Jan 16 15:23:44 2016 -0800

    of: earlycon: Move address translation to of_setup_earlycon()
    
    Cleanup the early DT/earlycon separation; remove the 'addr' parameter
    from of_setup_earlycon() and get the uart phys addr directly with a
    new wrapper function, of_flat_dt_translate_addr(). Limit
    fdt_translate_address() to file scope.
    
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 6d1bed821181..cbfcf38e220d 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -359,7 +359,7 @@ extern const struct earlycon_id __earlycon_table_end[];
 #define EARLYCON_DECLARE(_name, fn)	OF_EARLYCON_DECLARE(_name, "", fn)
 
 extern int setup_earlycon(char *buf);
-extern int of_setup_earlycon(unsigned long addr, const struct earlycon_id *match,
+extern int of_setup_earlycon(const struct earlycon_id *match,
 			     unsigned long node,
 			     const char *options);
 

commit 088da2a17619cf0113b62a76ad38c6a14470ffa6
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sat Jan 16 15:23:43 2016 -0800

    of: earlycon: Initialize port fields from DT properties
    
    Read the optional "reg-offset", "reg-shift", "reg-io-width" and endianness
    properties and initialize the respective struct uart_port field if found.
    
    NB: These bindings are common to several drivers and the values merely
    indicate the default value; the registering earlycon setup() method can
    simply override the values if required.
    
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 62a4df05eaca..6d1bed821181 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -360,6 +360,7 @@ extern const struct earlycon_id __earlycon_table_end[];
 
 extern int setup_earlycon(char *buf);
 extern int of_setup_earlycon(unsigned long addr, const struct earlycon_id *match,
+			     unsigned long node,
 			     const char *options);
 
 struct uart_port *uart_get_console(struct uart_port *ports, int nr,

commit 4d118c9a866590850dad8689262a95345d2c6e09
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sat Jan 16 15:23:42 2016 -0800

    of: earlycon: Add options string handling
    
    Pass-through any options string in the 'stdout-path' property to the
    earlycon "driver" setup.
    
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 63fdb55e4c9d..62a4df05eaca 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -359,7 +359,8 @@ extern const struct earlycon_id __earlycon_table_end[];
 #define EARLYCON_DECLARE(_name, fn)	OF_EARLYCON_DECLARE(_name, "", fn)
 
 extern int setup_earlycon(char *buf);
-extern int of_setup_earlycon(unsigned long addr, const struct earlycon_id *match);
+extern int of_setup_earlycon(unsigned long addr, const struct earlycon_id *match,
+			     const char *options);
 
 struct uart_port *uart_get_console(struct uart_port *ports, int nr,
 				   struct console *c);

commit 05d961320ba624c98b16d72b32f947307674b341
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sat Jan 16 15:23:41 2016 -0800

    of: earlycon: Fixup earlycon console name and index
    
    Use the console name embedded in the OF earlycon table by the
    OF_EARLYCON_DECLARE() macro to initialize the struct console 'name'
    and 'index' fields.
    
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 25e05147f379..63fdb55e4c9d 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -359,8 +359,7 @@ extern const struct earlycon_id __earlycon_table_end[];
 #define EARLYCON_DECLARE(_name, fn)	OF_EARLYCON_DECLARE(_name, "", fn)
 
 extern int setup_earlycon(char *buf);
-extern int of_setup_earlycon(unsigned long addr,
-			     int (*setup)(struct earlycon_device *, const char *));
+extern int of_setup_earlycon(unsigned long addr, const struct earlycon_id *match);
 
 struct uart_port *uart_get_console(struct uart_port *ports, int nr,
 				   struct console *c);

commit 2eaa790989e03900298ad24f77f1086dbbc1aebd
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sat Jan 16 15:23:39 2016 -0800

    earlycon: Use common framework for earlycon declarations
    
    Use a single common table of struct earlycon_id for both command line
    and devicetree. Re-define OF_EARLYCON_DECLARE() macro to instance a
    unique earlycon declaration (the declaration is only guaranteed to be
    unique within a compilation unit; separate compilation units must still
    use unique earlycon names).
    
    The semantics of OF_EARLYCON_DECLARE() is different; it declares an
    earlycon which can matched either on the command line or by devicetree.
    EARLYCON_DECLARE() is semantically unchanged; it declares an earlycon
    which is matched by command line only. Remove redundant instances of
    EARLYCON_DECLARE().
    
    This enables all earlycons to properly initialize struct console
    with the appropriate name and index, which improves diagnostics and
    enables direct earlycon-to-console handoff.
    
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index e03d6ba5e5b4..25e05147f379 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -342,22 +342,26 @@ struct earlycon_device {
 
 struct earlycon_id {
 	char	name[16];
+	char	compatible[128];
 	int	(*setup)(struct earlycon_device *, const char *options);
 } __aligned(32);
 
+extern const struct earlycon_id __earlycon_table[];
+extern const struct earlycon_id __earlycon_table_end[];
+
+#define OF_EARLYCON_DECLARE(_name, compat, fn)				\
+	static const struct earlycon_id __UNIQUE_ID(__earlycon_##_name)	\
+	     __used __section(__earlycon_table)				\
+		= { .name = __stringify(_name),				\
+		    .compatible = compat,				\
+		    .setup = fn  }
+
+#define EARLYCON_DECLARE(_name, fn)	OF_EARLYCON_DECLARE(_name, "", fn)
+
 extern int setup_earlycon(char *buf);
 extern int of_setup_earlycon(unsigned long addr,
 			     int (*setup)(struct earlycon_device *, const char *));
 
-#define EARLYCON_DECLARE(_name, func)					\
-	static const struct earlycon_id __earlycon_##_name		\
-		__used __section(__earlycon_table)			\
-		 = { .name  = __stringify(_name),			\
-		     .setup = func  }
-
-#define OF_EARLYCON_DECLARE(name, compat, fn)				\
-	_OF_DECLARE(earlycon, name, compat, fn, void *)
-
 struct uart_port *uart_get_console(struct uart_port *ports, int nr,
 				   struct console *c);
 int uart_parse_earlycon(char *p, unsigned char *iotype, unsigned long *addr,

commit 858965d909db32fb567a06916bbebdb8951cd39e
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Fri Nov 27 21:29:24 2015 -0500

    serial: Fix UPIO_MEM comment
    
    The original semantics of UPIO_MEM did not include the notion of bitness
    and endianness; different drivers used UPIO_MEM to refer to their original
    mmio bitness/endianness. For example, for the 8250 driver this is 8-bit LE
    but for the amba-pl011 driver this is 16-bit LE. Since UPIO_* values are
    userspace ABI via TIOCGSERIAL/TIOCSSERIAL ioctls, the original meaning of
    UPIIO_MEM must remain as it was: the original mmio stride/width/endianness
    of the driver.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Acked-by: Timur Tabi <timur@codeaurora.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 35aa87b96b71..e03d6ba5e5b4 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -145,7 +145,7 @@ struct uart_port {
 
 #define UPIO_PORT		(SERIAL_IO_PORT)	/* 8b I/O port access */
 #define UPIO_HUB6		(SERIAL_IO_HUB6)	/* Hub6 ISA card */
-#define UPIO_MEM		(SERIAL_IO_MEM)		/* 8b MMIO access */
+#define UPIO_MEM		(SERIAL_IO_MEM)		/* driver-specific */
 #define UPIO_MEM32		(SERIAL_IO_MEM32)	/* 32b little endian */
 #define UPIO_AU			(SERIAL_IO_AU)		/* Au1x00 and RT288x type IO */
 #define UPIO_TSI		(SERIAL_IO_TSI)		/* Tsi108/109 type IO */

commit bd94c4077a0b2ecc35562c294f80f3659ecd8499
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Wed Oct 28 12:46:05 2015 +0900

    serial: support 16-bit register interface for console
    
    Currently, 8-bit (MMIO) and 32-bit (MMIO32) register interfaces are
    supported for the 8250 console, but the 16-bit (MMIO16) is not.
    The 8250 UART device on my board is connected to a 16-bit bus and
    my main motivation is to use earlycon with it.
    (Refer to arch/arm/boot/dts/uniphier-support-card.dtsi)
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Reviewed-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 297d4fa1cfe5..35aa87b96b71 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -150,6 +150,7 @@ struct uart_port {
 #define UPIO_AU			(SERIAL_IO_AU)		/* Au1x00 and RT288x type IO */
 #define UPIO_TSI		(SERIAL_IO_TSI)		/* Tsi108/109 type IO */
 #define UPIO_MEM32BE		(SERIAL_IO_MEM32BE)	/* 32b big endian */
+#define UPIO_MEM16		(SERIAL_IO_MEM16)	/* 16b little endian */
 
 	unsigned int		read_status_mask;	/* driver specific */
 	unsigned int		ignore_status_mask;	/* driver specific */

commit 6b3cddccf4eec0883feb065aea28dd9770bb17d0
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sat Apr 11 11:02:36 2015 -0400

    serial: core: Fix unused variable warnings from uart_console()
    
    If CONFIG_SERIAL_CORE_CONSOLE=n, build warnings are generated by
    uart_console() macro expansion:
    
    drivers/tty/serial/of_serial.c: In function ‘of_serial_suspend_8250’:
    drivers/tty/serial/of_serial.c:262:20: warning: unused variable ‘port’ [-Wunused-variable]
      struct uart_port *port = &port8250->port;
                        ^
    drivers/tty/serial/of_serial.c: In function ‘of_serial_resume_8250’:
    drivers/tty/serial/of_serial.c:272:20: warning: unused variable ‘port’ [-Wunused-variable]
      struct uart_port *port = &port8250->port;
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 025dad9dcde4..297d4fa1cfe5 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -35,7 +35,7 @@
 #define uart_console(port) \
 	((port)->cons && (port)->cons->index == (port)->line)
 #else
-#define uart_console(port)      (0)
+#define uart_console(port)      ({ (void)port; 0; })
 #endif
 
 struct uart_port;

commit 99492c39f39fc2d8c4ae36ecfb88d7de5d8106b5
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Fri Apr 3 08:57:51 2015 -0400

    earlycon: Fix __earlycon_table stride
    
    The compiler and the linker must agree on the alignment of
    struct earlycon_id; empirical testing and commit 07fca0e57fca92
    ("tracing: Properly align linker defined symbols") suggests
    32-byte alignment is the LCD.
    
    Reported-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 34de16840152..025dad9dcde4 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -342,7 +342,7 @@ struct earlycon_device {
 struct earlycon_id {
 	char	name[16];
 	int	(*setup)(struct earlycon_device *, const char *options);
-};
+} __aligned(32);
 
 extern int setup_earlycon(char *buf);
 extern int of_setup_earlycon(unsigned long addr,

commit ee97d0e3f06498487671c23cad4230bf9aa5fd88
Author: Mans Rullgard <mans@mansr.com>
Date:   Sun Mar 8 14:30:04 2015 +0000

    serial: 8250: allow specifying iomem size in addition to address
    
    This adds a mapsize field to struct uart_port to be used in
    conjunction with mapbase. If set, it overrides whatever value
    serial8250_port_size() would otherwise report.
    
    Signed-off-by: Mans Rullgard <mans@mansr.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 8aeec4913a9c..34de16840152 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -237,6 +237,7 @@ struct uart_port {
 	unsigned int		line;			/* port index */
 	unsigned int		minor;
 	resource_size_t		mapbase;		/* for ioremap */
+	resource_size_t		mapsize;
 	struct device		*dev;			/* parent device */
 	unsigned char		hub6;			/* this should be in the 8250 driver */
 	unsigned char		suspended;

commit 470ca0de69feaba5df215ad804cec1859883a5ed
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Mon Mar 9 16:27:21 2015 -0400

    serial: earlycon: Enable earlycon without command line param
    
    Earlycon matching can only be triggered if 'earlycon=...' has been
    specified on the kernel command line. To workaround this limitation
    requires tight coupling between arches and specific serial drivers
    in order to start an earlycon. Devicetree avoids this limitation
    with a link table that contains the required data to match earlycons.
    
    Mirror this approach for earlycon match by name. Re-purpose
    EARLYCON_DECLARE to generate a table entry which associates name with
    setup() function. Re-purpose setup_earlycon() to scan this table for
    an earlycon match, which is registered if found.
    
    Declare one "earlycon" early_param, which calls setup_earlycon().
    
    This design allows setup_earlycon() to be called directly with a
    param string (as if 'earlycon=...' had been set on the command line).
    Re-registration (either directly or by early_param) is prevented.
    
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 980170e5a982..8aeec4913a9c 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -337,18 +337,21 @@ struct earlycon_device {
 	char options[16];		/* e.g., 115200n8 */
 	unsigned int baud;
 };
-int setup_earlycon(char *buf, const char *match,
-		   int (*setup)(struct earlycon_device *, const char *));
 
+struct earlycon_id {
+	char	name[16];
+	int	(*setup)(struct earlycon_device *, const char *options);
+};
+
+extern int setup_earlycon(char *buf);
 extern int of_setup_earlycon(unsigned long addr,
 			     int (*setup)(struct earlycon_device *, const char *));
 
-#define EARLYCON_DECLARE(name, func) \
-static int __init name ## _setup_earlycon(char *buf) \
-{ \
-	return setup_earlycon(buf, __stringify(name), func); \
-} \
-early_param("earlycon", name ## _setup_earlycon);
+#define EARLYCON_DECLARE(_name, func)					\
+	static const struct earlycon_id __earlycon_##_name		\
+		__used __section(__earlycon_table)			\
+		 = { .name  = __stringify(_name),			\
+		     .setup = func  }
 
 #define OF_EARLYCON_DECLARE(name, compat, fn)				\
 	_OF_DECLARE(earlycon, name, compat, fn, void *)

commit 959801fef94b7ee66ea2c713229637a7e1770890
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Tue Feb 24 14:25:00 2015 -0500

    serial: core: Add minor field to uart_port
    
    UART drivers that share ttyS namespace cannot trivially compute the
    ttyS index from the port->line value since the minor_start may be
    offset from minor 64. Further, to do so requires a pointer to the
    uart driver since there is no back pointer from uart_port to
    uart_driver.
    
    Rather than have UART drivers computing the minor value by themselves,
    encapsulate within the serial core at port registration time.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index b0148e7bcbfa..980170e5a982 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -235,6 +235,7 @@ struct uart_port {
 	const struct uart_ops	*ops;
 	unsigned int		custom_divisor;
 	unsigned int		line;			/* port index */
+	unsigned int		minor;
 	resource_size_t		mapbase;		/* for ioremap */
 	struct device		*dev;			/* parent device */
 	unsigned char		hub6;			/* this should be in the 8250 driver */

commit becba85f0e1ca8ab97bd7e836a7129a94ace1ff2
Merge: 9eccca084320 3372ec286220
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Mon Mar 9 07:08:37 2015 +0100

    Merge 4.0-rc3 into tty-testing
    
    This resolves a merge issue in drivers/tty/serial/8250/8250_pci.c
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit 73abaf87f01be6fa6da3c0aa9c138a1b6b281068
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sun Mar 1 11:05:46 2015 -0500

    serial: earlycon: Refactor parse_options into serial core
    
    Prepare to support console-defined matching; refactor the command
    line parameter string processing from parse_options() into a
    new core function, uart_parse_earlycon(), which decodes command line
    parameters of the form:
       earlycon=<name>,io|mmio|mmio32,<addr>,<options>
       console=<name>,io|mmio|mmio32,<addr>,<options>
       earlycon=<name>,0x<addr>,<options>
       console=<name>,0x<addr>,<options>
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index baf3e1d08416..cc5c506f07dd 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -354,6 +354,8 @@ early_param("earlycon", name ## _setup_earlycon);
 
 struct uart_port *uart_get_console(struct uart_port *ports, int nr,
 				   struct console *c);
+int uart_parse_earlycon(char *p, unsigned char *iotype, unsigned long *addr,
+			char **options);
 void uart_parse_options(char *options, int *baud, int *parity, int *bits,
 			int *flow);
 int uart_set_options(struct uart_port *port, struct console *co, int baud,

commit 647f162b8e7e446c4bade031eb8a1a0a83d3de82
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sun Mar 1 10:24:28 2015 -0500

    serial: uapi: Declare all userspace-visible io types
    
    ioctl(TIOCGSERIAL|TIOCSSERIAL) report and can change the port->iotype.
    UART drivers use the UPIO_* definitions, but the uapi header defines
    parallel values and userspace uses these parallel values for ioctls;
    thus the userspace values are definitive.
    
    Define UPIO_* iotypes in terms of the uapi defines, SERIAL_IO_*;
    extend the uapi defines to include all values in use by the serial
    core.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 1094f2d9cadb..d10965f0d8a4 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -143,13 +143,13 @@ struct uart_port {
 	unsigned char		iotype;			/* io access style */
 	unsigned char		unused1;
 
-#define UPIO_PORT		(0)			/* 8b I/O port access */
-#define UPIO_HUB6		(1)			/* Hub6 ISA card */
-#define UPIO_MEM		(2)			/* 8b MMIO access */
-#define UPIO_MEM32		(3)			/* 32b little endian */
-#define UPIO_AU			(4)			/* Au1x00 and RT288x type IO */
-#define UPIO_TSI		(5)			/* Tsi108/109 type IO */
-#define UPIO_MEM32BE		(6)			/* 32b big endian */
+#define UPIO_PORT		(SERIAL_IO_PORT)	/* 8b I/O port access */
+#define UPIO_HUB6		(SERIAL_IO_HUB6)	/* Hub6 ISA card */
+#define UPIO_MEM		(SERIAL_IO_MEM)		/* 8b MMIO access */
+#define UPIO_MEM32		(SERIAL_IO_MEM32)	/* 32b little endian */
+#define UPIO_AU			(SERIAL_IO_AU)		/* Au1x00 and RT288x type IO */
+#define UPIO_TSI		(SERIAL_IO_TSI)		/* Tsi108/109 type IO */
+#define UPIO_MEM32BE		(SERIAL_IO_MEM32BE)	/* 32b big endian */
 
 	unsigned int		read_status_mask;	/* driver specific */
 	unsigned int		ignore_status_mask;	/* driver specific */

commit 2bb785169e9709d41220e5c18b0270883a82f85c
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sun Mar 1 10:18:16 2015 -0500

    serial: core: Fix iotype userspace breakage
    
    commit 3ffb1a8193bea ("serial: core: Add big-endian iotype")
    re-numbered userspace-dependent values; ioctl(TIOCSSERIAL) can
    assign the port iotype (which is expected to match the selected
    i/o accessors), so iotype values must not be changed.
    
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: <stable@vger.kernel.org> # 3.19+
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Reviewed-by: Kevin Cernekee <cernekee@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index baf3e1d08416..1094f2d9cadb 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -147,9 +147,9 @@ struct uart_port {
 #define UPIO_HUB6		(1)			/* Hub6 ISA card */
 #define UPIO_MEM		(2)			/* 8b MMIO access */
 #define UPIO_MEM32		(3)			/* 32b little endian */
-#define UPIO_MEM32BE		(4)			/* 32b big endian */
-#define UPIO_AU			(5)			/* Au1x00 and RT288x type IO */
-#define UPIO_TSI		(6)			/* Tsi108/109 type IO */
+#define UPIO_AU			(4)			/* Au1x00 and RT288x type IO */
+#define UPIO_TSI		(5)			/* Tsi108/109 type IO */
+#define UPIO_MEM32BE		(6)			/* 32b big endian */
 
 	unsigned int		read_status_mask;	/* driver specific */
 	unsigned int		ignore_status_mask;	/* driver specific */

commit 391f93f2ec9f857c83bdd21a14dcf7e699f38579
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Sun Jan 25 14:44:51 2015 -0500

    serial: core: Rework hw-assisted flow control support
    
    hw-assisted flow control support was added to the serial core
    in v3.8 with commits,
    dba05832cbe4f ("SERIAL: core: add hardware assisted h/w flow control support")
    2cbacafd7af0f ("SERIAL: core: add hardware assisted s/w flow control support")
    9aba8d5b01119 ("SERIAL: core: add throttle/unthrottle callbacks for hardware
                    assisted flow control")
    Since then, additional requirements for serial core support have arisen.
    Specifically,
    1. Separate tx and rx flow control settings for UARTs which only support
       tx flow control (ie., autoCTS).
    2. Disable sw-assisted CTS flow control in autoCTS mode
    3. Support for RTS flow control by serial core and userspace in autoRTS mode
    
    Distinguish mode from capability; introduce UPSTAT_AUTORTS, UPSTAT_AUTOCTS
    and UPSTAT_AUTOXOFF which, when set by the uart driver, enable serial core
    support for hw-assisted rx, hw-assisted tx and hw-assisted in-band/IXOFF
    rx flow control, respectively. [Note: hw-assisted in-band/IXON tx flow
    control does not require serial core support/intervention and can be
    enabled by the uart driver when required.]
    
    These modes must be set/reset in the driver's set_termios() method, based
    on termios settings, and thus can be safely queried in any context in which
    one of the port lock, port mutex or termios rwsem are held. Set these modes
    in the 2 in-tree drivers, omap-serial and 8250_omap, which currently
    use UPF_HARD_FLOW/UPF_SOFT_FLOW support.
    
    Retain UPF_HARD_FLOW and UPF_SOFT_FLOW as capabilities; re-define
    UPF_HARD_FLOW as both UPF_AUTO_RTS and UPF_AUTO_CTS to allow for distinct
    and separate rx and tx flow control capabilities.
    
    Disable sw-assisted CTS flow control when UPSTAT_AUTOCTS is enabled.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index a0c7033d5f91..baf3e1d08416 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -191,8 +191,10 @@ struct uart_port {
 #define UPF_NO_TXEN_TEST	((__force upf_t) (1 << 15))
 #define UPF_MAGIC_MULTIPLIER	((__force upf_t) ASYNC_MAGIC_MULTIPLIER /* 16 */ )
 
-/* Port has hardware-assisted h/w flow control (iow, auto-RTS *not* auto-CTS) */
-#define UPF_HARD_FLOW		((__force upf_t) (1 << 21))
+/* Port has hardware-assisted h/w flow control */
+#define UPF_AUTO_CTS		((__force upf_t) (1 << 20))
+#define UPF_AUTO_RTS		((__force upf_t) (1 << 21))
+#define UPF_HARD_FLOW		((__force upf_t) (UPF_AUTO_CTS | UPF_AUTO_RTS))
 /* Port has hardware-assisted s/w flow control */
 #define UPF_SOFT_FLOW		((__force upf_t) (1 << 22))
 #define UPF_CONS_FLOW		((__force upf_t) (1 << 23))
@@ -214,11 +216,17 @@ struct uart_port {
 #error Change mask not equivalent to userspace-visible bit defines
 #endif
 
-	/* status must be updated while holding port lock */
+	/*
+	 * Must hold termios_rwsem, port mutex and port lock to change;
+	 * can hold any one lock to read.
+	 */
 	upstat_t		status;
 
 #define UPSTAT_CTS_ENABLE	((__force upstat_t) (1 << 0))
 #define UPSTAT_DCD_ENABLE	((__force upstat_t) (1 << 1))
+#define UPSTAT_AUTORTS		((__force upstat_t) (1 << 2))
+#define UPSTAT_AUTOCTS		((__force upstat_t) (1 << 3))
+#define UPSTAT_AUTOXOFF		((__force upstat_t) (1 << 4))
 
 	int			hw_stopped;		/* sw-assisted CTS flow state */
 	unsigned int		mctrl;			/* current modem ctrl settings */
@@ -392,6 +400,13 @@ static inline bool uart_cts_enabled(struct uart_port *uport)
 	return !!(uport->status & UPSTAT_CTS_ENABLE);
 }
 
+static inline bool uart_softcts_mode(struct uart_port *uport)
+{
+	upstat_t mask = UPSTAT_CTS_ENABLE | UPSTAT_AUTOCTS;
+
+	return ((uport->status & mask) == UPSTAT_CTS_ENABLE);
+}
+
 /*
  * The following are helper functions for the low level drivers.
  */

commit 4bf4ea9dca4ba1984abeb592f429265b9bacac42
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Tue Dec 30 20:28:15 2014 -0500

    serial: omap_8250: Fix RTS handling
    
    The OMAP3 UART ignores MCR[1] (ie., UART_MCR_RTS) when in autoRTS
    mode (UPF_HARD_FLOW + CRTSCTS). This makes it impossible for either
    the serial core or userspace to manually flow control the sender.
    
    Disable autoRTS mode when RTS is lowered and restore the previous
    mode when RTS is raised.
    
    Note that the OMAP3 UART provides no mechanism for switching from
    autoRTS mode without corrupting incoming data; to access the
    necessary register, the line control settings must be set to 8-e-2
    and thus any data received during that time will be interpreted with
    those settings. This corruption has been observed in practice.
    
    Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 057038cf2788..a0c7033d5f91 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -123,6 +123,7 @@ struct uart_port {
 	void			(*set_termios)(struct uart_port *,
 				               struct ktermios *new,
 				               struct ktermios *old);
+	void			(*set_mctrl)(struct uart_port *, unsigned int);
 	int			(*startup)(struct uart_port *port);
 	void			(*shutdown)(struct uart_port *port);
 	void			(*throttle)(struct uart_port *port);

commit 3ffb1a8193bead7bf4ef0fec2dae050c70e4c1c1
Author: Kevin Cernekee <cernekee@gmail.com>
Date:   Wed Nov 12 12:53:59 2014 -0800

    serial: core: Add big-endian iotype
    
    Since most drivers interpret UPIO_MEM32 to mean "little-endian" and use
    readl/writel to access the registers, add a parallel UPIO_MEM32BE to
    request the use of big-endian MMIO accessors (ioread32be/iowrite32be).
    
    Signed-off-by: Kevin Cernekee <cernekee@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 3231a43f6acf..057038cf2788 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -142,12 +142,13 @@ struct uart_port {
 	unsigned char		iotype;			/* io access style */
 	unsigned char		unused1;
 
-#define UPIO_PORT		(0)
-#define UPIO_HUB6		(1)
-#define UPIO_MEM		(2)
-#define UPIO_MEM32		(3)
-#define UPIO_AU			(4)			/* Au1x00 and RT288x type IO */
-#define UPIO_TSI		(5)			/* Tsi108/109 type IO */
+#define UPIO_PORT		(0)			/* 8b I/O port access */
+#define UPIO_HUB6		(1)			/* Hub6 ISA card */
+#define UPIO_MEM		(2)			/* 8b MMIO access */
+#define UPIO_MEM32		(3)			/* 32b little endian */
+#define UPIO_MEM32BE		(4)			/* 32b big endian */
+#define UPIO_AU			(5)			/* Au1x00 and RT288x type IO */
+#define UPIO_TSI		(6)			/* Tsi108/109 type IO */
 
 	unsigned int		read_status_mask;	/* driver specific */
 	unsigned int		ignore_status_mask;	/* driver specific */

commit a5f276f10ff70da89b349df445e944c8cd87956c
Author: Ricardo Ribalda <ribalda@kernel.org>
Date:   Thu Nov 6 22:46:13 2014 +0100

    serial_core: Handle TIOC[GS]RS485 ioctls.
    
    The following drivers: 8250_core, atmel_serial, max310x, mcf, omap-serial
    and sci16is7xx implement code to handle RS485 ioctls.
    
    In order to avoid code duplication, we implement a simple ioctl handler
    on the serial_core layer.
    
    This handler can be used by all the other drivers instead of duplicating
    code.
    
    Until this is the only RS485 ioctl handler, it will try first the
    rs485_config callback and if it is not present it will call the driver
    specific ioctl.
    
    Reviewed-by: Alan Cox <alan@linux.intel.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Ricardo Ribalda Delgado <ricardo.ribalda@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 40b4cc4f8e1d..3231a43f6acf 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -131,6 +131,8 @@ struct uart_port {
 	void			(*pm)(struct uart_port *, unsigned int state,
 				      unsigned int old);
 	void			(*handle_break)(struct uart_port *);
+	int			(*rs485_config)(struct uart_port *,
+						struct serial_rs485 *rs485);
 	unsigned int		irq;			/* irq number */
 	unsigned long		irqflags;		/* irq flags  */
 	unsigned int		uartclk;		/* base uart clock */
@@ -231,6 +233,7 @@ struct uart_port {
 	unsigned char		unused[2];
 	struct attribute_group	*attr_group;		/* port specific attributes */
 	const struct attribute_group **tty_groups;	/* all attributes (serial core use only) */
+	struct serial_rs485     rs485;
 	void			*private_data;		/* generic platform data pointer */
 };
 

commit 732a84a037a4de29b54e0b4e6cb6f9b3813e29e5
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Wed Nov 5 13:11:43 2014 -0500

    serial: core: Pass termios to set_ldisc() notifications
    
    UART drivers which enable modem status interrupts when switching
    to N_PPS line discipline need to determine if modem status
    interrupts should be disabled when switching from N_PPS.
    Specifically, the set_ldisc() notification needs to evaluate
    UART_ENABLE_MS() which requires termios->c_cflag.
    
    Convert in-tree UART drivers to new interface.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index ad9329669aba..40b4cc4f8e1d 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -63,7 +63,7 @@ struct uart_ops {
 	void		(*flush_buffer)(struct uart_port *);
 	void		(*set_termios)(struct uart_port *, struct ktermios *new,
 				       struct ktermios *old);
-	void		(*set_ldisc)(struct uart_port *, int new);
+	void		(*set_ldisc)(struct uart_port *, struct ktermios *);
 	void		(*pm)(struct uart_port *, unsigned int state,
 			      unsigned int oldstate);
 

commit 904326ecac022ebaeb39cdfb206fd3b6551cdfca
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Thu Oct 16 16:54:21 2014 -0400

    tty,serial: Unify UPF_* and ASYNC_* flag definitions
    
    The userspace-defined ASYNC_* flags in include/uapi/linux/tty_flags.h
    are the authoritative bit definitions for the serial_struct flags,
    and thus for any derivative values or fields.
    
    Although the serial core provides the TIOCSSERIAL and TIOCGSERIAL
    ioctls to set and retrieve these flags from userspace, it defines these
    bits independently, as UPF_* macros.
    
    Define the UPF_* macros which are userspace-modifiable directly from
    the ASYNC_* symbolic constants. Add compile-time test to ensure the
    bits changeable by TIOCSSERIAL match the defined range in the uapi
    header.
    
    Add ASYNCB_MAGIC_MULTIPLIER to the uapi header since this bit is
    programmable by userspace.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index bccf4bac22f5..ad9329669aba 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -160,21 +160,33 @@ struct uart_port {
 	/* flags must be updated while holding port mutex */
 	upf_t			flags;
 
-#define UPF_FOURPORT		((__force upf_t) (1 << 1))
-#define UPF_SAK			((__force upf_t) (1 << 2))
-#define UPF_SPD_MASK		((__force upf_t) (0x1030))
-#define UPF_SPD_HI		((__force upf_t) (0x0010))
-#define UPF_SPD_VHI		((__force upf_t) (0x0020))
-#define UPF_SPD_CUST		((__force upf_t) (0x0030))
-#define UPF_SPD_SHI		((__force upf_t) (0x1000))
-#define UPF_SPD_WARP		((__force upf_t) (0x1010))
-#define UPF_SKIP_TEST		((__force upf_t) (1 << 6))
-#define UPF_AUTO_IRQ		((__force upf_t) (1 << 7))
-#define UPF_HARDPPS_CD		((__force upf_t) (1 << 11))
-#define UPF_LOW_LATENCY		((__force upf_t) (1 << 13))
-#define UPF_BUGGY_UART		((__force upf_t) (1 << 14))
+	/*
+	 * These flags must be equivalent to the flags defined in
+	 * include/uapi/linux/tty_flags.h which are the userspace definitions
+	 * assigned from the serial_struct flags in uart_set_info()
+	 * [for bit definitions in the UPF_CHANGE_MASK]
+	 *
+	 * Bits [0..UPF_LAST_USER] are userspace defined/visible/changeable
+	 * except bit 15 (UPF_NO_TXEN_TEST) which is masked off.
+	 * The remaining bits are serial-core specific and not modifiable by
+	 * userspace.
+	 */
+#define UPF_FOURPORT		((__force upf_t) ASYNC_FOURPORT       /* 1  */ )
+#define UPF_SAK			((__force upf_t) ASYNC_SAK            /* 2  */ )
+#define UPF_SPD_HI		((__force upf_t) ASYNC_SPD_HI         /* 4  */ )
+#define UPF_SPD_VHI		((__force upf_t) ASYNC_SPD_VHI        /* 5  */ )
+#define UPF_SPD_CUST		((__force upf_t) ASYNC_SPD_CUST   /* 0x0030 */ )
+#define UPF_SPD_WARP		((__force upf_t) ASYNC_SPD_WARP   /* 0x1010 */ )
+#define UPF_SPD_MASK		((__force upf_t) ASYNC_SPD_MASK   /* 0x1030 */ )
+#define UPF_SKIP_TEST		((__force upf_t) ASYNC_SKIP_TEST      /* 6  */ )
+#define UPF_AUTO_IRQ		((__force upf_t) ASYNC_AUTO_IRQ       /* 7  */ )
+#define UPF_HARDPPS_CD		((__force upf_t) ASYNC_HARDPPS_CD     /* 11 */ )
+#define UPF_SPD_SHI		((__force upf_t) ASYNC_SPD_SHI        /* 12 */ )
+#define UPF_LOW_LATENCY		((__force upf_t) ASYNC_LOW_LATENCY    /* 13 */ )
+#define UPF_BUGGY_UART		((__force upf_t) ASYNC_BUGGY_UART     /* 14 */ )
 #define UPF_NO_TXEN_TEST	((__force upf_t) (1 << 15))
-#define UPF_MAGIC_MULTIPLIER	((__force upf_t) (1 << 16))
+#define UPF_MAGIC_MULTIPLIER	((__force upf_t) ASYNC_MAGIC_MULTIPLIER /* 16 */ )
+
 /* Port has hardware-assisted h/w flow control (iow, auto-RTS *not* auto-CTS) */
 #define UPF_HARD_FLOW		((__force upf_t) (1 << 21))
 /* Port has hardware-assisted s/w flow control */
@@ -190,9 +202,14 @@ struct uart_port {
 #define UPF_DEAD		((__force upf_t) (1 << 30))
 #define UPF_IOREMAP		((__force upf_t) (1 << 31))
 
-#define UPF_CHANGE_MASK		((__force upf_t) (0x17fff))
+#define __UPF_CHANGE_MASK	0x17fff
+#define UPF_CHANGE_MASK		((__force upf_t) __UPF_CHANGE_MASK)
 #define UPF_USR_MASK		((__force upf_t) (UPF_SPD_MASK|UPF_LOW_LATENCY))
 
+#if __UPF_CHANGE_MASK > ASYNC_FLAGS
+#error Change mask not equivalent to userspace-visible bit defines
+#endif
+
 	/* status must be updated while holding port lock */
 	upstat_t		status;
 

commit d4260b51699082c7dea257bea002d79394e876e0
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Thu Oct 16 14:19:47 2014 -0400

    serial: Fix upstat_t sparse warnings
    
    Commit 299245a145b2ad4cfb4c5432eb1264299f55e7e0,
    serial: core: Privatize modem status enable flags, introduced
    the upstat_t type and matching bit definitions. The purpose is to
    produce sparse warnings if the wrong bit definitions are used
    (by warning of implicit integer conversions).
    
    Fix implicit conversion to integer return type from uart_cts_enabled()
    and uart_dcd_enabled().
    
    Fixes the following sparse warnings:
    drivers/tty/serial/serial_core.c:63:30: warning: incorrect type in return expression (different base types)
    drivers/tty/serial/serial_core.c:63:30:    expected int
    drivers/tty/serial/serial_core.c:63:30:    got restricted upstat_t
    include/linux/serial_core.h:364:30: warning: incorrect type in return expression (different base types)
    include/linux/serial_core.h:364:30:    expected bool
    include/linux/serial_core.h:364:30:    got restricted upstat_t
    include/linux/serial_core.h:364:30: warning: incorrect type in return expression (different base types)
    include/linux/serial_core.h:364:30:    expected bool
    include/linux/serial_core.h:364:30:    got restricted upstat_t
    
    Reported-by: Fengguang Wu <fengguang.wu@intel.com>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 21c2e05c1bc3..bccf4bac22f5 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -367,7 +367,7 @@ static inline int uart_tx_stopped(struct uart_port *port)
 
 static inline bool uart_cts_enabled(struct uart_port *uport)
 {
-	return uport->status & UPSTAT_CTS_ENABLE;
+	return !!(uport->status & UPSTAT_CTS_ENABLE);
 }
 
 /*

commit 234abab143aef82c0ef1f2de409c0db96b666f3c
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Wed Sep 10 21:29:56 2014 +0200

    tty: serial: 8250_core: allow to set ->throttle / ->unthrottle callbacks
    
    The OMAP UART provides support for HW assisted flow control. What is
    missing is the support to throttle / unthrottle callbacks which are used
    by the omap-serial driver at the moment.
    This patch adds the callbacks. It should be safe to add them since they
    are only invoked from the serial_core (uart_throttle()) if the feature
    flags are set.
    
    Reviewed-by: Tony Lindgren <tony@atomide.com>
    Tested-by: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 204c452a7567..21c2e05c1bc3 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -125,6 +125,8 @@ struct uart_port {
 				               struct ktermios *old);
 	int			(*startup)(struct uart_port *port);
 	void			(*shutdown)(struct uart_port *port);
+	void			(*throttle)(struct uart_port *port);
+	void			(*unthrottle)(struct uart_port *port);
 	int			(*handle_irq)(struct uart_port *);
 	void			(*pm)(struct uart_port *, unsigned int state,
 				      unsigned int old);

commit d01f4d181c92877ecc678adce248a30cb7077ff1
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Wed Sep 10 15:06:26 2014 -0400

    serial: core: Privatize tty->hw_stopped
    
    tty->hw_stopped is not used by the tty core and is thread-unsafe;
    hw_stopped is a member of a bitfield whose fields are updated
    non-atomically and no lock is suitable for serializing updates.
    
    Replace serial core usage of tty->hw_stopped with uport->hw_stopped.
    Use int storage which works around Alpha EV4/5 non-atomic byte storage,
    since uart_port uses different locks to protect certain fields within the
    structure.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 452c9cc9d717..204c452a7567 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -197,6 +197,7 @@ struct uart_port {
 #define UPSTAT_CTS_ENABLE	((__force upstat_t) (1 << 0))
 #define UPSTAT_DCD_ENABLE	((__force upstat_t) (1 << 1))
 
+	int			hw_stopped;		/* sw-assisted CTS flow state */
 	unsigned int		mctrl;			/* current modem ctrl settings */
 	unsigned int		timeout;		/* character-based timeout */
 	unsigned int		type;			/* port type */
@@ -357,7 +358,7 @@ int uart_resume_port(struct uart_driver *reg, struct uart_port *port);
 static inline int uart_tx_stopped(struct uart_port *port)
 {
 	struct tty_struct *tty = port->state->port.tty;
-	if(tty->stopped || tty->hw_stopped)
+	if (tty->stopped || port->hw_stopped)
 		return 1;
 	return 0;
 }

commit 299245a145b2ad4cfb4c5432eb1264299f55e7e0
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Wed Sep 10 15:06:24 2014 -0400

    serial: core: Privatize modem status enable flags
    
    The serial core uses the tty port flags, ASYNC_CTS_FLOW and
    ASYNC_CD_CHECK, to track whether CTS and DCD changes should be
    ignored or handled. However, the tty port flags are not safe for
    atomic bit operations and no lock provides serialized updates.
    
    Introduce the struct uart_port status field to track CTS and DCD
    enable states, and serialize access with uart port lock. Substitute
    uart_cts_enabled() helper for tty_port_cts_enabled().
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 3bd7d55eebce..452c9cc9d717 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -112,6 +112,7 @@ struct uart_icount {
 };
 
 typedef unsigned int __bitwise__ upf_t;
+typedef unsigned int __bitwise__ upstat_t;
 
 struct uart_port {
 	spinlock_t		lock;			/* port lock */
@@ -190,6 +191,12 @@ struct uart_port {
 #define UPF_CHANGE_MASK		((__force upf_t) (0x17fff))
 #define UPF_USR_MASK		((__force upf_t) (UPF_SPD_MASK|UPF_LOW_LATENCY))
 
+	/* status must be updated while holding port lock */
+	upstat_t		status;
+
+#define UPSTAT_CTS_ENABLE	((__force upstat_t) (1 << 0))
+#define UPSTAT_DCD_ENABLE	((__force upstat_t) (1 << 1))
+
 	unsigned int		mctrl;			/* current modem ctrl settings */
 	unsigned int		timeout;		/* character-based timeout */
 	unsigned int		type;			/* port type */
@@ -355,6 +362,11 @@ static inline int uart_tx_stopped(struct uart_port *port)
 	return 0;
 }
 
+static inline bool uart_cts_enabled(struct uart_port *uport)
+{
+	return uport->status & UPSTAT_CTS_ENABLE;
+}
+
 /*
  * The following are helper functions for the low level drivers.
  */

commit b99b121b2aa42e60e5b73fdd3a49863337839c7b
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Fri Sep 5 21:02:37 2014 +0200

    tty: serial: 8250_core: allow to overwrite & export serial8250_startup()
    
    The OMAP version of the 8250 can actually use 1:1 serial8250_startup().
    However it needs to be extended by a wake up irq which should to be
    requested & enabled at ->startup() time and disabled at ->shutdown() time.
    
    v2…v3: properly copy callbacks
    v1…v2: add shutdown callback
    
    Acked-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 8cb267b1fcd5..3bd7d55eebce 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -122,6 +122,8 @@ struct uart_port {
 	void			(*set_termios)(struct uart_port *,
 				               struct ktermios *new,
 				               struct ktermios *old);
+	int			(*startup)(struct uart_port *port);
+	void			(*shutdown)(struct uart_port *port);
 	int			(*handle_irq)(struct uart_port *);
 	void			(*pm)(struct uart_port *, unsigned int state,
 				      unsigned int old);

commit 8a949b07e4062cbd07e04e6a47249e69ca65b944
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Tue Sep 2 17:39:19 2014 -0400

    serial: core: Document lock requirement for UPF_* flags updates
    
    The flags field of struct uart_port can only be safely modified
    if the port mutex is held; no other lock prevents concurrent
    changes from corrupting the field.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index cf3a1e789bf5..8cb267b1fcd5 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -152,6 +152,7 @@ struct uart_port {
 	unsigned long		sysrq;			/* sysrq timeout */
 #endif
 
+	/* flags must be updated while holding port mutex */
 	upf_t			flags;
 
 #define UPF_FOURPORT		((__force upf_t) (1 << 1))

commit 266dcff03eed0050b6af11aaf2a61ab837d7ba3f
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Jul 16 01:19:34 2014 +0000

    Serial: allow port drivers to have a default attribute group
    
    Some serial drivers (like 8250), want to add sysfs files.  We need to do
    so in a race-free way, so allow any port to be able to specify an
    attribute group that should be added at device creation time.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Yoshihiro YUNOMAE <yoshihiro.yunomae.ez@hitachi.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 5bbb809ee197..cf3a1e789bf5 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -199,6 +199,8 @@ struct uart_port {
 	unsigned char		suspended;
 	unsigned char		irq_wake;
 	unsigned char		unused[2];
+	struct attribute_group	*attr_group;		/* port specific attributes */
+	const struct attribute_group **tty_groups;	/* all attributes (serial core use only) */
 	void			*private_data;		/* generic platform data pointer */
 };
 

commit b0b6abd34c1b508d4ac95dbc614f36c49d29e65a
Author: Rob Herring <robh@kernel.org>
Date:   Thu Mar 27 08:06:16 2014 -0500

    serial: earlycon: add DT support
    
    This adds the infrastructure to generic earlycon for earlycon setup
    using DT. The actual setup is not enabled until a following commit to
    add the FDT parsing.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Grant Likely <grant.likely@linaro.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 7a15b5b24c0b..5bbb809ee197 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -294,6 +294,9 @@ struct earlycon_device {
 int setup_earlycon(char *buf, const char *match,
 		   int (*setup)(struct earlycon_device *, const char *));
 
+extern int of_setup_earlycon(unsigned long addr,
+			     int (*setup)(struct earlycon_device *, const char *));
+
 #define EARLYCON_DECLARE(name, func) \
 static int __init name ## _setup_earlycon(char *buf) \
 { \
@@ -301,6 +304,9 @@ static int __init name ## _setup_earlycon(char *buf) \
 } \
 early_param("earlycon", name ## _setup_earlycon);
 
+#define OF_EARLYCON_DECLARE(name, compat, fn)				\
+	_OF_DECLARE(earlycon, name, compat, fn, void *)
+
 struct uart_port *uart_get_console(struct uart_port *ports, int nr,
 				   struct console *c);
 void uart_parse_options(char *options, int *baud, int *parity, int *bits,

commit 9aac5887595b765b6f64b2af08b785e82e095b57
Author: Rob Herring <robh@kernel.org>
Date:   Fri Apr 18 17:19:55 2014 -0500

    tty/serial: add generic serial earlycon
    
    This introduces generic earlycon infrastructure for serial devices
    based on the 8250 earlycon. This allows for supporting earlycon option
    with other serial devices. The earlycon output is enabled at the time
    early_params are processed.
    
    Only architectures that have fixmap support or have functional ioremap
    when early_params are processed are supported. This is the same
    restriction that the 8250 driver had.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index f729be981da0..7a15b5b24c0b 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -285,6 +285,22 @@ static inline int uart_poll_timeout(struct uart_port *port)
 /*
  * Console helpers.
  */
+struct earlycon_device {
+	struct console *con;
+	struct uart_port port;
+	char options[16];		/* e.g., 115200n8 */
+	unsigned int baud;
+};
+int setup_earlycon(char *buf, const char *match,
+		   int (*setup)(struct earlycon_device *, const char *));
+
+#define EARLYCON_DECLARE(name, func) \
+static int __init name ## _setup_earlycon(char *buf) \
+{ \
+	return setup_earlycon(buf, __stringify(name), func); \
+} \
+early_param("earlycon", name ## _setup_earlycon);
+
 struct uart_port *uart_get_console(struct uart_port *ports, int nr,
 				   struct console *c);
 void uart_parse_options(char *options, int *baud, int *parity, int *bits,

commit fa2b5ea09e48186041f68649ab8192447b31bffc
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Oct 15 09:20:52 2013 +0200

    serial: core: delete .set_wake() callback
    
    This deletes the .set_wake() callback in the struct uart_ops.
    Apparently this has been unused since pre-git times. In the
    old-2.6-bkcvs it is deleted as part of a changeset removing
    the PM_SET_WAKEUP from pm_request_t which is since also deleted
    from the kernel.
    
    The apropriate way to set wakeups in the kernel is to have a
    code snippet like this in .suspend() or .runtime_suspend()
    callbacks:
    
    static int foo_suspend(struct device *dev)
    {
            if (device_may_wakeup(dev)) {
                    /* Enable wakeups, set internal states */
            }
    }
    
    This specific callback is not coming back.
    
    Cc: Rafael J. Wysocki <rjw@sisk.pl>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Kevin Hilman <khilman@deeprootsystems.com>
    Cc: Dmitry Artamonow <mad_soft@inbox.ru>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index b98291ac7f14..f729be981da0 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -66,7 +66,6 @@ struct uart_ops {
 	void		(*set_ldisc)(struct uart_port *, int new);
 	void		(*pm)(struct uart_port *, unsigned int state,
 			      unsigned int oldstate);
-	int		(*set_wake)(struct uart_port *, unsigned int state);
 
 	/*
 	 * Return a string describing the type of the port

commit cf0ebee0d0374c6d75494ac96f86b4aea482dd09
Author: Sourav Poddar <sourav.poddar@ti.com>
Date:   Wed May 15 21:05:37 2013 +0530

    serial: Move "uart_console" def to core header file.
    
    Move "uart_console" definition to serial core header file, so that it can be
    used by serial drivers.
    Get rid of the uart_console defintion from mpc52xx_uart driver.
    
    Cc: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Cc: Rajendra nayak <rnayak@ti.com>
    Reviewed-by: Felipe Balbi <balbi@ti.com>
    Reviewed-by: Kevin Hilman <khilman@linaro.org>
    Tested-by: Kevin Hilman <khilman@linaro.org>
    Signed-off-by: Sourav Poddar <sourav.poddar@ti.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 87d4bbc773fc..b98291ac7f14 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -31,6 +31,13 @@
 #include <linux/sysrq.h>
 #include <uapi/linux/serial_core.h>
 
+#ifdef CONFIG_SERIAL_CORE_CONSOLE
+#define uart_console(port) \
+	((port)->cons && (port)->cons->index == (port)->line)
+#else
+#define uart_console(port)      (0)
+#endif
+
 struct uart_port;
 struct serial_struct;
 struct device;

commit 593fb1ae457aab28b392ac114f6e3358788da985
Author: George Spelvin <linux@horizon.com>
Date:   Tue Feb 12 02:00:43 2013 -0500

    pps: Move timestamp read into PPS code proper
    
    The PPS (Pulse-Per-Second) line discipline has developed a number of
    unhealthy attachments to core tty data and functions, ultimately leading
    to its breakage.
    
    The previous patches fixed the crashing.  This one reduces coupling further
    by eliminating the timestamp parameter from the dcd_change ldisc method.
    This reduces header file linkage and makes the extension more generic,
    and the timestamp read is delayed only slightly, from just before the
    ldisc->ops->dcd_change method call to just after.
    
    Fix attendant build breakage in
        drivers/tty/n_tty.c
        drivers/tty/tty_buffer.c
        drivers/staging/speakup/selection.c
        drivers/staging/dgrp/dgrp_*.c
    
    Cc: William Hubbs <w.d.hubbs@gmail.com>
    Cc: Chris Brannon <chris@the-brannons.com>
    Cc: Kirk Reiser <kirk@braille.uwo.ca>
    Cc: Samuel Thibault <samuel.thibault@ens-lyon.org>
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Signed-off-by: George Spelvin <linux@horizon.com>
    Acked-by: Rodolfo Giometti <giometti@enneenne.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index d97142159e0f..87d4bbc773fc 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -29,7 +29,6 @@
 #include <linux/tty.h>
 #include <linux/mutex.h>
 #include <linux/sysrq.h>
-#include <linux/pps_kernel.h>
 #include <uapi/linux/serial_core.h>
 
 struct uart_port;

commit c420811f117a59a4a7d4e34b362437b91c7fafa1
Author: John Crispin <john@phrozen.org>
Date:   Fri Jan 25 19:39:51 2013 +0100

    serial: ralink: adds support for the serial core found on ralink wisoc
    
    The MIPS based Ralink WiSoC platform has 1 or more 8250 compatible serial cores.
    To make them work we require the same quirks that are used by AU1x00.
    
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 82aebc8ff77f..d97142159e0f 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -134,7 +134,7 @@ struct uart_port {
 #define UPIO_HUB6		(1)
 #define UPIO_MEM		(2)
 #define UPIO_MEM32		(3)
-#define UPIO_AU			(4)			/* Au1x00 type IO */
+#define UPIO_AU			(4)			/* Au1x00 and RT288x type IO */
 #define UPIO_TSI		(5)			/* Tsi108/109 type IO */
 
 	unsigned int		read_status_mask;	/* driver specific */

commit e759d7c53b39a43fc908425bf9985b8b7d930550
Author: Kevin Cernekee <cernekee@gmail.com>
Date:   Wed Dec 26 20:43:42 2012 -0800

    tty: Update serial core API documentation
    
    Signed-off-by: Kevin Cernekee <cernekee@gmail.com>
    Acked-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index ec5df74c4506..82aebc8ff77f 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -37,8 +37,8 @@ struct serial_struct;
 struct device;
 
 /*
- * This structure describes all the operations that can be
- * done on the physical hardware.
+ * This structure describes all the operations that can be done on the
+ * physical hardware.  See Documentation/serial/driver for details.
  */
 struct uart_ops {
 	unsigned int	(*tx_empty)(struct uart_port *);
@@ -65,7 +65,7 @@ struct uart_ops {
 	/*
 	 * Return a string describing the type of the port
 	 */
-	const char *(*type)(struct uart_port *);
+	const char	*(*type)(struct uart_port *);
 
 	/*
 	 * Release IO and memory resources used by the port.
@@ -83,7 +83,7 @@ struct uart_ops {
 	int		(*ioctl)(struct uart_port *, unsigned int, unsigned long);
 #ifdef CONFIG_CONSOLE_POLL
 	int		(*poll_init)(struct uart_port *);
-	void	(*poll_put_char)(struct uart_port *, unsigned char);
+	void		(*poll_put_char)(struct uart_port *, unsigned char);
 	int		(*poll_get_char)(struct uart_port *);
 #endif
 };

commit a205a56dc24811a2879572e52c902a38425a4473
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Dec 18 11:41:14 2012 +0100

    serial: Remove RM9000 series serial driver.
    
    Now that support for RM9000 and platforms based on it has been removed,
    remove the serial driver for it as well.  It's really only been a quirk
    for an almost 8250 compatible UART anyway.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    
     drivers/tty/serial/8250/8250.c  | 70 +----------------------------------------
     drivers/tty/serial/8250/Kconfig |  9 ------
     include/linux/serial_core.h     |  1 -
     3 files changed, 1 insertion(+), 79 deletions(-)
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index a116daa13113..ec5df74c4506 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -136,7 +136,6 @@ struct uart_port {
 #define UPIO_MEM32		(3)
 #define UPIO_AU			(4)			/* Au1x00 type IO */
 #define UPIO_TSI		(5)			/* Tsi108/109 type IO */
-#define UPIO_RM9000		(6)			/* RM9000 type IO */
 
 	unsigned int		read_status_mask;	/* driver specific */
 	unsigned int		ignore_status_mask;	/* driver specific */

commit 6f538fe31c1d453b7e7fc4f6e7c6a9bdead4a6f2
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Dec 7 11:36:08 2012 +0100

    tty: serial core: decouple pm states from ACPI
    
    The serial core is using power states lifted from ACPI for no
    good reason. Remove this reference from the documentation and
    alter all users to use an enum specific to the serial core
    instead, and define it in <linux/serial_core.h>.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Alan Cox <alan@linux.intel.com>
    Reviewed-by: Daniel Lezcano <daniel.lezcano@linaro.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index c6690a2a27fb..a116daa13113 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -208,13 +208,25 @@ static inline void serial_port_out(struct uart_port *up, int offset, int value)
 	up->serial_out(up, offset, value);
 }
 
+/**
+ * enum uart_pm_state - power states for UARTs
+ * @UART_PM_STATE_ON: UART is powered, up and operational
+ * @UART_PM_STATE_OFF: UART is powered off
+ * @UART_PM_STATE_UNDEFINED: sentinel
+ */
+enum uart_pm_state {
+	UART_PM_STATE_ON = 0,
+	UART_PM_STATE_OFF = 3, /* number taken from ACPI */
+	UART_PM_STATE_UNDEFINED,
+};
+
 /*
  * This is the state information which is persistent across opens.
  */
 struct uart_state {
 	struct tty_port		port;
 
-	int			pm_state;
+	enum uart_pm_state	pm_state;
 	struct circ_buf		xmit;
 
 	struct uart_port	*uart_port;

commit 9aba8d5b011193c8e01d565c5b585df5b94f1db2
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Apr 17 17:23:14 2012 +0100

    SERIAL: core: add throttle/unthrottle callbacks for hardware assisted flow control
    
    Add two callbacks for hardware assisted flow control; we need to know
    when the tty layers want us to stop and restart due to their buffer
    levels.
    
    Call a driver specific throttle/unthrottle function if and only if the
    driver indicates that it is using an enabled hardware assisted flow
    control method, otherwise fall back to the non-hardware assisted
    methods.
    
    Acked-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index e2cda5d04e48..c6690a2a27fb 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -46,6 +46,8 @@ struct uart_ops {
 	unsigned int	(*get_mctrl)(struct uart_port *);
 	void		(*stop_tx)(struct uart_port *);
 	void		(*start_tx)(struct uart_port *);
+	void		(*throttle)(struct uart_port *);
+	void		(*unthrottle)(struct uart_port *);
 	void		(*send_xchar)(struct uart_port *, char ch);
 	void		(*stop_rx)(struct uart_port *);
 	void		(*enable_ms)(struct uart_port *);

commit dba05832cbe4f305dfd998fb26d7c685d91fbbd8
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Apr 17 16:41:10 2012 +0100

    SERIAL: core: add hardware assisted h/w flow control support
    
    Ports which are handling h/w flow control in hardware must not have
    their RTS state altered depending on the tty's hardware-stopped state.
    Avoid this additional logic when setting the termios state.
    
    Acked-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 00051388de3c..e2cda5d04e48 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -163,6 +163,8 @@ struct uart_port {
 #define UPF_BUGGY_UART		((__force upf_t) (1 << 14))
 #define UPF_NO_TXEN_TEST	((__force upf_t) (1 << 15))
 #define UPF_MAGIC_MULTIPLIER	((__force upf_t) (1 << 16))
+/* Port has hardware-assisted h/w flow control (iow, auto-RTS *not* auto-CTS) */
+#define UPF_HARD_FLOW		((__force upf_t) (1 << 21))
 /* Port has hardware-assisted s/w flow control */
 #define UPF_SOFT_FLOW		((__force upf_t) (1 << 22))
 #define UPF_CONS_FLOW		((__force upf_t) (1 << 23))

commit 2cbacafd7af0f1cc7a433668c662a91ba6aabc1b
Author: Russell King <rmk+kernel@arm.linux.org.uk>
Date:   Tue Apr 17 16:34:13 2012 +0100

    SERIAL: core: add hardware assisted s/w flow control support
    
    Ports which are capable of handling s/w flow control in hardware to
    know when the s/w flow control termios settings are changed.  Add a
    flag to allow the low level serial drivers to indicate that they
    support this, and these changes should be propagated to them.
    
    Acked-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 3c430228d232..00051388de3c 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -163,6 +163,8 @@ struct uart_port {
 #define UPF_BUGGY_UART		((__force upf_t) (1 << 14))
 #define UPF_NO_TXEN_TEST	((__force upf_t) (1 << 15))
 #define UPF_MAGIC_MULTIPLIER	((__force upf_t) (1 << 16))
+/* Port has hardware-assisted s/w flow control */
+#define UPF_SOFT_FLOW		((__force upf_t) (1 << 22))
 #define UPF_CONS_FLOW		((__force upf_t) (1 << 23))
 #define UPF_SHARE_IRQ		((__force upf_t) (1 << 24))
 #define UPF_EXAR_EFR		((__force upf_t) (1 << 25))

commit 607ca46e97a1b6594b29647d98a32d545c24bdff
Author: David Howells <dhowells@redhat.com>
Date:   Sat Oct 13 10:46:48 2012 +0100

    UAPI: (Scripted) Disintegrate include/linux
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Michael Kerrisk <mtk.manpages@gmail.com>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Acked-by: Dave Jones <davej@redhat.com>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index f9b22ec7a9f3..3c430228d232 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -20,202 +20,6 @@
 #ifndef LINUX_SERIAL_CORE_H
 #define LINUX_SERIAL_CORE_H
 
-#include <linux/serial.h>
-
-/*
- * The type definitions.  These are from Ted Ts'o's serial.h
- */
-#define PORT_UNKNOWN	0
-#define PORT_8250	1
-#define PORT_16450	2
-#define PORT_16550	3
-#define PORT_16550A	4
-#define PORT_CIRRUS	5
-#define PORT_16650	6
-#define PORT_16650V2	7
-#define PORT_16750	8
-#define PORT_STARTECH	9
-#define PORT_16C950	10
-#define PORT_16654	11
-#define PORT_16850	12
-#define PORT_RSA	13
-#define PORT_NS16550A	14
-#define PORT_XSCALE	15
-#define PORT_RM9000	16	/* PMC-Sierra RM9xxx internal UART */
-#define PORT_OCTEON	17	/* Cavium OCTEON internal UART */
-#define PORT_AR7	18	/* Texas Instruments AR7 internal UART */
-#define PORT_U6_16550A	19	/* ST-Ericsson U6xxx internal UART */
-#define PORT_TEGRA	20	/* NVIDIA Tegra internal UART */
-#define PORT_XR17D15X	21	/* Exar XR17D15x UART */
-#define PORT_LPC3220	22	/* NXP LPC32xx SoC "Standard" UART */
-#define PORT_8250_CIR	23	/* CIR infrared port, has its own driver */
-#define PORT_MAX_8250	23	/* max port ID */
-
-/*
- * ARM specific type numbers.  These are not currently guaranteed
- * to be implemented, and will change in the future.  These are
- * separate so any additions to the old serial.c that occur before
- * we are merged can be easily merged here.
- */
-#define PORT_PXA	31
-#define PORT_AMBA	32
-#define PORT_CLPS711X	33
-#define PORT_SA1100	34
-#define PORT_UART00	35
-#define PORT_21285	37
-
-/* Sparc type numbers.  */
-#define PORT_SUNZILOG	38
-#define PORT_SUNSAB	39
-
-/* DEC */
-#define PORT_DZ		46
-#define PORT_ZS		47
-
-/* Parisc type numbers. */
-#define PORT_MUX	48
-
-/* Atmel AT91 / AT32 SoC */
-#define PORT_ATMEL	49
-
-/* Macintosh Zilog type numbers */
-#define PORT_MAC_ZILOG	50	/* m68k : not yet implemented */
-#define PORT_PMAC_ZILOG	51
-
-/* SH-SCI */
-#define PORT_SCI	52
-#define PORT_SCIF	53
-#define PORT_IRDA	54
-
-/* Samsung S3C2410 SoC and derivatives thereof */
-#define PORT_S3C2410    55
-
-/* SGI IP22 aka Indy / Challenge S / Indigo 2 */
-#define PORT_IP22ZILOG	56
-
-/* Sharp LH7a40x -- an ARM9 SoC series */
-#define PORT_LH7A40X	57
-
-/* PPC CPM type number */
-#define PORT_CPM        58
-
-/* MPC52xx (and MPC512x) type numbers */
-#define PORT_MPC52xx	59
-
-/* IBM icom */
-#define PORT_ICOM	60
-
-/* Samsung S3C2440 SoC */
-#define PORT_S3C2440	61
-
-/* Motorola i.MX SoC */
-#define PORT_IMX	62
-
-/* Marvell MPSC */
-#define PORT_MPSC	63
-
-/* TXX9 type number */
-#define PORT_TXX9	64
-
-/* NEC VR4100 series SIU/DSIU */
-#define PORT_VR41XX_SIU		65
-#define PORT_VR41XX_DSIU	66
-
-/* Samsung S3C2400 SoC */
-#define PORT_S3C2400	67
-
-/* M32R SIO */
-#define PORT_M32R_SIO	68
-
-/*Digi jsm */
-#define PORT_JSM        69
-
-#define PORT_PNX8XXX	70
-
-/* Hilscher netx */
-#define PORT_NETX	71
-
-/* SUN4V Hypervisor Console */
-#define PORT_SUNHV	72
-
-#define PORT_S3C2412	73
-
-/* Xilinx uartlite */
-#define PORT_UARTLITE	74
-
-/* Blackfin bf5xx */
-#define PORT_BFIN	75
-
-/* Micrel KS8695 */
-#define PORT_KS8695	76
-
-/* Broadcom SB1250, etc. SOC */
-#define PORT_SB1250_DUART	77
-
-/* Freescale ColdFire */
-#define PORT_MCF	78
-
-/* Blackfin SPORT */
-#define PORT_BFIN_SPORT		79
-
-/* MN10300 on-chip UART numbers */
-#define PORT_MN10300		80
-#define PORT_MN10300_CTS	81
-
-#define PORT_SC26XX	82
-
-/* SH-SCI */
-#define PORT_SCIFA	83
-
-#define PORT_S3C6400	84
-
-/* NWPSERIAL */
-#define PORT_NWPSERIAL	85
-
-/* MAX3100 */
-#define PORT_MAX3100    86
-
-/* Timberdale UART */
-#define PORT_TIMBUART	87
-
-/* Qualcomm MSM SoCs */
-#define PORT_MSM	88
-
-/* BCM63xx family SoCs */
-#define PORT_BCM63XX	89
-
-/* Aeroflex Gaisler GRLIB APBUART */
-#define PORT_APBUART    90
-
-/* Altera UARTs */
-#define PORT_ALTERA_JTAGUART	91
-#define PORT_ALTERA_UART	92
-
-/* SH-SCI */
-#define PORT_SCIFB	93
-
-/* MAX310X */
-#define PORT_MAX310X	94
-
-/* High Speed UART for Medfield */
-#define PORT_MFD	95
-
-/* TI OMAP-UART */
-#define PORT_OMAP	96
-
-/* VIA VT8500 SoC */
-#define PORT_VT8500	97
-
-/* Xilinx PSS UART */
-#define PORT_XUARTPS	98
-
-/* Atheros AR933X SoC */
-#define PORT_AR933X	99
-
-/* Energy Micro efm32 SoC */
-#define PORT_EFMUART   100
-
-#ifdef __KERNEL__
 
 #include <linux/compiler.h>
 #include <linux/interrupt.h>
@@ -226,6 +30,7 @@
 #include <linux/mutex.h>
 #include <linux/sysrq.h>
 #include <linux/pps_kernel.h>
+#include <uapi/linux/serial_core.h>
 
 struct uart_port;
 struct serial_struct;
@@ -562,6 +367,4 @@ static inline int uart_handle_break(struct uart_port *port)
 					 (cflag) & CRTSCTS || \
 					 !((cflag) & CLOCAL))
 
-#endif
-
 #endif /* LINUX_SERIAL_CORE_H */

commit c7f3e7087ab0abb52bb1286010f2c104fd38ca5c
Author: Anton Vorontsov <anton.vorontsov@linaro.org>
Date:   Mon Sep 24 14:27:53 2012 -0700

    tty/serial/core: Introduce poll_init callback
    
    It was noticed that polling drivers (like KGDB) are not able to use
    serial ports if the ports were not previously initialized via console.
    I.e.  when booting with console=ttyAMA0 kgdboc=ttyAMA0, everything works
    fine, but with console=ttyFOO kgdboc=ttyAMA0, the kgdboc doesn't work.
    
    This is because we don't initialize the hardware. Calling ->startup() is
    not an option, because drivers request interrupts there, and drivers
    fail to handle situations when tty isn't opened with interrupts enabled.
    
    So, we have to implement a new callback (actually, tty_ops already have
    a similar callback), which does everything needed to initialize just the
    hardware.
    
    Signed-off-by: Anton Vorontsov <anton.vorontsov@linaro.org>
    Acked-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index bb010030828a..f9b22ec7a9f3 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -275,6 +275,7 @@ struct uart_ops {
 	int		(*verify_port)(struct uart_port *, struct serial_struct *);
 	int		(*ioctl)(struct uart_port *, unsigned int, unsigned long);
 #ifdef CONFIG_CONSOLE_POLL
+	int		(*poll_init)(struct uart_port *);
 	void	(*poll_put_char)(struct uart_port *, unsigned char);
 	int		(*poll_get_char)(struct uart_port *);
 #endif

commit 65ecc9c02dbad033a73a32916d17c107c5b25031
Author: Sean Young <sean@mess.org>
Date:   Fri Sep 7 19:06:24 2012 +0100

    8250: blacklist Winbond CIR port
    
    The legacy serial driver will detect the Winbond CIR device as a serial
    port, since it looks exactly like a serial port unless you know what
    it is from the PNP ID.
    
    Here we track this port as a special PORT_8250_CIR type, preventing the
    legacy serial driver from probing it.
    
    Signed-off-by: Sean Young <sean@mess.org>
    Acked-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 7cf0b68bbe9e..bb010030828a 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -48,7 +48,8 @@
 #define PORT_TEGRA	20	/* NVIDIA Tegra internal UART */
 #define PORT_XR17D15X	21	/* Exar XR17D15x UART */
 #define PORT_LPC3220	22	/* NXP LPC32xx SoC "Standard" UART */
-#define PORT_MAX_8250	22	/* max port ID */
+#define PORT_8250_CIR	23	/* CIR infrared port, has its own driver */
+#define PORT_MAX_8250	23	/* max port ID */
 
 /*
  * ARM specific type numbers.  These are not currently guaranteed

commit f65444187a66bf54af32a10902877dd0326456d1
Author: Alexander Shiyan <shc_work@mail.ru>
Date:   Mon Aug 6 19:42:32 2012 +0400

    serial: New serial driver MAX310X
    
    This driver is a replacement for a MAX3107 driver with a lot of
    improvements and new features.
    The main differences from the old version:
    - Using the regmap.
    - Using devm_XXX-related functions.
    - The use of threaded IRQ with IRQF_ONESHOT flag allows the driver to
      the hardware that supports only level IRQ.
    - Improved error handling of serial port, improved FIFO handling,
      improved hardware & software flow control.
    - Advanced flags allows turn on RS-485 mode (Auto direction control).
    - Ability to load multiple instances of drivers.
    - Added support for MAX3108.
    - GPIO support.
    - Driver is quite ready for adding I2C support and support other ICs
      with compatible registers set (MAX3109, MAX14830).
    
    Signed-off-by: Alexander Shiyan <shc_work@mail.ru>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 0253c2022e53..7cf0b68bbe9e 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -193,8 +193,8 @@
 /* SH-SCI */
 #define PORT_SCIFB	93
 
-/* MAX3107 */
-#define PORT_MAX3107	94
+/* MAX310X */
+#define PORT_MAX310X	94
 
 /* High Speed UART for Medfield */
 #define PORT_MFD	95

commit 7a5145965c9807732135630642c49f280b375f56
Author: Roland Stigge <stigge@antcom.de>
Date:   Mon Jun 11 21:57:13 2012 +0200

    serial/8250: Add LPC3220 standard UART type
    
    LPC32xx has "Standard" UARTs that are actually 16550A compatible but have
    bigger FIFOs. Since the already supported 16X50 line still doesn't match here,
    we agreed on adding a new type.
    
    Signed-off-by: Roland Stigge <stigge@antcom.de>
    Acked-by: Alan Cox <alan@linux.intel.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 65db9928e15f..0253c2022e53 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -47,7 +47,8 @@
 #define PORT_U6_16550A	19	/* ST-Ericsson U6xxx internal UART */
 #define PORT_TEGRA	20	/* NVIDIA Tegra internal UART */
 #define PORT_XR17D15X	21	/* Exar XR17D15x UART */
-#define PORT_MAX_8250	21	/* max port ID */
+#define PORT_LPC3220	22	/* NXP LPC32xx SoC "Standard" UART */
+#define PORT_MAX_8250	22	/* max port ID */
 
 /*
  * ARM specific type numbers.  These are not currently guaranteed

commit 665ab0f3c8b8f86bb77b25285ac93870c7054d63
Merge: bf03f65b7967 e816b57a337e
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Apr 18 15:57:31 2012 -0700

    Merge 3.4-rc3 into tty-next
    
    This allows us to pick up some changes needed for other serial patches.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

commit bf03f65b7967df5807ddef7b99f8a41d4c94fc70
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Apr 10 14:10:53 2012 -0700

    tegra, serial8250: add ->handle_break() uart_port op
    
    The "KT" serial port has another use case for a "received break" quirk,
    so before adding another special case to the 8250 core take this
    opportunity to push such quirks out of the core and into a uart_port op.
    
    Stephen says:
    "If the callback function is to no longer live in 8250.c itself,
     arch/arm/mach-tegra/devices.c isn't logically a good place to put it,
     and that file will be going away once we get rid of all the board files
     and move solely to device tree."
    
    ...so since 8250_pci.c houses all the quirks for pci serial devices this
    quirk is similarly housed in of_serial.c.  Once the open firmware
    conversion completes the infrastructure details
    (include/linux/of_serial.h, and the export) can all be removed to make
    this self contained to of_serial.c.
    
    Cc: Nhan H Mai <nhan.h.mai@intel.com>
    Cc: Colin Cross <ccross@android.com>
    Cc: Olof Johansson <olof@lixom.net>
    [stephen: kill CONFIG_SERIAL_TEGRA in favor just using CONFIG_ARCH_TEGRA]
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Sudhakar Mamillapalli <sudhakar@fb.com>
    Reported-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Acked-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Acked-by: Stephen Warren <swarren@wwwdotorg.org>
    Tested-by: Stephen Warren <swarren@wwwdotorg.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index f51bf2e70c69..0dd752f3039d 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -310,6 +310,7 @@ struct uart_port {
 	int			(*handle_irq)(struct uart_port *);
 	void			(*pm)(struct uart_port *, unsigned int state,
 				      unsigned int old);
+	void			(*handle_break)(struct uart_port *);
 	unsigned int		irq;			/* irq number */
 	unsigned long		irqflags;		/* irq flags  */
 	unsigned int		uartclk;		/* base uart clock */
@@ -533,6 +534,10 @@ uart_handle_sysrq_char(struct uart_port *port, unsigned int ch)
 static inline int uart_handle_break(struct uart_port *port)
 {
 	struct uart_state *state = port->state;
+
+	if (port->handle_break)
+		port->handle_break(port);
+
 #ifdef SUPPORT_SYSRQ
 	if (port->cons && port->cons->index == port->line) {
 		if (!port->sysrq) {

commit bc02d15a3452fdf9276e8fb89c5e504a88df888a
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Apr 6 11:49:50 2012 -0700

    serial/8250_pci: add a "force background timer" flag and use it for the "kt" serial port
    
    Workaround dropped notifications in the iir register.  Register reads
    coincident with new interrupt notifications sometimes result in this
    device clearing the interrupt event without reporting it in the read
    data.
    
    The serial core already has a heuristic for determining when a device
    has an untrustworthy iir register.  In this case when we apriori know
    that the iir is faulty use a flag (UPF_BUG_THRE) to bypass the test and
    force usage of the background timer.
    
    [stable: 3.3.x]
    Acked-by: Alan Cox <alan@linux.intel.com>
    Cc: stable <stable@vger.kernel.org>
    Reported-by: Nhan H Mai <nhan.h.mai@intel.com>
    Reported-by: Sudhakar Mamillapalli <sudhakar@fb.com>
    Tested-by: Nhan H Mai <nhan.h.mai@intel.com>
    Tested-by: Sudhakar Mamillapalli <sudhakar@fb.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 882f1d61aa56..2db407a40051 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -357,6 +357,7 @@ struct uart_port {
 #define UPF_CONS_FLOW		((__force upf_t) (1 << 23))
 #define UPF_SHARE_IRQ		((__force upf_t) (1 << 24))
 #define UPF_EXAR_EFR		((__force upf_t) (1 << 25))
+#define UPF_BUG_THRE		((__force upf_t) (1 << 26))
 /* The exact UART type is known and should not be probed.  */
 #define UPF_FIXED_TYPE		((__force upf_t) (1 << 27))
 #define UPF_BOOT_AUTOCONF	((__force upf_t) (1 << 28))

commit 49b532f96fda23663f8be35593d1c1372c0f91e0
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Apr 6 11:49:44 2012 -0700

    Revert "serial/8250_pci: setup-quirk workaround for the kt serial controller"
    
    This reverts commit 448ac154c957c4580531fa0c8f2045816fe2f0e7.
    
    The semantic of UPF_IIR_ONCE is only guaranteed to workaround the race
    condition in the kt serial's iir register if the only source of
    interrupts is THRE (fifo-empty) events.  An modem status event at the
    wrong time can again cause an iir read to drop the 'empty' status
    leading to a hang.  So, revert this in preparation for using the
    existing "I don't trust my iir register" workaround in the 8250 core
    (UART_BUG_THRE).
    
    [stable: 3.3.x]
    Cc: stable <stable@vger.kernel.org>
    Acked-by: Alan Cox <alan@linux.intel.com>
    Cc: Sudhakar Mamillapalli <sudhakar@fb.com>
    Reported-by: Nhan H Mai <nhan.h.mai@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index f51bf2e70c69..882f1d61aa56 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -357,7 +357,6 @@ struct uart_port {
 #define UPF_CONS_FLOW		((__force upf_t) (1 << 23))
 #define UPF_SHARE_IRQ		((__force upf_t) (1 << 24))
 #define UPF_EXAR_EFR		((__force upf_t) (1 << 25))
-#define UPF_IIR_ONCE		((__force upf_t) (1 << 26))
 /* The exact UART type is known and should not be probed.  */
 #define UPF_FIXED_TYPE		((__force upf_t) (1 << 27))
 #define UPF_BOOT_AUTOCONF	((__force upf_t) (1 << 28))

commit 927353a75602dd97144352f53177e18093fdd198
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Thu Mar 8 19:12:12 2012 -0500

    serial: introduce generic port in/out helpers
    
    Looking at the existing serial drivers (esp. the 8250 derived
    variants) we see a common trend.  They create a hardware specific
    port struct, which in turn contains a generic serial_port struct.
    
    The other trend, is that they all create some sort of shortcut
    to go through the hardware specific struct, to the serial_port
    struct, which has the basic in/out operations within.  Looking
    for the serial_in and serial_out in several drivers shows this.
    
    Rather than let this continue, lets create a generic set of
    similar helper wrappers that can be used on a struct port, so
    we can eliminate bouncing out through hardware specific struct
    pointers just to come back into struct port where possible.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Acked-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 585bfd03d2ee..f51bf2e70c69 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -383,6 +383,16 @@ struct uart_port {
 	void			*private_data;		/* generic platform data pointer */
 };
 
+static inline int serial_port_in(struct uart_port *up, int offset)
+{
+	return up->serial_in(up, offset);
+}
+
+static inline void serial_port_out(struct uart_port *up, int offset, int value)
+{
+	up->serial_out(up, offset, value);
+}
+
 /*
  * This is the state information which is persistent across opens.
  */

commit 3afbd89c9639c344300dcdd7d4e5e18dda559fd4
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Wed Jan 25 09:05:04 2012 +0100

    serial/efm32: add new driver
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index c91ace70c21d..585bfd03d2ee 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -210,6 +210,8 @@
 /* Atheros AR933X SoC */
 #define PORT_AR933X	99
 
+/* Energy Micro efm32 SoC */
+#define PORT_EFMUART   100
 
 #ifdef __KERNEL__
 

commit 4964e0664c80680fa6b28ef91381c076a5b25c2c
Merge: 0a80939b3e6a 7bf6612e8a9d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jan 14 13:05:21 2012 -0800

    Merge branch 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus
    
    * 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus: (119 commits)
      MIPS: Delete unused function add_temporary_entry.
      MIPS: Set default pci cache line size.
      MIPS: Flush huge TLB
      MIPS: Octeon: Remove SYS_SUPPORTS_HIGHMEM.
      MIPS: Octeon: Add support for OCTEON II PCIe
      MIPS: Octeon: Update PCI Latency timer and enable more error reporting.
      MIPS: Alchemy: Update cpu-feature-overrides
      MIPS: Alchemy: db1200: Improve PB1200 detection.
      MIPS: Alchemy: merge Au1000 and Au1300-style IRQ controller code.
      MIPS: Alchemy: chain IRQ controllers to MIPS IRQ controller
      MIPS: Alchemy: irq: register pm at irq init time
      MIPS: Alchemy: Touchscreen support on DB1100
      MIPS: Alchemy: Hook up IrDA on DB1000/DB1100
      net/irda: convert au1k_ir to platform driver.
      MIPS: Alchemy: remove unused board headers
      MTD: nand: make au1550nd.c a platform_driver
      MIPS: Netlogic: Mark Netlogic chips as SMT capable
      MIPS: Netlogic: Add support for XLP 3XX cores
      MIPS: Netlogic: Merge some of XLR/XLP wakup code
      MIPS: Netlogic: Add default XLP config.
      ...
    
    Fix up trivial conflicts in arch/mips/kernel/{perf_event_mipsxx.c,
    traps.c} and drivers/tty/serial/Makefile

commit d57f341ba08c9f34ccd45a89729e73174d4a3325
Author: Gabor Juhos <juhosg@openwrt.org>
Date:   Mon Jun 20 19:26:11 2011 +0200

    SERIAL: AR933X: Add driver for the built-in UART of the SoC
    
    This patch adds the driver for the built-in UART of the
    Atheros AR933X SoCs.
    
    Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
    Cc: linux-mips@linux-mips.org
    Cc: Kathy Giori <kgiori@qca.qualcomm.com>
    Cc: "Luis R.  Rodriguez" <rodrigue@qca.qualcomm.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: linux-serial@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/2526/
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index eadf33d0abba..3c35fb2f688f 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -207,6 +207,10 @@
 /* Xilinx PSS UART */
 #define PORT_XUARTPS	98
 
+/* Atheros AR933X SoC */
+#define PORT_AR933X	99
+
+
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>

commit 448ac154c957c4580531fa0c8f2045816fe2f0e7
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Nov 22 13:41:24 2011 -0800

    serial/8250_pci: setup-quirk workaround for the kt serial controller
    
    Workaround dropped notifications in the iir register.  Prevent reads
    coincident with new interrupt notifications by reading the iir at most
    once per interrupt.
    
    Reported-by: Nhan H Mai <nhan.h.mai@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Acked-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 945e02cae614..b67305e3ad57 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -351,6 +351,7 @@ struct uart_port {
 #define UPF_CONS_FLOW		((__force upf_t) (1 << 23))
 #define UPF_SHARE_IRQ		((__force upf_t) (1 << 24))
 #define UPF_EXAR_EFR		((__force upf_t) (1 << 25))
+#define UPF_IIR_ONCE		((__force upf_t) (1 << 26))
 /* The exact UART type is known and should not be probed.  */
 #define UPF_FIXED_TYPE		((__force upf_t) (1 << 27))
 #define UPF_BOOT_AUTOCONF	((__force upf_t) (1 << 28))

commit 027d7dacf73273dbe07a75b2ef5579616f17272c
Author: Jiri Slaby <jirislaby@kernel.org>
Date:   Wed Nov 9 21:33:43 2011 +0100

    TTY: serial, cleanup include file
    
    There are some functions (uart_handle_dcd_change, _handle_cts_change,
    _insert_char) which are big enough to not be inlined. So move them
    from .h to .c. We need to export them so that modules can actually use
    them.
    
    They will be even bigger when we introduce tty refcounting to them.
    
    While at it, cleanup the "Proud member of Uglyhacks'R'US". It means,
    define uart_handle_sysrq_char only when SUPPORT_SYSRQ is set.
    Otherwise define it as a macro. This is needed for some arm driver
    where the second parameter is undefined if expanded.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index eadf33d0abba..945e02cae614 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -483,10 +483,19 @@ static inline int uart_tx_stopped(struct uart_port *port)
 /*
  * The following are helper functions for the low level drivers.
  */
+
+extern void uart_handle_dcd_change(struct uart_port *uport,
+		unsigned int status);
+extern void uart_handle_cts_change(struct uart_port *uport,
+		unsigned int status);
+
+extern void uart_insert_char(struct uart_port *port, unsigned int status,
+		 unsigned int overrun, unsigned int ch, unsigned int flag);
+
+#ifdef SUPPORT_SYSRQ
 static inline int
 uart_handle_sysrq_char(struct uart_port *port, unsigned int ch)
 {
-#ifdef SUPPORT_SYSRQ
 	if (port->sysrq) {
 		if (ch && time_before(jiffies, port->sysrq)) {
 			handle_sysrq(ch);
@@ -495,11 +504,10 @@ uart_handle_sysrq_char(struct uart_port *port, unsigned int ch)
 		}
 		port->sysrq = 0;
 	}
-#endif
 	return 0;
 }
-#ifndef SUPPORT_SYSRQ
-#define uart_handle_sysrq_char(port,ch) uart_handle_sysrq_char(port, 0)
+#else
+#define uart_handle_sysrq_char(port,ch) ({ (void)port; 0; })
 #endif
 
 /*
@@ -522,89 +530,6 @@ static inline int uart_handle_break(struct uart_port *port)
 	return 0;
 }
 
-/**
- *	uart_handle_dcd_change - handle a change of carrier detect state
- *	@uport: uart_port structure for the open port
- *	@status: new carrier detect status, nonzero if active
- */
-static inline void
-uart_handle_dcd_change(struct uart_port *uport, unsigned int status)
-{
-	struct uart_state *state = uport->state;
-	struct tty_port *port = &state->port;
-	struct tty_ldisc *ld = tty_ldisc_ref(port->tty);
-	struct pps_event_time ts;
-
-	if (ld && ld->ops->dcd_change)
-		pps_get_ts(&ts);
-
-	uport->icount.dcd++;
-#ifdef CONFIG_HARD_PPS
-	if ((uport->flags & UPF_HARDPPS_CD) && status)
-		hardpps();
-#endif
-
-	if (port->flags & ASYNC_CHECK_CD) {
-		if (status)
-			wake_up_interruptible(&port->open_wait);
-		else if (port->tty)
-			tty_hangup(port->tty);
-	}
-
-	if (ld && ld->ops->dcd_change)
-		ld->ops->dcd_change(port->tty, status, &ts);
-	if (ld)
-		tty_ldisc_deref(ld);
-}
-
-/**
- *	uart_handle_cts_change - handle a change of clear-to-send state
- *	@uport: uart_port structure for the open port
- *	@status: new clear to send status, nonzero if active
- */
-static inline void
-uart_handle_cts_change(struct uart_port *uport, unsigned int status)
-{
-	struct tty_port *port = &uport->state->port;
-	struct tty_struct *tty = port->tty;
-
-	uport->icount.cts++;
-
-	if (port->flags & ASYNC_CTS_FLOW) {
-		if (tty->hw_stopped) {
-			if (status) {
-				tty->hw_stopped = 0;
-				uport->ops->start_tx(uport);
-				uart_write_wakeup(uport);
-			}
-		} else {
-			if (!status) {
-				tty->hw_stopped = 1;
-				uport->ops->stop_tx(uport);
-			}
-		}
-	}
-}
-
-#include <linux/tty_flip.h>
-
-static inline void
-uart_insert_char(struct uart_port *port, unsigned int status,
-		 unsigned int overrun, unsigned int ch, unsigned int flag)
-{
-	struct tty_struct *tty = port->state->port.tty;
-
-	if ((status & port->ignore_status_mask & ~overrun) == 0)
-		tty_insert_flip_char(tty, ch, flag);
-
-	/*
-	 * Overrun is special.  Since it's reported immediately,
-	 * it doesn't affect the current character.
-	 */
-	if (status & ~port->ignore_status_mask & overrun)
-		tty_insert_flip_char(tty, 0, TTY_OVERRUN);
-}
-
 /*
  *	UART_ENABLE_MS - determine if port should enable modem status irqs
  */

commit 06315348b16178e4c006e7892ef8e5e65f49c66a
Author: Søren Holm <sgh@sgh.dk>
Date:   Fri Sep 2 22:55:37 2011 +0200

    serial: Support the EFR-register of XR1715x uarts.
    
    The EFR (Enhenced-Features-Register) is located at a different offset
    than the other devices supporting UART_CAP_EFR. This change add a special
    setup quick to set UPF_EXAR_EFR on the port. UPF_EXAR_EFR is then used to
    the port type to PORT_XR17D15X since it is for sure a XR17D15X uart.
    
    Signed-off-by: Søren Holm <sgh@sgh.dk>
    Acked-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 493773e3b46d..eadf33d0abba 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -46,7 +46,8 @@
 #define PORT_AR7	18	/* Texas Instruments AR7 internal UART */
 #define PORT_U6_16550A	19	/* ST-Ericsson U6xxx internal UART */
 #define PORT_TEGRA	20	/* NVIDIA Tegra internal UART */
-#define PORT_MAX_8250	20	/* max port ID */
+#define PORT_XR17D15X	21	/* Exar XR17D15x UART */
+#define PORT_MAX_8250	21	/* max port ID */
 
 /*
  * ARM specific type numbers.  These are not currently guaranteed
@@ -349,6 +350,7 @@ struct uart_port {
 #define UPF_MAGIC_MULTIPLIER	((__force upf_t) (1 << 16))
 #define UPF_CONS_FLOW		((__force upf_t) (1 << 23))
 #define UPF_SHARE_IRQ		((__force upf_t) (1 << 24))
+#define UPF_EXAR_EFR		((__force upf_t) (1 << 25))
 /* The exact UART type is known and should not be probed.  */
 #define UPF_FIXED_TYPE		((__force upf_t) (1 << 27))
 #define UPF_BOOT_AUTOCONF	((__force upf_t) (1 << 28))

commit 4834d028978583dfe8e1fc19f1180ceb03d8dfb7
Author: Jamie Iles <jamie@jamieiles.com>
Date:   Mon Aug 15 10:17:55 2011 +0100

    tty: serial8250: remove UPIO_DWAPB{,32}
    
    Now that platforms can override the port IRQ handler and the only user
    of these UPIO modes has been converted over, kill off UPIO_DWAPB and
    UPIO_DWAPB32.
    
    Acked-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Jamie Iles <jamie@jamieiles.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index c31ae43c073d..493773e3b46d 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -318,9 +318,7 @@ struct uart_port {
 #define UPIO_MEM32		(3)
 #define UPIO_AU			(4)			/* Au1x00 type IO */
 #define UPIO_TSI		(5)			/* Tsi108/109 type IO */
-#define UPIO_DWAPB		(6)			/* DesignWare APB UART */
-#define UPIO_RM9000		(7)			/* RM9000 type IO */
-#define UPIO_DWAPB32		(8)			/* DesignWare APB UART (32 bit accesses) */
+#define UPIO_RM9000		(6)			/* RM9000 type IO */
 
 	unsigned int		read_status_mask;	/* driver specific */
 	unsigned int		ignore_status_mask;	/* driver specific */

commit a74036f51272975e9538e80cd1bb64dce164b208
Author: Jamie Iles <jamie@jamieiles.com>
Date:   Mon Aug 15 10:17:51 2011 +0100

    tty: serial: allow ports to override the irq handler
    
    Some serial ports may have unusal requirements for interrupt handling
    (e.g. the Synopsys DesignWare 8250-alike port and it's busy detect
    interrupt).  Add a .handle_irq callback that can be used for platforms
    to override the interrupt behaviour in a similar fashion to the
    .serial_out and .serial_in callbacks.
    
    Signed-off-by: Jamie Iles <jamie@jamieiles.com>
    Acked-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 76e110363745..c31ae43c073d 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -300,6 +300,7 @@ struct uart_port {
 	void			(*set_termios)(struct uart_port *,
 				               struct ktermios *new,
 				               struct ktermios *old);
+	int			(*handle_irq)(struct uart_port *);
 	void			(*pm)(struct uart_port *, unsigned int state,
 				      unsigned int old);
 	unsigned int		irq;			/* irq number */

commit 6a3e492b6daaf7ec4dc41e51d87d2aae8ff886f2
Author: Jiri Slaby <jirislaby@kernel.org>
Date:   Thu Jul 14 14:35:12 2011 +0200

    TTY: serial, remove tasklet for tty_wakeup
    
    tty_wakeup can be called from any context. So there is no need to have
    an extra tasklet for calling that. Hence save some space and remove
    the tasklet completely.
    
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index a5c31146a337..76e110363745 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -384,7 +384,6 @@ struct uart_state {
 	int			pm_state;
 	struct circ_buf		xmit;
 
-	struct tasklet_struct	tlet;
 	struct uart_port	*uart_port;
 };
 

commit 4539c24fe4f92c09ee668ef959d3e8180df619b9
Author: Stephen Warren <swarren@nvidia.com>
Date:   Tue May 17 16:12:36 2011 -0600

    tty/serial: Add explicit PORT_TEGRA type
    
    Tegra's UART is currently auto-detected as PORT_XSCALE due to register
    bit UART_IER.UUE being writable. However, the Tegra documentation states
    that this register bit is reserved. Hence, we should not program it.
    
    Instead, the documentation specifies that the UART is 16550 compatible.
    However, Tegra does need register bit UART_IER.RTOIE set, which is not
    enabled by any 16550 port type. This was not noticed before, since
    PORT_XSCALE enables CAP_UUE, which conflates both UUE and RTOIE bit
    programming.
    
    This change defines PORT_TEGRA that doesn't set UART_CAP_UUE, but does
    set UART_CAP_RTOIE, which is a new capability indicating that the RTOIE
    bit needs to be enabled.
    
    Based-on-code-by: Laxman Dewangan <ldewangan@nvidia.com>
    Cc: Laxman Dewangan <ldewangan@nvidia.com>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>
    Acked-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 95d479ba514e..a5c31146a337 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -45,7 +45,8 @@
 #define PORT_OCTEON	17	/* Cavium OCTEON internal UART */
 #define PORT_AR7	18	/* Texas Instruments AR7 internal UART */
 #define PORT_U6_16550A	19	/* ST-Ericsson U6xxx internal UART */
-#define PORT_MAX_8250	19	/* max port ID */
+#define PORT_TEGRA	20	/* NVIDIA Tegra internal UART */
+#define PORT_MAX_8250	20	/* max port ID */
 
 /*
  * ARM specific type numbers.  These are not currently guaranteed

commit 61ec9016988f5c030e96e3c8a42ee9e11b8517aa
Author: John Linn <john.linn@xilinx.com>
Date:   Sat Apr 30 00:07:43 2011 -0400

    tty/serial: add support for Xilinx PS UART
    
    The Xilinx PS Uart is used on the new ARM based SoC. This
    UART is not compatible with others such that a seperate
    driver is required.
    
    Signed-off-by: John Linn <john.linn@xilinx.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 758c5b0c6fd3..95d479ba514e 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -202,6 +202,9 @@
 /* VIA VT8500 SoC */
 #define PORT_VT8500	97
 
+/* Xilinx PSS UART */
+#define PORT_XUARTPS	98
+
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>

commit 6f4229b51106cbc859e9d8209b22c8a2ec749e64
Author: Alexander Gordeev <lasaine@lvk.cs.msu.su>
Date:   Wed Jan 12 17:00:50 2011 -0800

    pps: unify timestamp gathering
    
    Add a helper function to gather timestamps.  This way clients don't have
    to duplicate it.
    
    Signed-off-by: Alexander Gordeev <lasaine@lvk.cs.msu.su>
    Acked-by: Rodolfo Giometti <giometti@linux.it>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index a23fa29d4eb0..758c5b0c6fd3 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -212,6 +212,7 @@
 #include <linux/tty.h>
 #include <linux/mutex.h>
 #include <linux/sysrq.h>
+#include <linux/pps_kernel.h>
 
 struct uart_port;
 struct serial_struct;
@@ -528,10 +529,10 @@ uart_handle_dcd_change(struct uart_port *uport, unsigned int status)
 	struct uart_state *state = uport->state;
 	struct tty_port *port = &state->port;
 	struct tty_ldisc *ld = tty_ldisc_ref(port->tty);
-	struct timespec ts;
+	struct pps_event_time ts;
 
 	if (ld && ld->ops->dcd_change)
-		getnstimeofday(&ts);
+		pps_get_ts(&ts);
 
 	uport->icount.dcd++;
 #ifdef CONFIG_HARD_PPS

commit 3f960dbb9dfe29ff283810624c4340c79fde87f5
Author: Govindraj.R <govindraj.raja@ti.com>
Date:   Thu Dec 16 18:12:47 2010 +0530

    Serial: Avoid unbalanced IRQ wake disable during resume
    
    To avoid unbalanced IRQ wake disable, ensure that wakeups are disabled
    only when wakeups have been successfully enabled.
    Tested on OMAP3630SDP/ZOOM3.
    
    Signed-off-by: Govindraj.R <govindraj.raja@ti.com>
    Reported-by: Paul Walmsley <paul@pwsan.com>
    Cc: Santosh Shilimkar <santosh.shilimkar@ti.com>
    Acked-by: Kevin Hilman <khilman@deeprootsystems.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 7a6daf189995..a23fa29d4eb0 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -365,6 +365,7 @@ struct uart_port {
 	struct device		*dev;			/* parent device */
 	unsigned char		hub6;			/* this should be in the 8250 driver */
 	unsigned char		suspended;
+	unsigned char		irq_wake;
 	unsigned char		unused[2];
 	void			*private_data;		/* generic platform data pointer */
 };

commit a3ae0fc34f58e7163b7724feb3d77aa4603f0dc3
Author: Jamie Iles <jamie@jamieiles.com>
Date:   Wed Dec 1 23:39:36 2010 +0000

    8250: add a UPIO_DWAPB32 for 32 bit accesses
    
    Some platforms contain a Synopsys DesignWare APB UART that is attached
    to a 32-bit APB bus where sub-word accesses are not allowed. Add a new
    IO type (UPIO_DWAPB32) that performs 32 bit acccesses to the UART.
    
    v2:
            - don't test for 32 bit in the output fast path, provide a
              separate dwabp32_serial_out() function. Refactor
              dwabp_serial_out() so that we can reuse the LCR saving
              code.
    v3:
            - rebased on top of "8250: use container_of() instead of
              casting"
    
    Signed-off-by: Jamie Iles <jamie@jamieiles.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 9ff9b7db293b..7a6daf189995 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -314,6 +314,7 @@ struct uart_port {
 #define UPIO_TSI		(5)			/* Tsi108/109 type IO */
 #define UPIO_DWAPB		(6)			/* DesignWare APB UART */
 #define UPIO_RM9000		(7)			/* RM9000 type IO */
+#define UPIO_DWAPB32		(8)			/* DesignWare APB UART (32 bit accesses) */
 
 	unsigned int		read_status_mask;	/* driver specific */
 	unsigned int		ignore_status_mask;	/* driver specific */

commit e44dcb6c377529805bbaae505d5b333daab69111
Author: Wolfram Sang <wsa@kernel.org>
Date:   Fri Nov 12 19:47:47 2010 +0100

    serial: mpc52xx: make printout for type more generic
    
    The printout for the type should be just "5xxx", so 512x users won't
    wonder why they have a mpc52xx-type UART.
    
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 41603d690433..9ff9b7db293b 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -95,7 +95,7 @@
 /* PPC CPM type number */
 #define PORT_CPM        58
 
-/* MPC52xx type numbers */
+/* MPC52xx (and MPC512x) type numbers */
 #define PORT_MPC52xx	59
 
 /* IBM icom */

commit 304e12665a4a7b8b25dfe8c64fa4fd56a04a67ea
Author: Alexey Charkov <alchark@gmail.com>
Date:   Mon Nov 8 20:33:20 2010 +0300

    serial: Add support for UART on VIA VT8500 and compatibles
    
    This adds a driver for the serial ports found in VIA and WonderMedia
    Systems-on-Chip. Interrupt-driven FIFO operation is implemented.
    The hardware also supports pure register-based operation (which is
    slower) and DMA-based FIFO operation. As the FIFOs are only 16 bytes
    long, DMA operation is probably not worth the hassle.
    
    Signed-off-by: Alexey Charkov <alchark@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 212eb4c67797..41603d690433 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -199,6 +199,9 @@
 /* TI OMAP-UART */
 #define PORT_OMAP	96
 
+/* VIA VT8500 SoC */
+#define PORT_VT8500	97
+
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>

commit 7b6181e06841f5ad15c4ff708b967b4db65a64de
Merge: 72e58063d63c bc487fb341af
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 25 13:46:56 2010 -0700

    Merge branch 'omap-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap-2.6
    
    * 'omap-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap-2.6: (163 commits)
      omap: complete removal of machine_desc.io_pg_offst and .phys_io
      omap: UART: fix wakeup registers for OMAP24xx UART2
      omap: Fix spotty MMC voltages
      ASoC: OMAP4: MCPDM: Remove unnecessary include of plat/control.h
      serial: omap-serial: fix signess error
      OMAP3: DMA: Errata i541: sDMA FIFO draining does not finish
      omap: dma: Fix buffering disable bit setting for omap24xx
      omap: serial: Fix the boot-up crash/reboot without CONFIG_PM
      OMAP3: PM: fix scratchpad memory accesses for off-mode
      omap4: pandaboard: enable the ehci port on pandaboard
      omap4: pandaboard: Fix the init if CONFIG_MMC_OMAP_HS is not set
      omap4: pandaboard: remove unused hsmmc definition
      OMAP: McBSP: Remove null omap44xx ops comment
      OMAP: McBSP: Swap CLKS source definition
      OMAP: McBSP: Fix CLKR and FSR signal muxing
      OMAP2+: clock: reduce the amount of standard debugging while disabling unused clocks
      OMAP: control: move plat-omap/control.h to mach-omap2/control.h
      OMAP: split plat-omap/common.c
      OMAP: McBSP: implement functional clock switching via clock framework
      OMAP: McBSP: implement McBSP CLKR and FSR signal muxing via mach-omap2/mcbsp.c
      ...
    
    Fixed up trivial conflicts in arch/arm/mach-omap2/
    {board-zoom-peripherals.c,devices.c} as per Tony

commit c161afe9759ddcc174d08e7c4f683d08ac9ba86f
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Sat Sep 25 15:13:45 2010 +0200

    8250: allow platforms to override PM hook.
    
    Add a hook for platforms to specify custom pm methods.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@googlemail.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index ac48082f3559..99e5994e6f84 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -289,6 +289,8 @@ struct uart_port {
 	void			(*set_termios)(struct uart_port *,
 				               struct ktermios *new,
 				               struct ktermios *old);
+	void			(*pm)(struct uart_port *, unsigned int state,
+				      unsigned int old);
 	unsigned int		irq;			/* irq number */
 	unsigned long		irqflags;		/* irq flags  */
 	unsigned int		uartclk;		/* base uart clock */

commit 54381067ed7873e6173d6fe32818a585ad667723
Author: Anton Vorontsov <cbouatmailru@gmail.com>
Date:   Fri Oct 1 17:21:25 2010 +0400

    serial: Factor out uart_poll_timeout() from 8250 driver
    
    Soon we will use that handy function in the altera_uart driver.
    
    Signed-off-by: Anton Vorontsov <cbouatmailru@gmail.com>
    Cc: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 563e23400913..ac48082f3559 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -411,6 +411,14 @@ unsigned int uart_get_baud_rate(struct uart_port *port, struct ktermios *termios
 				unsigned int max);
 unsigned int uart_get_divisor(struct uart_port *port, unsigned int baud);
 
+/* Base timer interval for polling */
+static inline int uart_poll_timeout(struct uart_port *port)
+{
+	int timeout = port->timeout;
+
+	return timeout > 6 ? (timeout / 2 - 2) : 1;
+}
+
 /*
  * Console helpers.
  */

commit b612633b5928077441b979471869753bfa93d41a
Author: Govindraj.R <govindraj.raja@ti.com>
Date:   Mon Sep 27 20:20:49 2010 +0530

    serial: Add OMAP high-speed UART driver
    
    This patch adds driver support for OMAP2/3/4 high speed UART.
    
    The driver is made separate from 8250 driver as we cannot
    over load 8250 driver with omap platform specific configuration for
    features like DMA, it makes easier to implement features like DMA and
    hardware flow control and software flow control configuration with
    this driver as required for the omap-platform.
    This patch involves only the core driver and its dependent.
    
    Cc: Tony Lindgren <tony@atomide.com>
    Signed-off-by: Govindraj.R <govindraj.raja@ti.com>
    Acked-by: Alan Cox <alan@linux.intel.com>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 563e23400913..295e89817de8 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -196,6 +196,9 @@
 /* High Speed UART for Medfield */
 #define PORT_MFD	95
 
+/* TI OMAP-UART */
+#define PORT_OMAP	96
+
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>

commit 71cad0554956de87c3fc413b1eac9313887eb14f
Author: Philippe Langlais <philippe.langlais@stericsson.com>
Date:   Tue Aug 31 14:19:09 2010 +0200

    serial: fix port type conflict between NS16550A & U6_16550A
    
    Bug seen by Dr. David Alan Gilbert with sparse
    
    Signed-off-by: Philippe Langlais <philippe.langlais@stericsson.com>
    Cc: stable <stable@kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 64458a9a8938..563e23400913 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -44,7 +44,8 @@
 #define PORT_RM9000	16	/* PMC-Sierra RM9xxx internal UART */
 #define PORT_OCTEON	17	/* Cavium OCTEON internal UART */
 #define PORT_AR7	18	/* Texas Instruments AR7 internal UART */
-#define PORT_MAX_8250	18	/* max port ID */
+#define PORT_U6_16550A	19	/* ST-Ericsson U6xxx internal UART */
+#define PORT_MAX_8250	19	/* max port ID */
 
 /*
  * ARM specific type numbers.  These are not currently guaranteed

commit f335397d177c906256ee1bba28e8c49e8ec63817
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Tue Aug 17 21:15:47 2010 -0700

    Input: sysrq - drop tty argument form handle_sysrq()
    
    Sysrq operations do not accept tty argument anymore so no need to pass
    it to us.
    
    [Stephen Rothwell <sfr@canb.auug.org.au>: fix build breakage in drm code
     caused by sysrq using bool but not including linux/types.h]
    
    [Sachin Sant <sachinp@in.ibm.com>: fix build breakage in s390 keyboadr
     driver]
    
    Acked-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Acked-by: Jason Wessel <jason.wessel@windriver.com>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Dmitry Torokhov <dtor@mail.ru>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 3c2ad99fed34..64458a9a8938 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -465,7 +465,7 @@ uart_handle_sysrq_char(struct uart_port *port, unsigned int ch)
 #ifdef SUPPORT_SYSRQ
 	if (port->sysrq) {
 		if (ch && time_before(jiffies, port->sysrq)) {
-			handle_sysrq(ch, port->state->port.tty);
+			handle_sysrq(ch);
 			port->sysrq = 0;
 			return 1;
 		}

commit 636d17427b1ef0e97bd9df9b3b0e0f314ff889d3
Merge: dd21e9bdff14 0b019a41553a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Aug 11 09:13:19 2010 -0700

    Merge branch 'for-linus' of master.kernel.org:/home/rmk/linux-2.6-arm
    
    * 'for-linus' of master.kernel.org:/home/rmk/linux-2.6-arm: (226 commits)
      ARM: 6323/1: cam60: don't use __init for cam60_spi_{flash_platform_data,partitions}
      ARM: 6324/1: cam60: move cam60_spi_devices to .init.data
      ARM: 6322/1: imx/pca100: Fix name of spi platform data
      ARM: 6321/1: fix syntax error in main Kconfig file
      ARM: 6297/1: move U300 timer to dynamic clock lookup
      ARM: 6296/1: clock U300 intcon and timer properly
      ARM: 6295/1: fix U300 apb_pclk split
      ARM: 6306/1: fix inverted MMC card detect in U300
      ARM: 6299/1: errata: TLBIASIDIS and TLBIMVAIS operations can broadcast a faulty ASID
      ARM: 6294/1: etm: do a dummy read from OSSRR during initialization
      ARM: 6292/1: coresight: add ETM management registers
      ARM: 6288/1: ftrace: document mcount formats
      ARM: 6287/1: ftrace: clean up mcount assembly indentation
      ARM: 6286/1: fix Thumb-2 decompressor broken by "Auto calculate ZRELADDR"
      ARM: 6281/1: video/imxfb.c: allow usage without BACKLIGHT_CLASS_DEVICE
      ARM: 6280/1: imx: Fix build failure when including <mach/gpio.h> without <linux/spinlock.h>
      ARM: S5PV210: Fix on missing s3c-sdhci card detection method for hsmmc3
      ARM: S5P: Fix on missing S5P_DEV_FIMC in plat-s5p/Kconfig
      ARM: S5PV210: Override FIMC driver name on Aquila board
      ARM: S5PC100: enable FIMC on SMDKC100
      ...
    
    Fix up conflicts in arch/arm/mach-{s5pc100,s5pv210}/cpu.c due to
    different subsystem 'setname' calls, and trivial port types in
    include/linux/serial_core.h

commit 235dae5d094c415fcf0fc79fa637f1901bc8afe2
Author: Philippe Langlais <philippe.langlais@stericsson.com>
Date:   Thu Jul 29 17:13:57 2010 +0200

    U6715 16550A serial driver support
    
    UART Features extract from STEricsson U6715 data-sheet (arm926 SoC for mobile phone):
    * Fully compatible with industry standard 16C550 and 16C450 from various
    manufacturers
    * RX and TX 64 byte FIFO reduces CPU interrupts
    * Full double buffering
    * Modem control signals include CTS, RTS, (and DSR, DTR on UART1 only)
    * Automatic baud rate selection
    * Manual or automatic RTS/CTS smart hardware flow control
    * Programmable serial characteristics:
    – Baud rate generation (50 to 3.25M baud)
    – 5, 6, 7 or 8-bit characters
    – Even, odd or no-parity bit generation and detection
    – 1, 1.5 or 2 stop bit generation
    * Independent control of transmit, receive, line status, data set interrupts and FIFOs
    * Full status-reporting capabilities
    * Separate DMA signaling for RX and TX
    * Timed interrupt to spread receive interrupt on known duration
    * DMA time-out interrupt to allow detection of end of reception
    * Carkit pulse coding and decoding compliant with USB carkit control interface [40]
    
    In 16550A auto-configuration, if the fifo size is 64 then it's an U6 16550A port
    Add set_termios hook & export serial8250_do_set_termios to change uart
    clock following baudrate
    
    Signed-off-by: Philippe Langlais <philippe.langlais@stericsson.com>
    Acked-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index f8fce351463d..8129ca2d57e3 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -282,6 +282,9 @@ struct uart_port {
 	unsigned char __iomem	*membase;		/* read/write[bwl] */
 	unsigned int		(*serial_in)(struct uart_port *, int);
 	void			(*serial_out)(struct uart_port *, int, int);
+	void			(*set_termios)(struct uart_port *,
+				               struct ktermios *new,
+				               struct ktermios *old);
 	unsigned int		irq;			/* irq number */
 	unsigned long		irqflags;		/* irq flags  */
 	unsigned int		uartclk;		/* base uart clock */

commit d843fc6e9dc9bee7061b6833594860ea93ad98e1
Author: Feng Tang <feng.tang@intel.com>
Date:   Tue Jul 27 08:20:22 2010 +0100

    hsu: driver for Medfield High Speed UART device
    
    This is a PCI & UART driver, which suppors both PIO and DMA mode
    UART operation. It has 3 identical UART ports and one internal
    DMA controller.
    
    Current FW will export 4 pci devices for hsu: 3 uart ports and 1
    dma controller, each has one IRQ line. And we need to discuss the
    device model, one PCI device covering whole HSU should be a better
    model, but there is a problem of how to export the 4 IRQs info
    
    Current driver set the highest baud rate to 2746800bps, which is
    easy to scale down to 115200/230400.... To suport higher baud rate,
    we need add special process, change DLAB/DLH/PS/DIV/MUL registers
    all together.
    
    921600 is the highest baud rate that has been tested with Bluetooth
    modem connected to HSU port 0. Will test more when there is right
    BT firmware.
    
    Current version contains several work around for A0's Silicon bugs
    
    Signed-off-by: Feng Tang <feng.tang@intel.com>
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 9ddc866ccc09..f8fce351463d 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -189,6 +189,8 @@
 /* MAX3107 */
 #define PORT_MAX3107	94
 
+/* High Speed UART for Medfield */
+#define PORT_MFD	95
 
 #ifdef __KERNEL__
 

commit 61fd15262bb9c88a05fd89af22add9317dc1b1f4
Author: Alan Cox <alan@linux.intel.com>
Date:   Wed Jun 30 17:58:38 2010 +0100

    serial: max3107: Abstract out the platform specific bits
    
    At the moment there is only one platform type supported and there is is
    hard wired, but with these changes the infrastructure is now there for
    anyone else to provide methods for their hardware.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 32928161fab6..9ddc866ccc09 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -186,6 +186,10 @@
 #define PORT_ALTERA_JTAGUART	91
 #define PORT_ALTERA_UART	92
 
+/* MAX3107 */
+#define PORT_MAX3107	94
+
+
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>

commit d87d9b7d19f04b16c4406d3c0feeca10090e0ada
Author: Alan Cox <alan@linux.intel.com>
Date:   Tue Jun 1 22:52:53 2010 +0200

    tty: serial - fix tty referencing in set_ldisc
    
    Pass down the ldisc number so that the drivers don't have to peek into the
    tty object themselves. This lets us get rid of another case of back referencing
    port to tty which we don't want (because of races versus hangup/close).
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index f10db6e5f3b5..32928161fab6 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -220,7 +220,7 @@ struct uart_ops {
 	void		(*flush_buffer)(struct uart_port *);
 	void		(*set_termios)(struct uart_port *, struct ktermios *new,
 				       struct ktermios *old);
-	void		(*set_ldisc)(struct uart_port *);
+	void		(*set_ldisc)(struct uart_port *, int new);
 	void		(*pm)(struct uart_port *, unsigned int state,
 			      unsigned int oldstate);
 	int		(*set_wake)(struct uart_port *, unsigned int state);

commit 75b93489b449db4a34f0424c72f51821d985f52f
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Sun May 23 16:39:02 2010 +0000

    serial: add a new port type, found on some sh-mobile SoCs
    
    Such ports are found, e.g., on SH7372.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index f10db6e5f3b5..522832023a69 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -186,6 +186,9 @@
 #define PORT_ALTERA_JTAGUART	91
 #define PORT_ALTERA_UART	92
 
+/* SH-SCI */
+#define PORT_SCIFB	93
+
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>

commit 90b9a32d8f441369b2f97a765d2d957b531eb653
Merge: 8b108c609ade 4402c153cb9c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 21 11:08:05 2010 -0700

    Merge branch 'kdb-merge' of git://git.kernel.org/pub/scm/linux/kernel/git/jwessel/linux-2.6-kgdb
    
    * 'kdb-merge' of git://git.kernel.org/pub/scm/linux/kernel/git/jwessel/linux-2.6-kgdb: (25 commits)
      kdb,debug_core: Allow the debug core to receive a panic notification
      MAINTAINERS: update kgdb, kdb, and debug_core info
      debug_core,kdb: Allow the debug core to process a recursive debug entry
      printk,kdb: capture printk() when in kdb shell
      kgdboc,kdb: Allow kdb to work on a non open console port
      kgdb: Add the ability to schedule a breakpoint via a tasklet
      mips,kgdb: kdb low level trap catch and stack trace
      powerpc,kgdb: Introduce low level trap catching
      x86,kgdb: Add low level debug hook
      kgdb: remove post_primary_code references
      kgdb,docs: Update the kgdb docs to include kdb
      kgdboc,keyboard: Keyboard driver for kdb with kgdb
      kgdb: gdb "monitor" -> kdb passthrough
      sparc,sunzilog: Add console polling support for sunzilog serial driver
      sh,sh-sci: Use NO_POLL_CHAR in the SCIF polled console code
      kgdb,8250,pl011: Return immediately from console poll
      kgdb: core changes to support kdb
      kdb: core for kgdb back end (2 of 2)
      kdb: core for kgdb back end (1 of 2)
      kgdb,blackfin: Add in kgdb_arch_set_pc for blackfin
      ...

commit 6b7d8f8b5c43f7bedda750d8a9dab0658da1d2ba
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Wed May 5 10:35:23 2010 +0200

    serial: Add driver for the Altera UART
    
    Add an UART driver for the UART component available as a SOPC (System on
    Programmable Chip) component for Altera FPGAs.
    
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index ade1536e1a48..09d0d2d5a08b 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -184,6 +184,7 @@
 
 /* Altera UARTs */
 #define PORT_ALTERA_JTAGUART	91
+#define PORT_ALTERA_UART	92
 
 #ifdef __KERNEL__
 

commit 5bcd601049c6b2ad52733d4cd2794bfbaf1b9314
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Wed May 5 10:35:22 2010 +0200

    serial: Add driver for the Altera JTAG UART
    
    Add an UART driver for the JTAG UART component available as a SOPC
    (System on Programmable Chip) component for Altera FPGAs.
    
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 78dd1e7120a9..ade1536e1a48 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -182,6 +182,9 @@
 /* Aeroflex Gaisler GRLIB APBUART */
 #define PORT_APBUART    90
 
+/* Altera UARTs */
+#define PORT_ALTERA_JTAGUART	91
+
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>

commit f5316b4aea024da9266d740322a5481657f6ce59
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Thu May 20 21:04:22 2010 -0500

    kgdb,8250,pl011: Return immediately from console poll
    
    The design of the kdb shell requires that every device that can
    provide input to kdb have a polling routine that exits immediately if
    there is no character available.  This is required in order to get the
    page scrolling mechanism working.
    
    Changing the kernel debugger I/O API to require all polling character
    routines to exit immediately if there is no data allows the kernel
    debugger to process multiple input channels.
    
    NO_POLL_CHAR will be the return code to the polling routine when ever
    there is no character available.
    
    CC: linux-serial@vger.kernel.org
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 78dd1e7120a9..ad839963fa68 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -246,6 +246,7 @@ struct uart_ops {
 #endif
 };
 
+#define NO_POLL_CHAR		0x00ff0000
 #define UART_CONFIG_TYPE	(1 << 0)
 #define UART_CONFIG_IRQ		(1 << 1)
 

commit a0880df0ccde8d551fc4d88c455acb2ee0801e26
Author: Rodolfo Giometti <giometti@linux.it>
Date:   Wed Mar 10 15:23:47 2010 -0800

    pps: serial clients support
    
    Adds support, by using the PPS line discipline, for the PPS sources
    connected with the CD (Carrier Detect) pin of a serial port.
    
    [akpm@linux-foundation.org: fix cast size warnings]
    Signed-off-by: Rodolfo Giometti <giometti@linux.it>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Greg KH <greg@kroah.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Alexander Gordeev <lasaine@lvk.cs.msu.su>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 8c3dd36fe91a..78dd1e7120a9 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -491,9 +491,13 @@ uart_handle_dcd_change(struct uart_port *uport, unsigned int status)
 {
 	struct uart_state *state = uport->state;
 	struct tty_port *port = &state->port;
+	struct tty_ldisc *ld = tty_ldisc_ref(port->tty);
+	struct timespec ts;
 
-	uport->icount.dcd++;
+	if (ld && ld->ops->dcd_change)
+		getnstimeofday(&ts);
 
+	uport->icount.dcd++;
 #ifdef CONFIG_HARD_PPS
 	if ((uport->flags & UPF_HARDPPS_CD) && status)
 		hardpps();
@@ -505,6 +509,11 @@ uart_handle_dcd_change(struct uart_port *uport, unsigned int status)
 		else if (port->tty)
 			tty_hangup(port->tty);
 	}
+
+	if (ld && ld->ops->dcd_change)
+		ld->ops->dcd_change(port->tty, status, &ts);
+	if (ld)
+		tty_ldisc_deref(ld);
 }
 
 /**

commit d4ac42a582e46d7f86f0acb4253a310423c72c4c
Author: Kristoffer Glembo <kristoffer@gaisler.com>
Date:   Wed Nov 4 08:39:46 2009 -0800

    sparc: Support for GRLIB APBUART serial port
    
    This patch adds support for the APBUART serial port from Aeroflex
    Gaisler's IP library GRLIB. It is currently used in all LEON3 designs
    (SPARC V8) but can be used on other platforms as well (which support OF).
    
    Signed-off-by: Kristoffer Glembo <kristoffer@gaisler.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index db532ce288be..8c3dd36fe91a 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -179,6 +179,9 @@
 /* BCM63xx family SoCs */
 #define PORT_BCM63XX	89
 
+/* Aeroflex Gaisler GRLIB APBUART */
+#define PORT_APBUART    90
+
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>

commit 9fcd66e572b94974365a9119b073e0a43d496eb7
Author: Maxime Bizon <mbizon@freebox.fr>
Date:   Fri Sep 18 13:04:58 2009 +0200

    MIPS: BCM63xx: Add serial driver for bcm63xx integrated UART.
    
    Signed-off-by: Maxime Bizon <mbizon@freebox.fr>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index fe661afe0713..db532ce288be 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -176,6 +176,9 @@
 /* Qualcomm MSM SoCs */
 #define PORT_MSM	88
 
+/* BCM63xx family SoCs */
+#define PORT_BCM63XX	89
+
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>

commit 1b9894f342a39601bb0420b7b8c7e445670c1b51
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Mon Sep 21 11:12:03 2009 -0700

    serial core: fix new kernel-doc warnings
    
    Fix new kernel-doc warnings in serial_core.[hc] files.
    
      Warning(include/linux/serial_core.h:485): No description found for parameter 'uport'
      Warning(include/linux/serial_core.h:485): Excess function parameter 'port' description in 'uart_handle_dcd_change'
      Warning(include/linux/serial_core.h:511): No description found for parameter 'uport'
      Warning(include/linux/serial_core.h:511): Excess function parameter 'port' description in 'uart_handle_cts_change'
      Warning(drivers/serial/serial_core.c:2437): No description found for parameter 'uport'
      Warning(drivers/serial/serial_core.c:2437): Excess function parameter 'port' description in 'uart_add_one_port'
      Warning(drivers/serial/serial_core.c:2509): No description found for parameter 'uport'
      Warning(drivers/serial/serial_core.c:2509): Excess function parameter 'port' description in 'uart_remove_one_port'
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index d58e460844dd..fe661afe0713 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -477,7 +477,7 @@ static inline int uart_handle_break(struct uart_port *port)
 
 /**
  *	uart_handle_dcd_change - handle a change of carrier detect state
- *	@port: uart_port structure for the open port
+ *	@uport: uart_port structure for the open port
  *	@status: new carrier detect status, nonzero if active
  */
 static inline void
@@ -503,7 +503,7 @@ uart_handle_dcd_change(struct uart_port *uport, unsigned int status)
 
 /**
  *	uart_handle_cts_change - handle a change of clear-to-send state
- *	@port: uart_port structure for the open port
+ *	@uport: uart_port structure for the open port
  *	@status: new clear to send status, nonzero if active
  */
 static inline void

commit 016af53a6de6837e5be3da68901083ea85ebb4da
Author: Alan Cox <alan@linux.intel.com>
Date:   Sat Sep 19 13:13:32 2009 -0700

    serial: kill USF_CLOSING_* definitions
    
    The serial layer for some reason uses different defines for the special
    case close delays and then conditionally switches to/from the normal ones
    in the ioctls.
    
    Remove this rather pointless abstraction
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index bcafecd3b7c1..d58e460844dd 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -342,9 +342,6 @@ struct uart_port {
 struct uart_state {
 	struct tty_port		port;
 
-#define USF_CLOSING_WAIT_INF	(0)
-#define USF_CLOSING_WAIT_NONE	(~0U)
-
 	int			pm_state;
 	struct circ_buf		xmit;
 

commit bdc04e3174e18f475289fa8f4144f66686326b7e
Author: Alan Cox <alan@linux.intel.com>
Date:   Sat Sep 19 13:13:31 2009 -0700

    serial: move delta_msr_wait into the tty_port
    
    This is used by various drivers not just serial and can be extracted
    as commonality
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 27767ea5fa29..bcafecd3b7c1 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -349,7 +349,6 @@ struct uart_state {
 	struct circ_buf		xmit;
 
 	struct tasklet_struct	tlet;
-	wait_queue_head_t	delta_msr_wait;
 	struct uart_port	*uart_port;
 };
 

commit a2bceae065ed8c4f552b35c4dde4cc2db05ce9e3
Author: Alan Cox <alan@linux.intel.com>
Date:   Sat Sep 19 13:13:31 2009 -0700

    serial: replace the state mutex with the tty port mutex
    
    They cover essentially the same stuff and we can therefore fold it into the
    tty_port one.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index f98dc78abb27..27767ea5fa29 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -351,8 +351,6 @@ struct uart_state {
 	struct tasklet_struct	tlet;
 	wait_queue_head_t	delta_msr_wait;
 	struct uart_port	*uart_port;
-
-	struct mutex		mutex;
 };
 
 #define UART_XMIT_SIZE	PAGE_SIZE

commit a03006860d272eac5a8ebf23f04f54c7e1e783a5
Author: Alan Cox <alan@linux.intel.com>
Date:   Sat Sep 19 13:13:30 2009 -0700

    serial: kill off uif_t
    
    This typedef is now extinct
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 284ef7f54890..f98dc78abb27 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -336,19 +336,8 @@ struct uart_port {
 	void			*private_data;		/* generic platform data pointer */
 };
 
-/*
- * This is the state information which is only valid when the port
- * is open; it may be cleared the core driver once the device has
- * been closed.  Either the low level driver or the core can modify
- * stuff here.
- */
-typedef unsigned int __bitwise__ uif_t;
-
-
 /*
  * This is the state information which is persistent across opens.
- * The low level driver must not to touch any elements contained
- * within.
  */
 struct uart_state {
 	struct tty_port		port;

commit ccce6debb62d94964e3878f978a56b0f3e32d94f
Author: Alan Cox <alan@linux.intel.com>
Date:   Sat Sep 19 13:13:30 2009 -0700

    serial: move the flags into the tty_port field
    
    Fortunately the serial layer was designed to use the same flag values but
    with different names. It has its own SUSPENDED flag which is a free slot in
    the ASYNC flags so we allocate it in the ASYNC flags instead.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 63ad90966db2..284ef7f54890 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -20,6 +20,8 @@
 #ifndef LINUX_SERIAL_CORE_H
 #define LINUX_SERIAL_CORE_H
 
+#include <linux/serial.h>
+
 /*
  * The type definitions.  These are from Ted Ts'o's serial.h
  */
@@ -356,19 +358,6 @@ struct uart_state {
 
 	int			pm_state;
 	struct circ_buf		xmit;
-	uif_t			flags;
-
-/*
- * Definitions for info->flags.  These are _private_ to serial_core, and
- * are specific to this structure.  They may be queried by low level drivers.
- *
- * FIXME: use the ASY_ definitions
- */
-#define UIF_CHECK_CD		((__force uif_t) (1 << 25))
-#define UIF_CTS_FLOW		((__force uif_t) (1 << 26))
-#define UIF_NORMAL_ACTIVE	((__force uif_t) (1 << 29))
-#define UIF_INITIALIZED		((__force uif_t) (1 << 31))
-#define UIF_SUSPENDED		((__force uif_t) (1 << 30))
 
 	struct tasklet_struct	tlet;
 	wait_queue_head_t	delta_msr_wait;
@@ -509,22 +498,23 @@ static inline int uart_handle_break(struct uart_port *port)
  *	@status: new carrier detect status, nonzero if active
  */
 static inline void
-uart_handle_dcd_change(struct uart_port *port, unsigned int status)
+uart_handle_dcd_change(struct uart_port *uport, unsigned int status)
 {
-	struct uart_state *state = port->state;
+	struct uart_state *state = uport->state;
+	struct tty_port *port = &state->port;
 
-	port->icount.dcd++;
+	uport->icount.dcd++;
 
 #ifdef CONFIG_HARD_PPS
-	if ((port->flags & UPF_HARDPPS_CD) && status)
+	if ((uport->flags & UPF_HARDPPS_CD) && status)
 		hardpps();
 #endif
 
-	if (state->flags & UIF_CHECK_CD) {
+	if (port->flags & ASYNC_CHECK_CD) {
 		if (status)
-			wake_up_interruptible(&state->port.open_wait);
-		else if (state->port.tty)
-			tty_hangup(state->port.tty);
+			wake_up_interruptible(&port->open_wait);
+		else if (port->tty)
+			tty_hangup(port->tty);
 	}
 }
 
@@ -534,24 +524,24 @@ uart_handle_dcd_change(struct uart_port *port, unsigned int status)
  *	@status: new clear to send status, nonzero if active
  */
 static inline void
-uart_handle_cts_change(struct uart_port *port, unsigned int status)
+uart_handle_cts_change(struct uart_port *uport, unsigned int status)
 {
-	struct uart_state *state = port->state;
-	struct tty_struct *tty = state->port.tty;
+	struct tty_port *port = &uport->state->port;
+	struct tty_struct *tty = port->tty;
 
-	port->icount.cts++;
+	uport->icount.cts++;
 
-	if (state->flags & UIF_CTS_FLOW) {
+	if (port->flags & ASYNC_CTS_FLOW) {
 		if (tty->hw_stopped) {
 			if (status) {
 				tty->hw_stopped = 0;
-				port->ops->start_tx(port);
-				uart_write_wakeup(port);
+				uport->ops->start_tx(uport);
+				uart_write_wakeup(uport);
 			}
 		} else {
 			if (!status) {
 				tty->hw_stopped = 1;
-				port->ops->stop_tx(port);
+				uport->ops->stop_tx(uport);
 			}
 		}
 	}

commit 91312cdb4fcd832341e425f74f49938e0503c929
Author: Alan Cox <alan@linux.intel.com>
Date:   Sat Sep 19 13:13:29 2009 -0700

    serial: move count into the tty_port version
    
    Remove more stuff from the serial special case code
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index fd11d4d5a571..63ad90966db2 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -354,7 +354,6 @@ struct uart_state {
 #define USF_CLOSING_WAIT_INF	(0)
 #define USF_CLOSING_WAIT_NONE	(~0U)
 
-	int			count;
 	int			pm_state;
 	struct circ_buf		xmit;
 	uif_t			flags;

commit 5e99df561fc830730d63672d795a0b02ef8cdd6f
Author: Alan Cox <alan@linux.intel.com>
Date:   Sat Sep 19 13:13:28 2009 -0700

    serial: Fold closing_* fields into the tty_port ones
    
    Remove some more serial specific use
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index c1542703fbab..fd11d4d5a571 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -350,8 +350,6 @@ typedef unsigned int __bitwise__ uif_t;
  */
 struct uart_state {
 	struct tty_port		port;
-	unsigned int		close_delay;		/* msec */
-	unsigned int		closing_wait;		/* msec */
 
 #define USF_CLOSING_WAIT_INF	(0)
 #define USF_CLOSING_WAIT_NONE	(~0U)

commit ebd2c8f6d2ec4012c267ecb95e72a57b8355a705
Author: Alan Cox <alan@linux.intel.com>
Date:   Sat Sep 19 13:13:28 2009 -0700

    serial: kill off uart_info
    
    We moved this into uart_state, now move the fields out of the separate
    structure and kill it off.
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 3cd255f0b211..c1542703fbab 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -186,7 +186,6 @@
 #include <linux/sysrq.h>
 
 struct uart_port;
-struct uart_info;
 struct serial_struct;
 struct device;
 
@@ -284,7 +283,7 @@ struct uart_port {
 
 	unsigned int		read_status_mask;	/* driver specific */
 	unsigned int		ignore_status_mask;	/* driver specific */
-	struct uart_info	*info;			/* pointer to parent info */
+	struct uart_state	*state;			/* pointer to parent state */
 	struct uart_icount	icount;			/* statistics */
 
 	struct console		*cons;			/* struct console, if any */
@@ -343,8 +342,22 @@ struct uart_port {
  */
 typedef unsigned int __bitwise__ uif_t;
 
-struct uart_info {
+
+/*
+ * This is the state information which is persistent across opens.
+ * The low level driver must not to touch any elements contained
+ * within.
+ */
+struct uart_state {
 	struct tty_port		port;
+	unsigned int		close_delay;		/* msec */
+	unsigned int		closing_wait;		/* msec */
+
+#define USF_CLOSING_WAIT_INF	(0)
+#define USF_CLOSING_WAIT_NONE	(~0U)
+
+	int			count;
+	int			pm_state;
 	struct circ_buf		xmit;
 	uif_t			flags;
 
@@ -362,24 +375,7 @@ struct uart_info {
 
 	struct tasklet_struct	tlet;
 	wait_queue_head_t	delta_msr_wait;
-};
-
-/*
- * This is the state information which is persistent across opens.
- * The low level driver must not to touch any elements contained
- * within.
- */
-struct uart_state {
-	unsigned int		close_delay;		/* msec */
-	unsigned int		closing_wait;		/* msec */
-
-#define USF_CLOSING_WAIT_INF	(0)
-#define USF_CLOSING_WAIT_NONE	(~0U)
-
-	int			count;
-	int			pm_state;
-	struct uart_info	info;
-	struct uart_port	*port;
+	struct uart_port	*uart_port;
 
 	struct mutex		mutex;
 };
@@ -462,7 +458,7 @@ int uart_resume_port(struct uart_driver *reg, struct uart_port *port);
 
 static inline int uart_tx_stopped(struct uart_port *port)
 {
-	struct tty_struct *tty = port->info->port.tty;
+	struct tty_struct *tty = port->state->port.tty;
 	if(tty->stopped || tty->hw_stopped)
 		return 1;
 	return 0;
@@ -477,7 +473,7 @@ uart_handle_sysrq_char(struct uart_port *port, unsigned int ch)
 #ifdef SUPPORT_SYSRQ
 	if (port->sysrq) {
 		if (ch && time_before(jiffies, port->sysrq)) {
-			handle_sysrq(ch, port->info->port.tty);
+			handle_sysrq(ch, port->state->port.tty);
 			port->sysrq = 0;
 			return 1;
 		}
@@ -495,7 +491,7 @@ uart_handle_sysrq_char(struct uart_port *port, unsigned int ch)
  */
 static inline int uart_handle_break(struct uart_port *port)
 {
-	struct uart_info *info = port->info;
+	struct uart_state *state = port->state;
 #ifdef SUPPORT_SYSRQ
 	if (port->cons && port->cons->index == port->line) {
 		if (!port->sysrq) {
@@ -506,7 +502,7 @@ static inline int uart_handle_break(struct uart_port *port)
 	}
 #endif
 	if (port->flags & UPF_SAK)
-		do_SAK(info->port.tty);
+		do_SAK(state->port.tty);
 	return 0;
 }
 
@@ -518,7 +514,7 @@ static inline int uart_handle_break(struct uart_port *port)
 static inline void
 uart_handle_dcd_change(struct uart_port *port, unsigned int status)
 {
-	struct uart_info *info = port->info;
+	struct uart_state *state = port->state;
 
 	port->icount.dcd++;
 
@@ -527,11 +523,11 @@ uart_handle_dcd_change(struct uart_port *port, unsigned int status)
 		hardpps();
 #endif
 
-	if (info->flags & UIF_CHECK_CD) {
+	if (state->flags & UIF_CHECK_CD) {
 		if (status)
-			wake_up_interruptible(&info->port.open_wait);
-		else if (info->port.tty)
-			tty_hangup(info->port.tty);
+			wake_up_interruptible(&state->port.open_wait);
+		else if (state->port.tty)
+			tty_hangup(state->port.tty);
 	}
 }
 
@@ -543,12 +539,12 @@ uart_handle_dcd_change(struct uart_port *port, unsigned int status)
 static inline void
 uart_handle_cts_change(struct uart_port *port, unsigned int status)
 {
-	struct uart_info *info = port->info;
-	struct tty_struct *tty = info->port.tty;
+	struct uart_state *state = port->state;
+	struct tty_struct *tty = state->port.tty;
 
 	port->icount.cts++;
 
-	if (info->flags & UIF_CTS_FLOW) {
+	if (state->flags & UIF_CTS_FLOW) {
 		if (tty->hw_stopped) {
 			if (status) {
 				tty->hw_stopped = 0;
@@ -570,7 +566,7 @@ static inline void
 uart_insert_char(struct uart_port *port, unsigned int status,
 		 unsigned int overrun, unsigned int ch, unsigned int flag)
 {
-	struct tty_struct *tty = port->info->port.tty;
+	struct tty_struct *tty = port->state->port.tty;
 
 	if ((status & port->ignore_status_mask & ~overrun) == 0)
 		tty_insert_flip_char(tty, ch, flag);

commit 1c2f04937b3e397a5695953c6b82aa4c77d21eb8
Author: Vikram Pandita <vikram.pandita@ti.com>
Date:   Sat Sep 19 13:13:19 2009 -0700

    serial: 8250: add IRQ trigger support
    
    There is currently no provision for passing IRQ trigger flags for
    serial IRQs with triggering requirements (such as GPIO IRQs)
    
    This patch adds irqflags to plat_serial8250_port that can be passed
    from board file to reqest_irq() of 8250 driver
    
    Changes are backward compatible with boards passing UPF_SHARE_IRQ flag
    
    Tested on Zoom2 board that has IRQF_TRIGGER_RISING requirement for 8250 irq
    
    [Moved new flag to end to fix bugs in the original with the old_serial array
            -- Alan]
    
    Signed-off-by: Vikram Pandita <vikram.pandita@ti.com>
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 23d2fb051f97..3cd255f0b211 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -265,6 +265,7 @@ struct uart_port {
 	unsigned int		(*serial_in)(struct uart_port *, int);
 	void			(*serial_out)(struct uart_port *, int, int);
 	unsigned int		irq;			/* irq number */
+	unsigned long		irqflags;		/* irq flags  */
 	unsigned int		uartclk;		/* base uart clock */
 	unsigned int		fifosize;		/* tx fifo size */
 	unsigned char		x_char;			/* xon/xoff char */

commit 04896a77a97b87e1611dedd61be88264ef4ac96c
Author: Robert Love <rlove@google.com>
Date:   Mon Jun 22 18:43:11 2009 +0100

    msm_serial: serial driver for MSM7K onboard serial peripheral.
    
    Signed-off-by: Brian Swetland <swetland@google.com>
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 6fd80c4243f1..23d2fb051f97 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -171,6 +171,9 @@
 /* Timberdale UART */
 #define PORT_TIMBUART	87
 
+/* Qualcomm MSM SoCs */
+#define PORT_MSM	88
+
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>

commit 34aec591847c696339189b070cce2a11f901cfea
Author: Richard Röjfors <richard.rojfors.ext@mocean-labs.com>
Date:   Thu Jun 11 14:05:39 2009 +0100

    serial: Added Timberdale UART driver
    
    Driver for the UART found in the Timberdale FPGA
    
    Signed-off-by: Richard Röjfors <richard.rojfors.ext@mocean-labs.com>
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 48766ea845cf..6fd80c4243f1 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -168,6 +168,9 @@
 /* MAX3100 */
 #define PORT_MAX3100    86
 
+/* Timberdale UART */
+#define PORT_TIMBUART	87
+
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>

commit 08e0992f60ad44025a8a8b8a821838ca4a562686
Author: Florian Fainelli <florian@openwrt.org>
Date:   Thu Jun 11 13:21:24 2009 +0100

    serial: add support for the TI AR7 internal UART
    
    This patch adds support for the TI AR7 internal UART.
    
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 57a97e52e58d..48766ea845cf 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -41,7 +41,8 @@
 #define PORT_XSCALE	15
 #define PORT_RM9000	16	/* PMC-Sierra RM9xxx internal UART */
 #define PORT_OCTEON	17	/* Cavium OCTEON internal UART */
-#define PORT_MAX_8250	17	/* max port ID */
+#define PORT_AR7	18	/* Texas Instruments AR7 internal UART */
+#define PORT_MAX_8250	18	/* max port ID */
 
 /*
  * ARM specific type numbers.  These are not currently guaranteed

commit 1dcb884ca8048efb4ce2999d367c26369ab2227c
Author: Christian Pellegrin <chripell@gmail.com>
Date:   Tue Apr 7 16:48:51 2009 +0100

    Add support for the MAX3100 SPI UART.
    
    (akpm: queued pending confirmation of the new major number)
    
    [randy.dunlap@oracle.com: select SERIAL_CORE]
    Signed-off-by: Christian Pellegrin <chripell@fsfe.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 83e4b3ff9cda..57a97e52e58d 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -164,6 +164,9 @@
 /* NWPSERIAL */
 #define PORT_NWPSERIAL	85
 
+/* MAX3100 */
+#define PORT_MAX3100    86
+
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>

commit 06e82df015afad2d96d030f76f5e4d13e6dcdfa4
Author: Alexander Beregalov <a.beregalov@gmail.com>
Date:   Mon Apr 6 17:34:34 2009 +0100

    mux: fix build problem
    
    Fixes:
    
      In file included from drivers/serial/mux.c:37:
      include/linux/serial_core.h: In function 'uart_handle_sysrq_char':
      include/linux/serial_core.h:467: error: 'struct uart_port' has no member named 'sysrq'
      include/linux/serial_core.h:468: error: 'struct uart_port' has no member named 'sysrq'
    
    Signed-off-by: Alexander Beregalov <a.beregalov@gmail.com>
    Signed-off-by: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index df9245c7bd3b..83e4b3ff9cda 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -277,7 +277,7 @@ struct uart_port {
 	struct uart_icount	icount;			/* statistics */
 
 	struct console		*cons;			/* struct console, if any */
-#ifdef CONFIG_SERIAL_CORE_CONSOLE
+#if defined(CONFIG_SERIAL_CORE_CONSOLE) || defined(SUPPORT_SYSRQ)
 	unsigned long		sysrq;			/* sysrq timeout */
 #endif
 

commit b6adea334c6c89d5e6c94f9196bbf3a279cb53bd
Author: Mauro Carvalho Chehab <mchehab@kernel.org>
Date:   Fri Feb 20 15:38:52 2009 -0800

    8250: fix boot hang with serial console when using with Serial Over Lan port
    
    Intel 8257x Ethernet boards have a feature called Serial Over Lan.
    
    This feature works by emulating a serial port, and it is detected by
    kernel as a normal 8250 port.  However, this emulation is not perfect, as
    also noticed on changeset 7500b1f602aad75901774a67a687ee985d85893f.
    
    Before this patch, the kernel were trying to check if the serial TX is
    capable of work using IRQ's.
    
    This were done with a code similar this:
    
            serial_outp(up, UART_IER, UART_IER_THRI);
            lsr = serial_in(up, UART_LSR);
            iir = serial_in(up, UART_IIR);
            serial_outp(up, UART_IER, 0);
    
            if (lsr & UART_LSR_TEMT && iir & UART_IIR_NO_INT)
                    up->bugs |= UART_BUG_TXEN;
    
    This works fine for other 8250 ports, but, on 8250-emulated SoL port, the
    chip is a little lazy to down UART_IIR_NO_INT at UART_IIR register.
    
    Due to that, UART_BUG_TXEN is sometimes enabled.  However, as TX IRQ keeps
    working, and the TX polling is now enabled, the driver miss-interprets the
    IRQ received later, hanging up the machine until a key is pressed at the
    serial console.
    
    This is the 6 version of this patch.  Previous versions were trying to
    introduce a large enough delay between serial_outp and serial_in(up,
    UART_IIR), but not taking forever.  However, the needed delay couldn't be
    safely determined.
    
    At the experimental tests, a delay of 1us solves most of the cases, but
    still hangs sometimes.  Increasing the delay to 5us was better, but still
    doesn't solve.  A very high delay of 50 ms seemed to work every time.
    
    However, poking around with delays and pray for it to be enough doesn't
    seem to be a good approach, even for a quirk.
    
    So, instead of playing with random large arbitrary delays, let's just
    disable UART_BUG_TXEN for all SoL ports.
    
    [akpm@linux-foundation.org: fix warnings]
    Signed-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 90bbbf0b1161..df9245c7bd3b 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -296,6 +296,7 @@ struct uart_port {
 #define UPF_HARDPPS_CD		((__force upf_t) (1 << 11))
 #define UPF_LOW_LATENCY		((__force upf_t) (1 << 13))
 #define UPF_BUGGY_UART		((__force upf_t) (1 << 14))
+#define UPF_NO_TXEN_TEST	((__force upf_t) (1 << 15))
 #define UPF_MAGIC_MULTIPLIER	((__force upf_t) (1 << 16))
 #define UPF_CONS_FLOW		((__force upf_t) (1 << 23))
 #define UPF_SHARE_IRQ		((__force upf_t) (1 << 24))

commit 5886188dc7ba9a76babcd37452f44079a9a77f71
Author: Benjamin Krill <ben@codiert.org>
Date:   Wed Jan 7 10:32:38 2009 +0100

    serial: Add driver for the Cell Network Processor serial port NWP device
    
    Add support for the nwp serial device which is connected to a DCR bus. It
    uses the of_serial device driver to determine necessary properties from
    the device tree.  The supported device is added as serial port number 85.
    
    NWP stands for network processor and it is part of the QPACE - Quantum
    Chromodynamics Parallel Computing on the Cell Broadband Engine project.
    The implementation is a lightweight uart implementation with the focus
    to consume as little resources as possible and it is connected to a
    DCR bus.
    
    Signed-off-by: Benjamin Krill <ben@codiert.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index b4199841f1fc..90bbbf0b1161 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -161,6 +161,9 @@
 
 #define PORT_S3C6400	84
 
+/* NWPSERIAL */
+#define PORT_NWPSERIAL	85
+
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>

commit 6b06f19151c335ee0c5b61839fa4e6838182ebb8
Author: David Daney <ddaney@caviumnetworks.com>
Date:   Fri Jan 2 13:50:00 2009 +0000

    Serial: UART driver changes for Cavium OCTEON.
    
    Cavium UART implementation is not covered by existing uart_configS.
    Define a new uart_config (PORT_OCTEON) which is specified by OCTEON
    platform device registration code.
    
    Signed-off-by: Tomaso Paoletti <tpaoletti@caviumnetworks.com>
    Signed-off-by: David Daney <ddaney@caviumnetworks.com>
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index f155252f148c..b4199841f1fc 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -40,7 +40,8 @@
 #define PORT_NS16550A	14
 #define PORT_XSCALE	15
 #define PORT_RM9000	16	/* PMC-Sierra RM9xxx internal UART */
-#define PORT_MAX_8250	16	/* max port ID */
+#define PORT_OCTEON	17	/* Cavium OCTEON internal UART */
+#define PORT_MAX_8250	17	/* max port ID */
 
 /*
  * ARM specific type numbers.  These are not currently guaranteed

commit 8e23fcc89c8091790903927449f8efb9b4e23960
Author: David Daney <ddaney@caviumnetworks.com>
Date:   Fri Jan 2 13:49:54 2009 +0000

    Serial: Allow port type to be specified when calling serial8250_register_port.
    
    Add flag value UPF_FIXED_TYPE which specifies that the UART type is
    known and should not be probed.  For this case the UARTs properties
    are just copied out of the uart_config entry.
    
    This allows us to keep SOC specific 8250 probe code out of 8250.c.  In
    this case we know the serial hardware will not be changing as it is on
    the same silicon as the CPU, and we can specify it with certainty in
    the board/cpu setup code.
    
    The alternative is to load up 8250.c with a bunch of OCTEON specific
    special cases in the probing code.
    
    Signed-off-by: David Daney <ddaney@caviumnetworks.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 60061f44f3d8..f155252f148c 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -295,6 +295,8 @@ struct uart_port {
 #define UPF_MAGIC_MULTIPLIER	((__force upf_t) (1 << 16))
 #define UPF_CONS_FLOW		((__force upf_t) (1 << 23))
 #define UPF_SHARE_IRQ		((__force upf_t) (1 << 24))
+/* The exact UART type is known and should not be probed.  */
+#define UPF_FIXED_TYPE		((__force upf_t) (1 << 27))
 #define UPF_BOOT_AUTOCONF	((__force upf_t) (1 << 28))
 #define UPF_FIXED_PORT		((__force upf_t) (1 << 29))
 #define UPF_DEAD		((__force upf_t) (1 << 30))

commit 7d6a07d123b62bf4fa71867420c23da3ca36c995
Author: David Daney <ddaney@caviumnetworks.com>
Date:   Fri Jan 2 13:49:47 2009 +0000

    8250: Serial driver changes to support future Cavium OCTEON serial patches.
    
    In order to use Cavium OCTEON specific serial i/o drivers, we first
    patch the 8250 driver to use replaceable I/O functions.  Compatible
    I/O functions are added for existing iotypeS.
    
    An added benefit of this change is that it makes it easy to factor
    some of the existing special cases out to board/SOC specific support
    code.
    
    The alternative is to load up 8250.c with a bunch of OCTEON specific
    iotype code and bug work-arounds.
    
    Signed-off-by: David Daney <ddaney@caviumnetworks.com>
    Signed-off-by: Tomaso Paoletti <tpaoletti@caviumnetworks.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 2395969faa04..60061f44f3d8 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -248,6 +248,8 @@ struct uart_port {
 	spinlock_t		lock;			/* port lock */
 	unsigned long		iobase;			/* in/out[bwl] */
 	unsigned char __iomem	*membase;		/* read/write[bwl] */
+	unsigned int		(*serial_in)(struct uart_port *, int);
+	void			(*serial_out)(struct uart_port *, int, int);
 	unsigned int		irq;			/* irq number */
 	unsigned int		uartclk;		/* base uart clock */
 	unsigned int		fifosize;		/* tx fifo size */

commit f751928e0ddf54ea4fe5546f35e99efc5b5d9938
Author: Alan Cox <alan@redhat.com>
Date:   Fri Jan 2 13:49:21 2009 +0000

    tty: We want the port object to be persistent
    
    Move the tty_port and uart_info bits around a little. By embedding the uart_info
    into the uart_port we get rid of lots of corner case testing and also get the
    ability to go port<->state<->info which is a bit more elegant than the current
    data structures.
    
    Downsides - we allocate a tiny bit more memory for unused ports, upside we've
    removed as much code as it saved for most users..
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index feb3b939ec4b..2395969faa04 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -315,36 +315,14 @@ struct uart_port {
 	void			*private_data;		/* generic platform data pointer */
 };
 
-/*
- * This is the state information which is persistent across opens.
- * The low level driver must not to touch any elements contained
- * within.
- */
-struct uart_state {
-	unsigned int		close_delay;		/* msec */
-	unsigned int		closing_wait;		/* msec */
-
-#define USF_CLOSING_WAIT_INF	(0)
-#define USF_CLOSING_WAIT_NONE	(~0U)
-
-	int			count;
-	int			pm_state;
-	struct uart_info	*info;
-	struct uart_port	*port;
-
-	struct mutex		mutex;
-};
-
-#define UART_XMIT_SIZE	PAGE_SIZE
-
-typedef unsigned int __bitwise__ uif_t;
-
 /*
  * This is the state information which is only valid when the port
- * is open; it may be freed by the core driver once the device has
+ * is open; it may be cleared the core driver once the device has
  * been closed.  Either the low level driver or the core can modify
  * stuff here.
  */
+typedef unsigned int __bitwise__ uif_t;
+
 struct uart_info {
 	struct tty_port		port;
 	struct circ_buf		xmit;
@@ -366,6 +344,29 @@ struct uart_info {
 	wait_queue_head_t	delta_msr_wait;
 };
 
+/*
+ * This is the state information which is persistent across opens.
+ * The low level driver must not to touch any elements contained
+ * within.
+ */
+struct uart_state {
+	unsigned int		close_delay;		/* msec */
+	unsigned int		closing_wait;		/* msec */
+
+#define USF_CLOSING_WAIT_INF	(0)
+#define USF_CLOSING_WAIT_NONE	(~0U)
+
+	int			count;
+	int			pm_state;
+	struct uart_info	info;
+	struct uart_port	*port;
+
+	struct mutex		mutex;
+};
+
+#define UART_XMIT_SIZE	PAGE_SIZE
+
+
 /* number of characters left in xmit buffer before we ask for more */
 #define WAKEUP_CHARS		256
 
@@ -439,8 +440,13 @@ int uart_resume_port(struct uart_driver *reg, struct uart_port *port);
 #define uart_circ_chars_free(circ)	\
 	(CIRC_SPACE((circ)->head, (circ)->tail, UART_XMIT_SIZE))
 
-#define uart_tx_stopped(portp)		\
-	((portp)->info->port.tty->stopped || (portp)->info->port.tty->hw_stopped)
+static inline int uart_tx_stopped(struct uart_port *port)
+{
+	struct tty_struct *tty = port->info->port.tty;
+	if(tty->stopped || tty->hw_stopped)
+		return 1;
+	return 0;
+}
 
 /*
  * The following are helper functions for the low level drivers.
@@ -451,7 +457,7 @@ uart_handle_sysrq_char(struct uart_port *port, unsigned int ch)
 #ifdef SUPPORT_SYSRQ
 	if (port->sysrq) {
 		if (ch && time_before(jiffies, port->sysrq)) {
-			handle_sysrq(ch, port->info ? port->info->port.tty : NULL);
+			handle_sysrq(ch, port->info->port.tty);
 			port->sysrq = 0;
 			return 1;
 		}

commit b690ace50be7d10d77cb7a6d5ef1bd9de649852f
Author: Ben Dooks <ben-linux@fluff.org>
Date:   Tue Oct 21 14:07:03 2008 +0100

    [ARM] S3C6400: serial support for S3C6400 and S3C6410 SoCs
    
    Add support to the Samsung serial driver for the S3C6400
    and S3C6410 serial ports.
    
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 4e4f1277f3bf..feb3b939ec4b 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -158,6 +158,8 @@
 /* SH-SCI */
 #define PORT_SCIFA	83
 
+#define PORT_S3C6400	84
+
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>

commit 1a22f08dbd0e77c7cf45b5f527f93131d0b591b6
Author: Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
Date:   Tue Nov 11 12:19:05 2008 +0900

    serial: sh-sci: fix cannot work SH7723 SCIFA
    
    SH7723 has SCIFA. This module is similer SCI register map, but it has FIFO.
    So this patch adds new type(PORT_SCIFA) and change some type checking.
    
    Signed-off-by: Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
    Signed-off-by: Paul Mundt <lethal@linux-sh.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index e27f216361fc..4e4f1277f3bf 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -155,6 +155,9 @@
 
 #define PORT_SC26XX	82
 
+/* SH-SCI */
+#define PORT_SCIFA	83
+
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>

commit 0c8946d97ae7d2d6691f8290a10faa63453b63f8
Author: David Miller <davem@davemloft.net>
Date:   Mon Oct 13 10:35:23 2008 +0100

    serial: Make uart_port's ioport "unsigned long".
    
    Otherwise the top 32-bits of the resource value get chopped
    off on 64-bit systems, and the resulting I/O accesses go to
    random places.
    
    Thanks to testing and debugging by Josip Rodin, which helped
    track this down.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 3b2f6c04855e..e27f216361fc 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -241,7 +241,7 @@ typedef unsigned int __bitwise__ upf_t;
 
 struct uart_port {
 	spinlock_t		lock;			/* port lock */
-	unsigned int		iobase;			/* in/out[bwl] */
+	unsigned long		iobase;			/* in/out[bwl] */
 	unsigned char __iomem	*membase;		/* read/write[bwl] */
 	unsigned int		irq;			/* irq number */
 	unsigned int		uartclk;		/* base uart clock */

commit f606ddf42fd4edc558eeb48bfee66d2c591571d2
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Jul 23 21:28:50 2008 -0700

    remove the v850 port
    
    Trying to compile the v850 port brings many compile errors, one of them exists
    since at least kernel 2.6.19.
    
    There also seems to be noone willing to bring this port back into a usable
    state.
    
    This patch therefore removes the v850 port.
    
    If anyone ever decides to revive the v850 port the code will still be
    available from older kernels, and it wouldn't be impossible for the port to
    reenter the kernel if it would become actively maintained again.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Acked-by: Greg Ungerer <gerg@uclinux.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index f3a1c0e45021..3b2f6c04855e 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -59,9 +59,6 @@
 #define PORT_SUNZILOG	38
 #define PORT_SUNSAB	39
 
-/* NEC v850.  */
-#define PORT_V850E_UART	40
-
 /* DEC */
 #define PORT_DZ		46
 #define PORT_ZS		47

commit df4f4dd429870f435f8d5d9d561db029a29f063b
Author: Alan Cox <alan@redhat.com>
Date:   Wed Jul 16 21:53:50 2008 +0100

    serial: use tty_port
    
    Switch the serial_core based drivers to use the new tty_port structure.
    We can't quite use all of it yet because of the dynamically allocated
    extras in the serial_core layer.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 1d2faa6592ae..f3a1c0e45021 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -344,13 +344,15 @@ typedef unsigned int __bitwise__ uif_t;
  * stuff here.
  */
 struct uart_info {
-	struct tty_struct	*tty;
+	struct tty_port		port;
 	struct circ_buf		xmit;
 	uif_t			flags;
 
 /*
  * Definitions for info->flags.  These are _private_ to serial_core, and
  * are specific to this structure.  They may be queried by low level drivers.
+ *
+ * FIXME: use the ASY_ definitions
  */
 #define UIF_CHECK_CD		((__force uif_t) (1 << 25))
 #define UIF_CTS_FLOW		((__force uif_t) (1 << 26))
@@ -358,11 +360,7 @@ struct uart_info {
 #define UIF_INITIALIZED		((__force uif_t) (1 << 31))
 #define UIF_SUSPENDED		((__force uif_t) (1 << 30))
 
-	int			blocked_open;
-
 	struct tasklet_struct	tlet;
-
-	wait_queue_head_t	open_wait;
 	wait_queue_head_t	delta_msr_wait;
 };
 
@@ -439,8 +437,8 @@ int uart_resume_port(struct uart_driver *reg, struct uart_port *port);
 #define uart_circ_chars_free(circ)	\
 	(CIRC_SPACE((circ)->head, (circ)->tail, UART_XMIT_SIZE))
 
-#define uart_tx_stopped(port)		\
-	((port)->info->tty->stopped || (port)->info->tty->hw_stopped)
+#define uart_tx_stopped(portp)		\
+	((portp)->info->port.tty->stopped || (portp)->info->port.tty->hw_stopped)
 
 /*
  * The following are helper functions for the low level drivers.
@@ -451,7 +449,7 @@ uart_handle_sysrq_char(struct uart_port *port, unsigned int ch)
 #ifdef SUPPORT_SYSRQ
 	if (port->sysrq) {
 		if (ch && time_before(jiffies, port->sysrq)) {
-			handle_sysrq(ch, port->info ? port->info->tty : NULL);
+			handle_sysrq(ch, port->info ? port->info->port.tty : NULL);
 			port->sysrq = 0;
 			return 1;
 		}
@@ -480,7 +478,7 @@ static inline int uart_handle_break(struct uart_port *port)
 	}
 #endif
 	if (port->flags & UPF_SAK)
-		do_SAK(info->tty);
+		do_SAK(info->port.tty);
 	return 0;
 }
 
@@ -503,9 +501,9 @@ uart_handle_dcd_change(struct uart_port *port, unsigned int status)
 
 	if (info->flags & UIF_CHECK_CD) {
 		if (status)
-			wake_up_interruptible(&info->open_wait);
-		else if (info->tty)
-			tty_hangup(info->tty);
+			wake_up_interruptible(&info->port.open_wait);
+		else if (info->port.tty)
+			tty_hangup(info->port.tty);
 	}
 }
 
@@ -518,7 +516,7 @@ static inline void
 uart_handle_cts_change(struct uart_port *port, unsigned int status)
 {
 	struct uart_info *info = port->info;
-	struct tty_struct *tty = info->tty;
+	struct tty_struct *tty = info->port.tty;
 
 	port->icount.cts++;
 
@@ -544,7 +542,7 @@ static inline void
 uart_insert_char(struct uart_port *port, unsigned int status,
 		 unsigned int overrun, unsigned int ch, unsigned int flag)
 {
-	struct tty_struct *tty = port->info->tty;
+	struct tty_struct *tty = port->info->port.tty;
 
 	if ((status & port->ignore_status_mask & ~overrun) == 0)
 		tty_insert_flip_char(tty, ch, flag);

commit 6bb0e3a59a089e23eecc0af3b6f6012b2a9affba
Author: Haavard Skinnemoen <haavard.skinnemoen@atmel.com>
Date:   Wed Jul 16 21:52:36 2008 +0100

    Subject: [PATCH 1/2] serial: Add flush_buffer() operation to uart_ops
    
    Serial drivers using DMA (like the atmel_serial driver) tend to get very
    confused when the xmit buffer is flushed and nobody told them.  They
    also tend to spew a lot of garbage since the DMA engine keeps running
    after the buffer is flushed and possibly refilled with unrelated data.
    
    This patch adds a new flush_buffer operation to the uart_ops struct,
    along with a call to it from uart_flush_buffer() right after the xmit
    buffer has been cleared. The driver can implement this in order to
    syncronize its internal DMA state with the xmit buffer when the buffer
    is flushed.
    
    Signed-off-by: Haavard Skinnemoen <haavard.skinnemoen@atmel.com>
    Acked-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index d8f31de632c5..1d2faa6592ae 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -190,6 +190,7 @@ struct uart_ops {
 	void		(*break_ctl)(struct uart_port *, int ctl);
 	int		(*startup)(struct uart_port *);
 	void		(*shutdown)(struct uart_port *);
+	void		(*flush_buffer)(struct uart_port *);
 	void		(*set_termios)(struct uart_port *, struct ktermios *new,
 				       struct ktermios *old);
 	void		(*set_ldisc)(struct uart_port *);

commit 64e9159f5d2c4edf5fa6425031e556f8fddaf7e6
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Tue Jun 3 15:18:54 2008 +0100

    serial_core: uart_set_ldisc infrastructure
    
    The tty layer provides a callback that is used when the line discipline
    is changed. Some hardware uses this to configure hardware specific
    features such as IrDA mode on serial ports. Unfortunately the serial
    layer does not provide this feature or pass it down to drivers.
    
    Blackfin used to hack around this by rewriting the tty ops, but those are
    now properly shared and const so the hack fails. Instead provide the
    proper operations.
    
    This change plus a follow up from the Blackfin guys is needed to avoid
    blackfin losing features in this release.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index d32123ae08ad..d8f31de632c5 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -192,6 +192,7 @@ struct uart_ops {
 	void		(*shutdown)(struct uart_port *);
 	void		(*set_termios)(struct uart_port *, struct ktermios *new,
 				       struct ktermios *old);
+	void		(*set_ldisc)(struct uart_port *);
 	void		(*pm)(struct uart_port *, unsigned int state,
 			      unsigned int oldstate);
 	int		(*set_wake)(struct uart_port *, unsigned int state);

commit 2f3517418dc0684a32318f2c5b53257416448b1e
Author: Bryan Wu <bryan.wu@analog.com>
Date:   Wed Apr 30 00:52:12 2008 -0700

    Blackfin serial driver: this driver enable SPORTs on Blackfin emulate UART
    
    Signed-off-by: Bryan Wu <bryan.wu@analog.com>
    Cc: Alan Cox <alan@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 7cb094a82456..d32123ae08ad 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -149,13 +149,15 @@
 /* Freescale ColdFire */
 #define PORT_MCF	78
 
-#define PORT_SC26XX	79
-
+/* Blackfin SPORT */
+#define PORT_BFIN_SPORT		79
 
 /* MN10300 on-chip UART numbers */
 #define PORT_MN10300		80
 #define PORT_MN10300_CTS	81
 
+#define PORT_SC26XX	82
+
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>

commit f2d937f3bf00665ccf048b3b6616ef95859b0945
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Thu Apr 17 20:05:37 2008 +0200

    consoles: polling support, kgdboc
    
    polled console handling support, to access a console in an irq-less
    way while in debug or irq context.
    
    absolutely zero impact as long as CONFIG_CONSOLE_POLL is disabled.
    (which is the default)
    
    [ jan.kiszka@siemens.com: lots of cleanups ]
    [ mingo@elte.hu: redesign, splitups, cleanups. ]
    
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Jan Kiszka <jan.kiszka@web.de>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 289942fc6655..7cb094a82456 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -213,6 +213,10 @@ struct uart_ops {
 	void		(*config_port)(struct uart_port *, int);
 	int		(*verify_port)(struct uart_port *, struct serial_struct *);
 	int		(*ioctl)(struct uart_port *, unsigned int, unsigned long);
+#ifdef CONFIG_CONSOLE_POLL
+	void	(*poll_put_char)(struct uart_port *, unsigned char);
+	int		(*poll_get_char)(struct uart_port *);
+#endif
 };
 
 #define UART_CONFIG_TYPE	(1 << 0)

commit 2695a14d315c014474ccadbaed40b0169b00cb5b
Author: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
Date:   Wed Feb 13 15:03:17 2008 -0800

    SC26XX: missing PORT define in serial_core.h
    
    When submitting the driver for inclusion to 2.6.25 I've missed the change to
    serial_core.h. This patch fixes this.
    
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 1a0b6cf83ff1..289942fc6655 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -149,6 +149,8 @@
 /* Freescale ColdFire */
 #define PORT_MCF	78
 
+#define PORT_SC26XX	79
+
 
 /* MN10300 on-chip UART numbers */
 #define PORT_MN10300		80

commit ef3d534754f31fed9c3b976fee1ece1b3bc38282
Author: David Howells <dhowells@redhat.com>
Date:   Fri Feb 8 04:19:30 2008 -0800

    mn10300: allocate serial port UART IDs for on-chip serial ports
    
    Allocate serial port UART type IDs for the MN10300 on-chip serial ports.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 9963f81fea9a..1a0b6cf83ff1 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -150,6 +150,10 @@
 #define PORT_MCF	78
 
 
+/* MN10300 on-chip UART numbers */
+#define PORT_MN10300		80
+#define PORT_MN10300_CTS	81
+
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>

commit 68576cf122bc5195c758ed295e78b5858472378a
Author: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
Date:   Wed Nov 28 16:21:44 2007 -0800

    IP22ZILOG: fix lockup and sysrq
    
     - fix lockup when switching from early console to real console
     - make sysrq reliable
     - fix panic, if sysrq is issued before console is opened
    
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 6a5203fb9cf1..9963f81fea9a 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -437,7 +437,7 @@ uart_handle_sysrq_char(struct uart_port *port, unsigned int ch)
 #ifdef SUPPORT_SYSRQ
 	if (port->sysrq) {
 		if (ch && time_before(jiffies, port->sysrq)) {
-			handle_sysrq(ch, port->info->tty);
+			handle_sysrq(ch, port->info ? port->info->tty : NULL);
 			port->sysrq = 0;
 			return 1;
 		}

commit f0c15f48bb4a68d5f74855720ae5efc56dec6a3b
Author: Greg Ungerer <gerg@snapgear.com>
Date:   Wed Oct 24 12:03:52 2007 +1000

    add port definition for mcf UART driver
    
    Add a port type definition for the Freescale UART driver ports (mcf.c).
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 4db77249281c..6a5203fb9cf1 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -146,6 +146,9 @@
 /* Broadcom SB1250, etc. SOC */
 #define PORT_SB1250_DUART	77
 
+/* Freescale ColdFire */
+#define PORT_MCF	78
+
 
 #ifdef __KERNEL__
 

commit b3b708fa2780cd2b5d8266a8f0c3a1cab364d4d2
Author: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
Date:   Tue Oct 16 01:24:02 2007 -0700

    wake up from a serial port
    
    Enable wakeup from serial ports, make it run-time configurable over sysfs,
    e.g.,
    
    echo enabled > /sys/devices/platform/serial8250.0/tty/ttyS0/power/wakeup
    
    Requires
    
    # CONFIG_SYSFS_DEPRECATED is not set
    
    Following suggestions from Alan and Russell moved the may_wake_up checks
    to serial_core.c. This time actually tested - it does even work. Could
    someone, please, verify, that put_device after device_find_child is
    correct?
    
    Also would be nice to test with a Natsemi UART, that can wake up the system,
    if such systems exist.
    
    For this you just have to apply the patch below, issue the above "echo"
    command to one of your Natsemi port, suspend and resume your system, and
    verify that your Natsemi port still works.  If you are actually capable of
    waking up the system from that port, would be nice to test that as well.
    
    Signed-off-by: Guennadi Liakhovetski <g.liakhovetski@gmx.de>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Greg KH <greg@kroah.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 09d17b06bf02..4db77249281c 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -291,7 +291,8 @@ struct uart_port {
 	resource_size_t		mapbase;		/* for ioremap */
 	struct device		*dev;			/* parent device */
 	unsigned char		hub6;			/* this should be in the 8250 driver */
-	unsigned char		unused[3];
+	unsigned char		suspended;
+	unsigned char		unused[2];
 	void			*private_data;		/* generic platform data pointer */
 };
 

commit 4f640efb3170dbcf99a37a3cc99060647b95428c
Author: Josh Boyer <jwboyer@linux.vnet.ibm.com>
Date:   Mon Jul 23 18:43:44 2007 -0700

    Use resource_size_t for serial port IO addresses
    
    At present, various parts of the serial code use unsigned long to define
    resource addresses.  This is a problem, because some 32-bit platforms have
    physical addresses larger than 32-bits, and have mmio serial uarts located
    above the 4GB point.
    
    This patch changes the type of mapbase in both struct uart_port and struct
    plat_serial8250_port to resource_size_t, which can be configured to be 64
    bits on such platforms.  The mapbase in serial_struct can't safely be
    changed, because that structure is user visible.
    
    Signed-off-by: David Gibson <dwg@au1.ibm.com>
    Signed-off-by: Josh Boyer <jwboyer@linux.vnet.ibm.com>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Jason Wessel <jason.wessel@windriver.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 773d8d8828ad..09d17b06bf02 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -288,7 +288,7 @@ struct uart_port {
 	const struct uart_ops	*ops;
 	unsigned int		custom_divisor;
 	unsigned int		line;			/* port index */
-	unsigned long		mapbase;		/* for ioremap */
+	resource_size_t		mapbase;		/* for ioremap */
 	struct device		*dev;			/* parent device */
 	unsigned char		hub6;			/* this should be in the 8250 driver */
 	unsigned char		unused[3];

commit 8b4a40809e5330c9da5d20107d693d92d73b31dc
Author: Maciej W. Rozycki <macro@orcam.me.uk>
Date:   Wed Jul 18 00:49:11 2007 -0700

    zs: move to the serial subsystem
    
    This is a reimplementation of the zs driver for the serial subsystem.  Any
    resemblance to the old driver is purely coincidential.  ;-) I do hope I got
    the handling of modem lines right -- better do not tackle me about the
    issue unless you feel too good...
    
    Any users of the old driver: please note the numbers of the serial lines
    have now been swapped, i.e.  ttyS0 <-> ttyS1 and ttyS2 <-> ttyS3.  It has
    to do with the modem lines mentioned above; basically the port A in a given
    chip has to be initialised before the port B if you want to use the latter
    as the serial console (which is usually the case), as operations on modem
    lines of the serial line associated with the port B access both ports (see
    the comment at the top of the driver for the details of wiring used).
    Please update your scripts.
    
    This is also the reason each SCC now requests an IRQ once only (as seen in
    "/proc/interrupts") -- the handler takes care of both ports at once as the
    line associated with the port B has to take status update interrupts from
    both ports (and yet the line of the port A takes its own for itself too).
    The old driver never got it right...
    
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 9c721cd2c9d6..773d8d8828ad 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -62,8 +62,9 @@
 /* NEC v850.  */
 #define PORT_V850E_UART	40
 
-/* DZ */
-#define PORT_DZ		47
+/* DEC */
+#define PORT_DZ		46
+#define PORT_ZS		47
 
 /* Parisc type numbers. */
 #define PORT_MUX	48

commit b45d52797432bd6b5d9786dbda940eb8d0b9ed06
Author: Maciej W. Rozycki <macro@orcam.me.uk>
Date:   Tue Jul 17 04:03:50 2007 -0700

    sb1250-duart.c: SB1250 DUART serial support
    
    This is a driver for the SB1250 DUART, a dual serial port implementation
    included in the Broadcom family of SOCs descending from the SiByte SB1250
    MIPS64 chip multiprocessor.  It is a new implementation replacing the
    old-fashioned driver currently present in the linux-mips.org tree.  It
    supports all the usual features one would expect from a(n asynchronous)
    serial driver, including modem line control (as far as hardware supports it
    -- there is edge detection logic missing from the DCD and RI lines and the
    driver does not implement polling of these lines at the moment), the serial
    console, BREAK transmission and reception, including the magic SysRq.  The
    receive FIFO threshold is not maintained though.
    
    The driver was tested with a SWARM board which uses a BCM1250 SOC (which is
    dual MIPS64 CMP) and has both ports of the single DUART implemented wired
    externally.  Both were tested.  Testing included using the ports as
    terminal lines at 1200bps (which is the ports minimum), 115200bps and a
    couple of random speeds inbetween.  The modem lines were verified to
    operate correctly.  No testing was performed with a use as a network
    interface, like with SLIP or PPP.
    
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 7f2c99d66e9d..9c721cd2c9d6 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -142,6 +142,9 @@
 /* Micrel KS8695 */
 #define PORT_KS8695	76
 
+/* Broadcom SB1250, etc. SOC */
+#define PORT_SB1250_DUART	77
+
 
 #ifdef __KERNEL__
 

commit b11115c15351faba978ce1b9e75068e77f6ef48d
Author: Maciej W. Rozycki <macro@orcam.me.uk>
Date:   Fri Jun 1 00:47:07 2007 -0700

    serial_core.h: include <linux/sysrq.h>
    
    The <linux/serial_core.h> header refers to handle_sysrq(), but does not
    include <linux/sysrq.h> which provides a declaration of the function.  This
    may result in an implicit declaration and a warning if the actual one is
    seen later on.
    
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index a3ac4c896831..7f2c99d66e9d 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -152,6 +152,7 @@
 #include <linux/sched.h>
 #include <linux/tty.h>
 #include <linux/mutex.h>
+#include <linux/sysrq.h>
 
 struct uart_port;
 struct uart_info;

commit 2c7ee6ab7cb7261aacea91d41da8df1874772f3f
Author: Andrew Victor <andrew@sanpeople.com>
Date:   Fri May 11 21:37:25 2007 +0100

    [ARM] 4332/2: KS8695: Serial driver
    
    A driver for the KS8695 internal UART.
    
    Based on the 2.6.9 driver from Micrel.
    
    Signed-off-by: Andrew Victor <andrew@sanpeople.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index aa2653a159f4..a3ac4c896831 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -139,6 +139,10 @@
 /* Blackfin bf5xx */
 #define PORT_BFIN	75
 
+/* Micrel KS8695 */
+#define PORT_KS8695	76
+
+
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>

commit 194de5612777a9ff4f96dae1932f77a5a89e5f0a
Author: Bryan Wu <bryan.wu@analog.com>
Date:   Sun May 6 14:50:30 2007 -0700

    blackfin: serial driver
    
    This patch implements the driver necessary use the Analog Devices Blackfin
    processor's Serial Port.
    
    Signed-off-by: Bryan Wu <bryan.wu@analog.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Russell King <rmk+lkml@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index aadbfd30763f..aa2653a159f4 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -136,6 +136,9 @@
 /* Xilinx uartlite */
 #define PORT_UARTLITE	74
 
+/* Blackfin bf5xx */
+#define PORT_BFIN	75
+
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>

commit abb4a2390737867353ebafc012d45f2b03f3f944
Author: David Gibson <david@gibson.dropbear.id.au>
Date:   Sun May 6 14:48:49 2007 -0700

    serial: define FIXED_PORT flag for serial_core
    
    At present, the serial core always allows setserial in userspace to change the
    port address, irq and base clock of any serial port.  That makes sense for
    legacy ISA ports, but not for (say) embedded ns16550 compatible serial ports
    at peculiar addresses.  In these cases, the kernel code configuring the ports
    must know exactly where they are, and their clocking arrangements (which can
    be unusual on embedded boards).  It doesn't make sense for userspace to change
    these settings.
    
    Therefore, this patch defines a UPF_FIXED_PORT flag for the uart_port
    structure.  If this flag is set when the serial port is configured, any
    attempts to alter the port's type, io address, irq or base clock with
    setserial are ignored.
    
    In addition this patch uses the new flag for on-chip serial ports probed in
    arch/powerpc/kernel/legacy_serial.c, and for other hard-wired serial ports
    probed by drivers/serial/of_serial.c.
    
    Signed-off-by: David Gibson <dwg@au1.ibm.com>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index d242c731491f..aadbfd30763f 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -263,6 +263,7 @@ struct uart_port {
 #define UPF_CONS_FLOW		((__force upf_t) (1 << 23))
 #define UPF_SHARE_IRQ		((__force upf_t) (1 << 24))
 #define UPF_BOOT_AUTOCONF	((__force upf_t) (1 << 28))
+#define UPF_FIXED_PORT		((__force upf_t) (1 << 29))
 #define UPF_DEAD		((__force upf_t) (1 << 30))
 #define UPF_IOREMAP		((__force upf_t) (1 << 31))
 

commit bd71c182d5a02337305fc381831c11029dd17d64
Author: Thomas Koeller <thomas.koeller@baslerweb.com>
Date:   Sun May 6 14:48:47 2007 -0700

    RM9000 serial driver
    
    Add support for the integrated serial ports of the MIPS RM9122 processor
    and its relatives.
    
    The patch also does some whitespace cleanup.
    
    [akpm@linux-foundation.org: cleanups]
    Signed-off-by: Thomas Koeller <thomas.koeller@baslerweb.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 8b5592e6aca4..d242c731491f 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -39,7 +39,8 @@
 #define PORT_RSA	13
 #define PORT_NS16550A	14
 #define PORT_XSCALE	15
-#define PORT_MAX_8250	15	/* max port ID */
+#define PORT_RM9000	16	/* PMC-Sierra RM9xxx internal UART */
+#define PORT_MAX_8250	16	/* max port ID */
 
 /*
  * ARM specific type numbers.  These are not currently guaranteed
@@ -231,6 +232,7 @@ struct uart_port {
 #define UPIO_AU			(4)			/* Au1x00 type IO */
 #define UPIO_TSI		(5)			/* Tsi108/109 type IO */
 #define UPIO_DWAPB		(6)			/* DesignWare APB UART */
+#define UPIO_RM9000		(7)			/* RM9000 type IO */
 
 	unsigned int		read_status_mask;	/* driver specific */
 	unsigned int		ignore_status_mask;	/* driver specific */

commit beab697ab4b2962e3d741b476abe443baad0933d
Author: Marc St-Jean <stjeanma@pmc-sierra.com>
Date:   Sun May 6 14:48:45 2007 -0700

    serial driver PMC MSP71xx
    
    Serial driver patch for the PMC-Sierra MSP71xx devices.
    
    There are three different fixes:
    
    1 Fix for DesignWare APB THRE errata: In brief, this is a non-standard
      16550 in that the THRE interrupt will not re-assert itself simply by
      disabling and re-enabling the THRI bit in the IER, it is only re-enabled
      if a character is actually sent out.
    
      It appears that the "8250-uart-backup-timer.patch" in the "mm" tree
      also fixes it so we have dropped our initial workaround.  This patch now
      needs to be applied on top of that "mm" patch.
    
    2 Fix for Busy Detect on LCR write: The DesignWare APB UART has a feature
      which causes a new Busy Detect interrupt to be generated if it's busy
      when the LCR is written.  This fix saves the value of the LCR and
      rewrites it after clearing the interrupt.
    
    3 Workaround for interrupt/data concurrency issue: The SoC needs to
      ensure that writes that can cause interrupts to be cleared reach the UART
      before returning from the ISR.  This fix reads a non-destructive register
      on the UART so the read transaction completion ensures the previously
      queued write transaction has also completed.
    
    Signed-off-by: Marc St-Jean <Marc_St-Jean@pmc-sierra.com>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 586aaba91720..8b5592e6aca4 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -230,6 +230,7 @@ struct uart_port {
 #define UPIO_MEM32		(3)
 #define UPIO_AU			(4)			/* Au1x00 type IO */
 #define UPIO_TSI		(5)			/* Tsi108/109 type IO */
+#define UPIO_DWAPB		(6)			/* DesignWare APB UART */
 
 	unsigned int		read_status_mask;	/* driver specific */
 	unsigned int		ignore_status_mask;	/* driver specific */
@@ -276,6 +277,7 @@ struct uart_port {
 	struct device		*dev;			/* parent device */
 	unsigned char		hub6;			/* this should be in the 8250 driver */
 	unsigned char		unused[3];
+	void			*private_data;		/* generic platform data pointer */
 };
 
 /*

commit e6fa0ba304f0642b5e9454c20b07740b8bf2c416
Author: Vitaly Wool <vitalywool@gmail.com>
Date:   Wed Feb 14 00:33:08 2007 -0800

    [PATCH] fix PNX8550 serial breakage
    
    Fix the serial header breakage for the PNX8550 MIPS platform.
    
    Signed-off-by: Vitaly Wool <vitalywool@gmail.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index cf23813cbec2..586aaba91720 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -122,7 +122,7 @@
 /*Digi jsm */
 #define PORT_JSM        69
 
-#define PORT_IP3106	70
+#define PORT_PNX8XXX	70
 
 /* Hilscher netx */
 #define PORT_NETX	71

commit 606d099cdd1080bbb50ea50dc52d98252f8f10a1
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Fri Dec 8 02:38:45 2006 -0800

    [PATCH] tty: switch to ktermios
    
    This is the grungy swap all the occurrences in the right places patch that
    goes with the updates.  At this point we have the same functionality as
    before (except that sgttyb() returns speeds not zero) and are ready to
    begin turning new stuff on providing nobody reports lots of bugs
    
    If you are a tty driver author converting an out of tree driver the only
    impact should be termios->ktermios name changes for the speed/property
    setting functions from your upper layers.
    
    If you are implementing your own TCGETS function before then your driver
    was broken already and its about to get a whole lot more painful for you so
    please fix it 8)
    
    Also fill in c_ispeed/ospeed on init for most devices, although the current
    code will do this for you anyway but I'd like eventually to lose that extra
    paranoia
    
    [akpm@osdl.org: bluetooth fix]
    [mp3@de.ibm.com: sclp fix]
    [mp3@de.ibm.com: warning fix for tty3270]
    [hugh@veritas.com: fix tty_ioctl powerpc build]
    [jdike@addtoit.com: uml: fix ->set_termios declaration]
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Martin Peschke <mp3@de.ibm.com>
    Acked-by: Peter Oberparleiter <oberpar@de.ibm.com>
    Cc: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Hugh Dickins <hugh@veritas.com>
    Signed-off-by: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 827672136646..cf23813cbec2 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -166,8 +166,8 @@ struct uart_ops {
 	void		(*break_ctl)(struct uart_port *, int ctl);
 	int		(*startup)(struct uart_port *);
 	void		(*shutdown)(struct uart_port *);
-	void		(*set_termios)(struct uart_port *, struct termios *new,
-				       struct termios *old);
+	void		(*set_termios)(struct uart_port *, struct ktermios *new,
+				       struct ktermios *old);
 	void		(*pm)(struct uart_port *, unsigned int state,
 			      unsigned int oldstate);
 	int		(*set_wake)(struct uart_port *, unsigned int state);
@@ -361,8 +361,8 @@ void uart_write_wakeup(struct uart_port *port);
  */
 void uart_update_timeout(struct uart_port *port, unsigned int cflag,
 			 unsigned int baud);
-unsigned int uart_get_baud_rate(struct uart_port *port, struct termios *termios,
-				struct termios *old, unsigned int min,
+unsigned int uart_get_baud_rate(struct uart_port *port, struct ktermios *termios,
+				struct ktermios *old, unsigned int min,
 				unsigned int max);
 unsigned int uart_get_divisor(struct uart_port *port, unsigned int baud);
 

commit 238b8721a554a33a451a3f13bdb5be8fe5cfc927
Author: Peter Korsgaard <jacmet@sunsite.dk>
Date:   Wed Dec 6 20:35:17 2006 -0800

    [PATCH] serial uartlite driver
    
    Add a driver for the Xilinx uartlite serial controller used in boards with
    the PPC405 core in the Xilinx V2P/V4 fpgas.
    
    The hardware is very simple (baudrate/start/stopbits fixed and no break
    support).  See the datasheet for details:
    
            http://www.xilinx.com/bvdocs/ipcenter/data_sheet/opb_uartlite.pdf
    
    See http://thread.gmane.org/gmane.linux.serial/1237/ for the email thread.
    
    Signed-off-by: Peter Korsgaard <jacmet@sunsite.dk>
    Acked-by: Olof Johansson <olof@lixom.net>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 463ab953b092..827672136646 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -132,6 +132,8 @@
 
 #define PORT_S3C2412	73
 
+/* Xilinx uartlite */
+#define PORT_UARTLITE	74
 
 #ifdef __KERNEL__
 

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index b661c19f3f72..463ab953b092 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -409,13 +409,12 @@ int uart_resume_port(struct uart_driver *reg, struct uart_port *port);
  * The following are helper functions for the low level drivers.
  */
 static inline int
-uart_handle_sysrq_char(struct uart_port *port, unsigned int ch,
-		       struct pt_regs *regs)
+uart_handle_sysrq_char(struct uart_port *port, unsigned int ch)
 {
 #ifdef SUPPORT_SYSRQ
 	if (port->sysrq) {
 		if (ch && time_before(jiffies, port->sysrq)) {
-			handle_sysrq(ch, regs, port->info->tty);
+			handle_sysrq(ch, port->info->tty);
 			port->sysrq = 0;
 			return 1;
 		}
@@ -425,7 +424,7 @@ uart_handle_sysrq_char(struct uart_port *port, unsigned int ch,
 	return 0;
 }
 #ifndef SUPPORT_SYSRQ
-#define uart_handle_sysrq_char(port,ch,regs) uart_handle_sysrq_char(port, 0, NULL)
+#define uart_handle_sysrq_char(port,ch) uart_handle_sysrq_char(port, 0)
 #endif
 
 /*

commit 9ab4f88b7ffdf338773e7755f923bc6b9e079834
Author: Haavard Skinnemoen <hskinnemoen@atmel.com>
Date:   Wed Oct 4 16:02:06 2006 +0200

    [PATCH] serial: Rename PORT_AT91 -> PORT_ATMEL
    
    The at91_serial driver can be used with both AT32 and AT91 devices
    from Atmel and has therefore been renamed atmel_serial. The only
    thing left is to rename PORT_AT91 PORT_ATMEL.
    
    Signed-off-by: Haavard Skinnemoen <hskinnemoen@atmel.com>
    Acked-by: Andrew Victor <andrew@sanpeople.com>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index de2e68159d96..b661c19f3f72 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -67,8 +67,8 @@
 /* Parisc type numbers. */
 #define PORT_MUX	48
 
-/* Atmel AT91xxx SoC */
-#define PORT_AT91	49
+/* Atmel AT91 / AT32 SoC */
+#define PORT_ATMEL	49
 
 /* Macintosh Zilog type numbers */
 #define PORT_MAC_ZILOG	50	/* m68k : not yet implemented */

commit d8d64d6b29d331f1217c77999f5104fe68b0ef3a
Author: Simon Tatham <anakin@pobox.com>
Date:   Mon Sep 25 16:51:28 2006 -0700

    [SERIAL] Magic SysRq SAK does nothing on serial consoles
    
    Make sysrq-K work on serial console by passing in the tty.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index f9fdf97506ea..de2e68159d96 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -415,7 +415,7 @@ uart_handle_sysrq_char(struct uart_port *port, unsigned int ch,
 #ifdef SUPPORT_SYSRQ
 	if (port->sysrq) {
 		if (ch && time_before(jiffies, port->sysrq)) {
-			handle_sysrq(ch, regs, NULL);
+			handle_sysrq(ch, regs, port->info->tty);
 			port->sysrq = 0;
 			return 1;
 		}

commit a6b93a908508810c5d51dd9b390283345af6f2d9
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun Oct 1 17:17:40 2006 +0100

    [SERIAL] Fix oops when removing suspended serial port
    
    A serial card might have been removed when the system is resumed.
    This results in a suspended port being shut down, which results in
    the ports shutdown method being called twice in a row.  This causes
    BUGs.  Avoid this by tracking the suspended state separately from
    the initialised state.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 86501a3de2ac..f9fdf97506ea 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -319,6 +319,7 @@ struct uart_info {
 #define UIF_CTS_FLOW		((__force uif_t) (1 << 26))
 #define UIF_NORMAL_ACTIVE	((__force uif_t) (1 << 29))
 #define UIF_INITIALIZED		((__force uif_t) (1 << 31))
+#define UIF_SUSPENDED		((__force uif_t) (1 << 30))
 
 	int			blocked_open;
 

commit 3be91ec7388bae3cf1bfb4febcee5ab6c65f409f
Author: Zang Roy-r61911 <tie-fei.zang@freescale.com>
Date:   Fri Jun 30 02:29:58 2006 -0700

    [SERIAL] 8250: add tsi108 serial support
    
    The following patch gets rid of CONFIG_TSI108_BRIDGE.  I add UPIO_TSI to
    handle IIR and IER register in serial_in and serial_out.
    
    (1) the reason to rewrite serial_in:
    
        TSI108 rev Z1 version ERRATA.  Reading the UART's Interrupt
        Identification Register (IIR) clears the Transmit Holding Register
        Empty (THRE) and Transmit buffer Empty (TEMP) interrupts even if they
        are not enabled in the Interrupt Enable Register (IER).  This leads to
        loss of the interrupts.  Interrupts are not cleared when reading UART
        registers as 32-bit word.
    
    (2) the reason to rewrite serial_out:
    
        Check for UART_IER_UUE bit in the autoconfig routine.  This section
        of autoconfig is excluded for Tsi108/109 because bits 7 and 6 are
        reserved for internal use.  They are R/W bits.  In addition to
        incorrect identification, changing these bits (from 00) will make
        Tsi108/109 UART non-functional.
    
    Signed-off-by: Roy Zang <tie-fei.zang@freescale.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 058cba70818a..86501a3de2ac 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -227,6 +227,7 @@ struct uart_port {
 #define UPIO_MEM		(2)
 #define UPIO_MEM32		(3)
 #define UPIO_AU			(4)			/* Au1x00 type IO */
+#define UPIO_TSI		(5)			/* Tsi108/109 type IO */
 
 	unsigned int		read_status_mask;	/* driver specific */
 	unsigned int		ignore_status_mask;	/* driver specific */

commit 075395d228641646159dae3dd170fa3fc6ff477a
Merge: 060ec6f2fb3c 61a116ef29e7
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Mon Jul 3 21:31:05 2006 -0700

    Merge branch 'devel' of master.kernel.org:/home/rmk/linux-2.6-serial
    
    * 'devel' of master.kernel.org:/home/rmk/linux-2.6-serial:
      [SERIAL] Ensure 8250_pci quirks are not marked __devinit
      [SERIAL] Convert fifosize to an unsigned int

commit 947deee8904b3c2edc7f59ab6e6242499e4dc434
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun Jul 2 20:45:51 2006 +0100

    [SERIAL] Convert fifosize to an unsigned int
    
    Some UARTs have more than 255 bytes of FIFO, which can't be
    represented by an unsigned char.  Change the kernel's internal
    structure to be an unsigned int, but still export an unsigned char
    via the TIOCGSERIAL ioctl.  If the TIOCSSERIAL ioctl provides a
    fifo size of 0, assume this means "don't change" otherwise we'll
    corrupt the larger fifo sizes.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index bd14858121ea..966e2e8a1740 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -214,10 +214,11 @@ struct uart_port {
 	unsigned char __iomem	*membase;		/* read/write[bwl] */
 	unsigned int		irq;			/* irq number */
 	unsigned int		uartclk;		/* base uart clock */
-	unsigned char		fifosize;		/* tx fifo size */
+	unsigned int		fifosize;		/* tx fifo size */
 	unsigned char		x_char;			/* xon/xoff char */
 	unsigned char		regshift;		/* reg offset shift */
 	unsigned char		iotype;			/* io access style */
+	unsigned char		unused1;
 
 #define UPIO_PORT		(0)
 #define UPIO_HUB6		(1)

commit aa4148cfc7b3b93eeaf755a7d14f10afaffe9a96
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 20 21:15:16 2005 -0700

    [PATCH] devfs: Remove devfs support from the serial subsystem
    
    Also fixes all serial drivers.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 951c4e858274..fc1104a2cfa9 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -336,7 +336,6 @@ struct uart_driver {
 	struct module		*owner;
 	const char		*driver_name;
 	const char		*dev_name;
-	const char		*devfs_name;
 	int			 major;
 	int			 minor;
 	int			 nr;

commit 73e55cb3b3549d0174d1dadb755200938232e8d0
Author: Ben Dooks <ben-linux@fluff.org>
Date:   Sat Jun 24 21:21:32 2006 +0100

    [ARM] 3639/1: S3C2412: serial port support
    
    Patch from Ben Dooks
    
    Serial port support for the on-board UART blocks
    on the Samsung S3C2412 and S3C2413 UARTs.
    
    Signed-off-by: Ben Dooks <ben-linux@fluff.org>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 0ef50baa7da6..951c4e858274 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -130,6 +130,9 @@
 /* SUN4V Hypervisor Console */
 #define PORT_SUNHV	72
 
+#define PORT_S3C2412	73
+
+
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>

commit 050335db2a777ffaa859d77beb05fffe9e8c5ae9
Merge: a4cfae13cef6 905f14672e6d
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Tue Jun 20 17:52:36 2006 -0700

    Merge branch 'devel' of master.kernel.org:/home/rmk/linux-2.6-arm
    
    * 'devel' of master.kernel.org:/home/rmk/linux-2.6-arm: (42 commits)
      [ARM] Fix tosa build error
      [ARM] 3610/1: Make reboot work on Versatile
      [ARM] 3609/1: S3C24XX: defconfig update for s3c2410_defconfig
      [ARM] 3591/1: Anubis: IDE device definitions
      [ARM] Include asm/hardware.h not asm/arch/hardware.h
      [ARM] 3594/1: Poodle: Add touchscreen support + other updates
      [ARM] 3564/1: sharpsl_pm: Abstract some machine specific parameters
      [ARM] 3561/1: Poodle: Correct the MMC/SD power control
      [ARM] 3593/1: Add reboot and shutdown handlers for Zaurus handhelds
      [ARM] 3599/1: AT91RM9200 remove global variables
      [ARM] 3607/1: AT91RM9200 misc fixes
      [ARM] 3605/1: AT91RM9200 Power Management
      [ARM] 3604/1: AT91RM9200 New boards
      [ARM] 3603/1: AT91RM9200 remove old files
      [ARM] 3592/1: AT91RM9200 Serial driver update
      [ARM] 3590/1: AT91RM9200 Platform devices support
      [ARM] 3589/1: AT91RM9200 DK/EK board update
      [ARM] 3588/1: AT91RM9200 CSB337/637 board update
      [ARM] 3587/1: AT91RM9200 hardware headers
      [ARM] 3586/1: AT91RM9200 header update
      ...

commit afefc4158f3c8529e4bb99c1dc119fd792bac220
Author: Andrew Victor <andrew@sanpeople.com>
Date:   Mon Jun 19 19:53:19 2006 +0100

    [ARM] 3592/1: AT91RM9200 Serial driver update
    
    Patch from Andrew Victor
    
    This patch includes a number of updates to the AT91RM9200 serial driver.
    
    Changes include:
    1. Conversion to a platform_driver.  [Ivan Kokshaysky]
    2. Replaced all references to AT91RM9200 with AT91.  This driver can now
    also be used for the AT91SAM9216.
    3. Allow TIOCM_LOOP to configure local loopback mode.
    4. Cleaned up the 'read_status_mask' usage and interrupt handler code.
    [Chip Coldwell]
    5. Suspend/resume support.  [David Brownell]
    
    There are a few 'unused variable' warning when compiling this - I
    removed the new DMA support to keep this first patch simpler.
    
    Signed-off-by: Andrew Victor <andrew@sanpeople.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index bd14858121ea..56c2a1db4a90 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -67,8 +67,8 @@
 /* Parisc type numbers. */
 #define PORT_MUX	48
 
-/* Atmel AT91RM9200 SoC */
-#define PORT_AT91RM9200 49
+/* Atmel AT91xxx SoC */
+#define PORT_AT91	49
 
 /* Macintosh Zilog type numbers */
 #define PORT_MAC_ZILOG	50	/* m68k : not yet implemented */

commit 66643de455c27973ac31ad6de9f859d399916842
Merge: 2c23d62abb82 387e2b043902
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed May 24 09:22:21 2006 +0100

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6
    
    Conflicts:
    
            include/asm-powerpc/unistd.h
            include/asm-sparc/unistd.h
            include/asm-sparc64/unistd.h
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

commit 68ac64cd3fd89fdaa091701f6ab98a9065e9b1b5
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sun Apr 30 11:13:50 2006 +0100

    [SERIAL] Clean up serial locking when obtaining a reference to a port
    
    The locking for the uart_port is over complicated, and can be
    simplified if we introduce a flag to indicate that a port is "dead"
    and will be removed.
    
    This also helps the validator because it removes a case of non-nested
    unlock ordering.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index c32e60e79dea..bd14858121ea 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -254,6 +254,7 @@ struct uart_port {
 #define UPF_CONS_FLOW		((__force upf_t) (1 << 23))
 #define UPF_SHARE_IRQ		((__force upf_t) (1 << 24))
 #define UPF_BOOT_AUTOCONF	((__force upf_t) (1 << 28))
+#define UPF_DEAD		((__force upf_t) (1 << 30))
 #define UPF_IOREMAP		((__force upf_t) (1 << 31))
 
 #define UPF_CHANGE_MASK		((__force upf_t) (0x17fff))

commit 62c4f0a2d5a188f73a94f2cb8ea0dba3e7cf0a7f
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Apr 26 12:56:16 2006 +0100

    Don't include linux/config.h from anywhere else in include/
    
    Signed-off-by: David Woodhouse <dwmw2@infradead.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index c32e60e79dea..fcfb783bef41 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -132,7 +132,6 @@
 
 #ifdef __KERNEL__
 
-#include <linux/config.h>
 #include <linux/compiler.h>
 #include <linux/interrupt.h>
 #include <linux/circ_buf.h>

commit 9d8f057acbd38d8177cf2ffd5e151d52c2477372
Merge: 591eb85ecd7e 91bca4b3e2f1
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Wed Mar 22 17:33:12 2006 -0800

    Merge master.kernel.org:/home/rmk/linux-2.6-serial
    
    * master.kernel.org:/home/rmk/linux-2.6-serial:
      [SERIAL] Merge avlab serial board entries in parport_serial
      [SERIAL] kernel console should send CRLF not LFCR

commit d358788f3f30113e49882187d794832905e42592
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Mar 20 20:00:09 2006 +0000

    [SERIAL] kernel console should send CRLF not LFCR
    
    Glen Turner reported that writing LFCR rather than the more
    traditional CRLF causes issues with some terminals.
    
    Since this aflicts many serial drivers, extract the common code
    to a library function (uart_console_write) and arrange for each
    driver to supply a "putchar" function.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 4041122dabfc..f7434e5086f5 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -366,6 +366,9 @@ void uart_parse_options(char *options, int *baud, int *parity, int *bits,
 int uart_set_options(struct uart_port *port, struct console *co, int baud,
 		     int parity, int bits, int flow);
 struct tty_driver *uart_console_device(struct console *co, int *index);
+void uart_console_write(struct uart_port *port, const char *s,
+			unsigned int count,
+			void (*putchar)(struct uart_port *, int));
 
 /*
  * Port/driver registration/removal

commit 02fd473bd4844befc74f7ca67cd60891e0a2d890
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Sat Feb 11 02:25:21 2006 -0800

    [SPARC64]: Add SUN4V Hypervisor Console driver.
    
    Since it can do things like BREAK and HUP, we implement
    this as a serial uart driver.
    
    This still needs interrupt probing code, as I haven't figured
    out how interrupts will work or be probed for on SUN4V yet.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 4041122dabfc..57abcea1cb5d 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -127,6 +127,9 @@
 /* Hilscher netx */
 #define PORT_NETX	71
 
+/* SUN4V Hypervisor Console */
+#define PORT_SUNHV	72
+
 #ifdef __KERNEL__
 
 #include <linux/config.h>

commit 0077d45e46fe2af3aaee5813c99268afcd0e7c0e
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Jan 21 23:03:28 2006 +0000

    [SERIAL] Make uart_port flags a bitwise type
    
    Same reasoning as commit 747c8a55946ed037bf7d62454c3c599c02af2262
    but this time we're making uart_port flags a bitwise type - not
    all of these flags correspond with the old ASYNC_ flags, so there
    is the possibility for bugs if the wrong ASYNC_* constants are
    used.  Always use UPF_* constants for uart_port->flags.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 1a8cd0169c9a..4041122dabfc 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -203,6 +203,8 @@ struct uart_icount {
 	__u32	buf_overrun;
 };
 
+typedef unsigned int __bitwise__ upf_t;
+
 struct uart_port {
 	spinlock_t		lock;			/* port lock */
 	unsigned int		iobase;			/* in/out[bwl] */
@@ -230,29 +232,29 @@ struct uart_port {
 	unsigned long		sysrq;			/* sysrq timeout */
 #endif
 
-	unsigned int		flags;
-
-#define UPF_FOURPORT		(1 << 1)
-#define UPF_SAK			(1 << 2)
-#define UPF_SPD_MASK		(0x1030)
-#define UPF_SPD_HI		(0x0010)
-#define UPF_SPD_VHI		(0x0020)
-#define UPF_SPD_CUST		(0x0030)
-#define UPF_SPD_SHI		(0x1000)
-#define UPF_SPD_WARP		(0x1010)
-#define UPF_SKIP_TEST		(1 << 6)
-#define UPF_AUTO_IRQ		(1 << 7)
-#define UPF_HARDPPS_CD		(1 << 11)
-#define UPF_LOW_LATENCY		(1 << 13)
-#define UPF_BUGGY_UART		(1 << 14)
-#define UPF_MAGIC_MULTIPLIER	(1 << 16)
-#define UPF_CONS_FLOW		(1 << 23)
-#define UPF_SHARE_IRQ		(1 << 24)
-#define UPF_BOOT_AUTOCONF	(1 << 28)
-#define UPF_IOREMAP		(1 << 31)
-
-#define UPF_CHANGE_MASK		(0x17fff)
-#define UPF_USR_MASK		(UPF_SPD_MASK|UPF_LOW_LATENCY)
+	upf_t			flags;
+
+#define UPF_FOURPORT		((__force upf_t) (1 << 1))
+#define UPF_SAK			((__force upf_t) (1 << 2))
+#define UPF_SPD_MASK		((__force upf_t) (0x1030))
+#define UPF_SPD_HI		((__force upf_t) (0x0010))
+#define UPF_SPD_VHI		((__force upf_t) (0x0020))
+#define UPF_SPD_CUST		((__force upf_t) (0x0030))
+#define UPF_SPD_SHI		((__force upf_t) (0x1000))
+#define UPF_SPD_WARP		((__force upf_t) (0x1010))
+#define UPF_SKIP_TEST		((__force upf_t) (1 << 6))
+#define UPF_AUTO_IRQ		((__force upf_t) (1 << 7))
+#define UPF_HARDPPS_CD		((__force upf_t) (1 << 11))
+#define UPF_LOW_LATENCY		((__force upf_t) (1 << 13))
+#define UPF_BUGGY_UART		((__force upf_t) (1 << 14))
+#define UPF_MAGIC_MULTIPLIER	((__force upf_t) (1 << 16))
+#define UPF_CONS_FLOW		((__force upf_t) (1 << 23))
+#define UPF_SHARE_IRQ		((__force upf_t) (1 << 24))
+#define UPF_BOOT_AUTOCONF	((__force upf_t) (1 << 28))
+#define UPF_IOREMAP		((__force upf_t) (1 << 31))
+
+#define UPF_CHANGE_MASK		((__force upf_t) (0x17fff))
+#define UPF_USR_MASK		((__force upf_t) (UPF_SPD_MASK|UPF_LOW_LATENCY))
 
 	unsigned int		mctrl;			/* current modem ctrl settings */
 	unsigned int		timeout;		/* character-based timeout */

commit 27ae7a7435634820e7f7e2b922d8119f79cfc6e4
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Jan 21 22:54:06 2006 +0000

    [SERIAL] Fix UPF_ flag usage with uart_info->flags
    
    The previous change found a bug in the serial SAK handling - because
    we were looking for UPF_SAK set in uart_info->flags, we would never
    raise a SAK condition.  UPF_SAK is in uart_port->flags.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 90f681789a64..1a8cd0169c9a 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -430,7 +430,7 @@ static inline int uart_handle_break(struct uart_port *port)
 		port->sysrq = 0;
 	}
 #endif
-	if (info->flags & UPF_SAK)
+	if (port->flags & UPF_SAK)
 		do_SAK(info->tty);
 	return 0;
 }

commit 747c8a55946ed037bf7d62454c3c599c02af2262
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Jan 21 22:50:36 2006 +0000

    [SERIAL] Make uart_info flags a bitwise type
    
    The potential for confusing the flags is fairly high.  Make
    uart_info's flags a bitwise type so sparse can check that the
    right flag definitions are used with the right structure.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index b74ff34469b9..90f681789a64 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -287,6 +287,9 @@ struct uart_state {
 };
 
 #define UART_XMIT_SIZE	PAGE_SIZE
+
+typedef unsigned int __bitwise__ uif_t;
+
 /*
  * This is the state information which is only valid when the port
  * is open; it may be freed by the core driver once the device has
@@ -296,17 +299,16 @@ struct uart_state {
 struct uart_info {
 	struct tty_struct	*tty;
 	struct circ_buf		xmit;
-	unsigned int		flags;
+	uif_t			flags;
 
 /*
- * These are the flags that specific to info->flags, and reflect our
- * internal state.  They can not be accessed via port->flags.  Low
- * level drivers must not change these, but may query them instead.
+ * Definitions for info->flags.  These are _private_ to serial_core, and
+ * are specific to this structure.  They may be queried by low level drivers.
  */
-#define UIF_CHECK_CD		(1 << 25)
-#define UIF_CTS_FLOW		(1 << 26)
-#define UIF_NORMAL_ACTIVE	(1 << 29)
-#define UIF_INITIALIZED		(1 << 31)
+#define UIF_CHECK_CD		((__force uif_t) (1 << 25))
+#define UIF_CTS_FLOW		((__force uif_t) (1 << 26))
+#define UIF_NORMAL_ACTIVE	((__force uif_t) (1 << 29))
+#define UIF_INITIALIZED		((__force uif_t) (1 << 31))
 
 	int			blocked_open;
 

commit ba899dbc036d24ab6b45faf64e3648a268721cc9
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Jan 21 22:45:50 2006 +0000

    [SERIAL] Make port->ops constant
    
    No one should write to the port->ops structure, so make it constant.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index f3af47713a4e..b74ff34469b9 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -257,7 +257,7 @@ struct uart_port {
 	unsigned int		mctrl;			/* current modem ctrl settings */
 	unsigned int		timeout;		/* character-based timeout */
 	unsigned int		type;			/* port type */
-	struct uart_ops		*ops;
+	const struct uart_ops	*ops;
 	unsigned int		custom_divisor;
 	unsigned int		line;			/* port index */
 	unsigned long		mapbase;		/* for ioremap */

commit ca740803856f23dbc5b1872039291231bc131ecb
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Jan 21 20:06:14 2006 +0000

    [SERIAL] Remove UPF_AUTOPROBE and UPF_BOOT_ONLYMCA
    
    The functionality UPF_BOOT_ONLYMCA provided has been replaced by
    the 8250_mca module, which only registers MCA ports if MCA is
    present.
    
    UPF_AUTOPROBE has no functional effect - in fact, it's never
    tested.  Only ibmasm set the flag.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index ec351005bf9d..f3af47713a4e 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -245,9 +245,7 @@ struct uart_port {
 #define UPF_HARDPPS_CD		(1 << 11)
 #define UPF_LOW_LATENCY		(1 << 13)
 #define UPF_BUGGY_UART		(1 << 14)
-#define UPF_AUTOPROBE		(1 << 15)
 #define UPF_MAGIC_MULTIPLIER	(1 << 16)
-#define UPF_BOOT_ONLYMCA	(1 << 22)
 #define UPF_CONS_FLOW		(1 << 23)
 #define UPF_SHARE_IRQ		(1 << 24)
 #define UPF_BOOT_AUTOCONF	(1 << 28)

commit e2862f6a833ea26591c7feb755dc2e46909182a6
Author: Ingo Molnar <mingo@elte.hu>
Date:   Fri Jan 13 21:37:07 2006 +0000

    [SERIAL] convert uart_state.sem to uart_state.mutex
    
    semaphore to mutex conversion.
    
    the conversion was generated via scripts, and the result was validated
    automatically via a script as well.
    
    build and boot tested.
    
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index a8187c3c8a7b..ec351005bf9d 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -136,6 +136,7 @@
 #include <linux/spinlock.h>
 #include <linux/sched.h>
 #include <linux/tty.h>
+#include <linux/mutex.h>
 
 struct uart_port;
 struct uart_info;
@@ -284,7 +285,7 @@ struct uart_state {
 	struct uart_info	*info;
 	struct uart_port	*port;
 
-	struct semaphore	sem;
+	struct mutex		mutex;
 };
 
 #define UART_XMIT_SIZE	PAGE_SIZE

commit 1e6c9c2878c9c1f301449c78551e0b7c5f3e3ae5
Author: Andrew Victor <andrew@sanpeople.com>
Date:   Tue Jan 10 16:59:27 2006 +0000

    [ARM] 3242/2: AT91RM9200 support for 2.6 (Serial)
    
    Patch from Andrew Victor
    
    This patch adds support to the 2.6 kernel series for the Atmel
    AT91RM9200 processor.
    
    This patch is the Serial driver.
    
    This version uses the newly re-written GPL'ed hardware headers.
    
    Signed-off-by: Andrew Victor <andrew@sanpeople.com>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index e3710d7e260a..a8187c3c8a7b 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -67,6 +67,9 @@
 /* Parisc type numbers. */
 #define PORT_MUX	48
 
+/* Atmel AT91RM9200 SoC */
+#define PORT_AT91RM9200 49
+
 /* Macintosh Zilog type numbers */
 #define PORT_MAC_ZILOG	50	/* m68k : not yet implemented */
 #define PORT_PMAC_ZILOG	51

commit f5417612d787e6b619fd69616bbf95f1b895e900
Author: Sascha Hauer <sascha@saschahauer.de>
Date:   Mon Nov 28 18:09:44 2005 +0000

    [ARM] 3181/1: add PORT_ identifier for Hilscher netx uart
    
    Patch from Sascha Hauer
    
    This patch adds PORT_NETX for supporting the Hilscher netx embedded
    UARTs.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index a3ac92b19aca..e3710d7e260a 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -121,6 +121,9 @@
 
 #define PORT_IP3106	70
 
+/* Hilscher netx */
+#define PORT_NETX	71
+
 #ifdef __KERNEL__
 
 #include <linux/config.h>

commit 21c614a7899046ab108b3d327d76c33443a8ebf2
Author: Pantelis Antoniou <pantelis.antoniou@gmail.com>
Date:   Sun Nov 6 09:07:03 2005 +0000

    [SERIAL] Support Au1x00 8250 UARTs using the generic 8250 driver.
    
    The offsets of the registers are in a different place, and
    some parts cannot handle a full set of modem control signals.
    
    Signed-off-by: Pantelis Antoniou <pantelis@embeddedalley.ocm>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 9d2579230689..a3ac92b19aca 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -211,6 +211,7 @@ struct uart_port {
 #define UPIO_HUB6		(1)
 #define UPIO_MEM		(2)
 #define UPIO_MEM32		(3)
+#define UPIO_AU			(4)			/* Au1x00 type IO */
 
 	unsigned int		read_status_mask;	/* driver specific */
 	unsigned int		ignore_status_mask;	/* driver specific */

commit 913ade51eca369553a8ffbdaf1f426fade84f6ae
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Oct 31 13:53:26 2005 +0000

    [SERIAL] Fix port numbering
    
    The PORT_* macros must be uniquely numbered.  This fixes the
    definitions.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 2b0401b93f2b..9d2579230689 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -39,8 +39,7 @@
 #define PORT_RSA	13
 #define PORT_NS16550A	14
 #define PORT_XSCALE	15
-#define PORT_IP3106	16
-#define PORT_MAX_8250	16	/* max port ID */
+#define PORT_MAX_8250	15	/* max port ID */
 
 /*
  * ARM specific type numbers.  These are not currently guaranteed
@@ -118,7 +117,9 @@
 #define PORT_M32R_SIO	68
 
 /*Digi jsm */
-#define PORT_JSM        65
+#define PORT_JSM        69
+
+#define PORT_IP3106	70
 
 #ifdef __KERNEL__
 

commit bdf21b18b4abf983db38f04ef7fec88f47389867
Author: Pete Popov <ppopov@embeddedalley.com>
Date:   Thu Jul 14 17:47:57 2005 +0000

    Philips PNX8550 support: MIPS32-like core with 2 Trimedias on it.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 27db8da43aa4..2b0401b93f2b 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -39,7 +39,8 @@
 #define PORT_RSA	13
 #define PORT_NS16550A	14
 #define PORT_XSCALE	15
-#define PORT_MAX_8250	15	/* max port ID */
+#define PORT_IP3106	16
+#define PORT_MAX_8250	16	/* max port ID */
 
 /*
  * ARM specific type numbers.  These are not currently guaranteed

commit 4e1491847ef5ca1c5a661601d5f96dcb7d90d2f0
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Thu Sep 8 14:47:12 2005 -0700

    Fix up ARM serial driver compile failure
    
    Proud member of Uglyhacks'R'US.
    
    Acked-by: David S. Miller <davem@davemloft.net>
    Acked-by: Russell King <rmk+lkml@arm.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 9b12fe731612..27db8da43aa4 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -401,6 +401,9 @@ uart_handle_sysrq_char(struct uart_port *port, unsigned int ch,
 #endif
 	return 0;
 }
+#ifndef SUPPORT_SYSRQ
+#define uart_handle_sysrq_char(port,ch,regs) uart_handle_sysrq_char(port, 0, NULL)
+#endif
 
 /*
  * We do the SysRQ and SAK checking like this...

commit 93c37f292110a37dd77e4cc0aaf1c341d79bf6aa
Author: David S. Miller <davem@sunset.davemloft.net>
Date:   Tue Sep 6 13:57:08 2005 -0700

    [SERIAL]: Avoid 'statement with no effect' warnings.
    
    When SUPPORT_SYSRQ is false, gcc can emit warnings for
    the uart_handle_sysrq_char() that results.  Using an
    empty inline returning zero kills the warning.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index cf0f64ea2bc0..9b12fe731612 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -385,11 +385,11 @@ int uart_resume_port(struct uart_driver *reg, struct uart_port *port);
 /*
  * The following are helper functions for the low level drivers.
  */
-#ifdef SUPPORT_SYSRQ
 static inline int
 uart_handle_sysrq_char(struct uart_port *port, unsigned int ch,
 		       struct pt_regs *regs)
 {
+#ifdef SUPPORT_SYSRQ
 	if (port->sysrq) {
 		if (ch && time_before(jiffies, port->sysrq)) {
 			handle_sysrq(ch, regs, NULL);
@@ -398,11 +398,9 @@ uart_handle_sysrq_char(struct uart_port *port, unsigned int ch,
 		}
 		port->sysrq = 0;
 	}
+#endif
 	return 0;
 }
-#else
-#define uart_handle_sysrq_char(port,ch,regs)	(0)
-#endif
 
 /*
  * We do the SysRQ and SAK checking like this...

commit 0f302dc35412dc67035efc188b9d5c40711b4222
Author: Sascha Hauer <sascha@saschahauer.de>
Date:   Wed Aug 31 21:48:47 2005 +0100

    [ARM] 2866/1: add i.MX set_mctrl / get_mctrl functions
    
    Patch from Sascha Hauer
    
    This patch adds support for setting and getting RTS / CTS via
    set_mtctrl / get_mctrl functions.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 1c53302db041..cf0f64ea2bc0 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -360,8 +360,6 @@ struct tty_driver *uart_console_device(struct console *co, int *index);
  */
 int uart_register_driver(struct uart_driver *uart);
 void uart_unregister_driver(struct uart_driver *uart);
-void __deprecated uart_unregister_port(struct uart_driver *reg, int line);
-int __deprecated uart_register_port(struct uart_driver *reg, struct uart_port *port);
 int uart_add_one_port(struct uart_driver *reg, struct uart_port *port);
 int uart_remove_one_port(struct uart_driver *reg, struct uart_port *port);
 int uart_match_port(struct uart_port *port1, struct uart_port *port2);

commit b129a8ccd53f74c43e4c83c8e0031a4990040830
Merge: 6b39374a27eb 194d0710e1a7
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Wed Aug 31 10:12:14 2005 +0100

    [SERIAL] Clean up and fix tty transmission start/stoping
    
    The start_tx and stop_tx methods were passed a flag to indicate
    whether the start/stop was from the tty start/stop callbacks, and
    some drivers used this flag to decide whether to ask the UART to
    immediately stop transmission (where the UART supports such a
    feature.)
    
    There are other cases when we wish this to occur - when CTS is
    lowered, or if we change from soft to hard flow control and CTS
    is inactive.  In these cases, this flag was false, and we would
    allow the transmitter to drain before stopping.
    
    There is really only one case where we want to let the transmitter
    drain before disabling, and that's when we run out of characters
    to send.
    
    Hence, re-jig the start_tx and stop_tx methods to eliminate this
    flag, and introduce new functions for the special "disable and
    allow transmitter to drain" case.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

commit e5c2d749172657ed51e20e4b5ab540447666cc50
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Jul 27 11:45:19 2005 -0700

    [PATCH] serial_core whitespace fix
    
    Use tabs for formatting like anywhere else in this file.
    
    Cc: Russell King <rmk@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 30b64f3534f4..f6fca8f2f3ca 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -104,7 +104,7 @@
 #define PORT_MPSC	63
 
 /* TXX9 type number */
-#define PORT_TXX9       64
+#define PORT_TXX9	64
 
 /* NEC VR4100 series SIU/DSIU */
 #define PORT_VR41XX_SIU		65

commit 661f83a67c2e360d5a4d2406cc28379c909f94bf
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Jul 16 09:30:53 2005 +0100

    [PATCH] Serial: Move deprecation of register_serial forward to September
    
    I think it's about time to make the build a little more vocal about the
    expiry of these functions.  Due to recent discussions with problems in
    the console initialisation vs power manglement, I'd like to move the
    date forward to September.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index d6025af7efac..30b64f3534f4 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -122,6 +122,7 @@
 #ifdef __KERNEL__
 
 #include <linux/config.h>
+#include <linux/compiler.h>
 #include <linux/interrupt.h>
 #include <linux/circ_buf.h>
 #include <linux/spinlock.h>
@@ -359,8 +360,8 @@ struct tty_driver *uart_console_device(struct console *co, int *index);
  */
 int uart_register_driver(struct uart_driver *uart);
 void uart_unregister_driver(struct uart_driver *uart);
-void uart_unregister_port(struct uart_driver *reg, int line);
-int uart_register_port(struct uart_driver *reg, struct uart_port *port);
+void __deprecated uart_unregister_port(struct uart_driver *reg, int line);
+int __deprecated uart_register_port(struct uart_driver *reg, struct uart_port *port);
 int uart_add_one_port(struct uart_driver *reg, struct uart_port *port);
 int uart_remove_one_port(struct uart_driver *reg, struct uart_port *port);
 int uart_match_port(struct uart_port *port1, struct uart_port *port2);

commit 05ab3014636ff60a319d37cdf37dca594b015eec
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon May 9 23:21:59 2005 +0100

    [PATCH] Serial: Add uart_insert_char()
    
    Add uart_insert_char(), which handles inserting characters into the
    flip buffer.  This helper function handles the correct semantics
    for handling overrun in addition to inserting normal characters.
    
    Signed-off-by: Russell King <rmk@arm.linux.org.uk>

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index c3fb5984f250..d6025af7efac 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -479,6 +479,25 @@ uart_handle_cts_change(struct uart_port *port, unsigned int status)
 	}
 }
 
+#include <linux/tty_flip.h>
+
+static inline void
+uart_insert_char(struct uart_port *port, unsigned int status,
+		 unsigned int overrun, unsigned int ch, unsigned int flag)
+{
+	struct tty_struct *tty = port->info->tty;
+
+	if ((status & port->ignore_status_mask & ~overrun) == 0)
+		tty_insert_flip_char(tty, ch, flag);
+
+	/*
+	 * Overrun is special.  Since it's reported immediately,
+	 * it doesn't affect the current character.
+	 */
+	if (status & ~port->ignore_status_mask & overrun)
+		tty_insert_flip_char(tty, 0, TTY_OVERRUN);
+}
+
 /*
  *	UART_ENABLE_MS - determine if port should enable modem status irqs
  */

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
new file mode 100644
index 000000000000..c3fb5984f250
--- /dev/null
+++ b/include/linux/serial_core.h
@@ -0,0 +1,491 @@
+/*
+ *  linux/drivers/char/serial_core.h
+ *
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef LINUX_SERIAL_CORE_H
+#define LINUX_SERIAL_CORE_H
+
+/*
+ * The type definitions.  These are from Ted Ts'o's serial.h
+ */
+#define PORT_UNKNOWN	0
+#define PORT_8250	1
+#define PORT_16450	2
+#define PORT_16550	3
+#define PORT_16550A	4
+#define PORT_CIRRUS	5
+#define PORT_16650	6
+#define PORT_16650V2	7
+#define PORT_16750	8
+#define PORT_STARTECH	9
+#define PORT_16C950	10
+#define PORT_16654	11
+#define PORT_16850	12
+#define PORT_RSA	13
+#define PORT_NS16550A	14
+#define PORT_XSCALE	15
+#define PORT_MAX_8250	15	/* max port ID */
+
+/*
+ * ARM specific type numbers.  These are not currently guaranteed
+ * to be implemented, and will change in the future.  These are
+ * separate so any additions to the old serial.c that occur before
+ * we are merged can be easily merged here.
+ */
+#define PORT_PXA	31
+#define PORT_AMBA	32
+#define PORT_CLPS711X	33
+#define PORT_SA1100	34
+#define PORT_UART00	35
+#define PORT_21285	37
+
+/* Sparc type numbers.  */
+#define PORT_SUNZILOG	38
+#define PORT_SUNSAB	39
+
+/* NEC v850.  */
+#define PORT_V850E_UART	40
+
+/* DZ */
+#define PORT_DZ		47
+
+/* Parisc type numbers. */
+#define PORT_MUX	48
+
+/* Macintosh Zilog type numbers */
+#define PORT_MAC_ZILOG	50	/* m68k : not yet implemented */
+#define PORT_PMAC_ZILOG	51
+
+/* SH-SCI */
+#define PORT_SCI	52
+#define PORT_SCIF	53
+#define PORT_IRDA	54
+
+/* Samsung S3C2410 SoC and derivatives thereof */
+#define PORT_S3C2410    55
+
+/* SGI IP22 aka Indy / Challenge S / Indigo 2 */
+#define PORT_IP22ZILOG	56
+
+/* Sharp LH7a40x -- an ARM9 SoC series */
+#define PORT_LH7A40X	57
+
+/* PPC CPM type number */
+#define PORT_CPM        58
+
+/* MPC52xx type numbers */
+#define PORT_MPC52xx	59
+
+/* IBM icom */
+#define PORT_ICOM	60
+
+/* Samsung S3C2440 SoC */
+#define PORT_S3C2440	61
+
+/* Motorola i.MX SoC */
+#define PORT_IMX	62
+
+/* Marvell MPSC */
+#define PORT_MPSC	63
+
+/* TXX9 type number */
+#define PORT_TXX9       64
+
+/* NEC VR4100 series SIU/DSIU */
+#define PORT_VR41XX_SIU		65
+#define PORT_VR41XX_DSIU	66
+
+/* Samsung S3C2400 SoC */
+#define PORT_S3C2400	67
+
+/* M32R SIO */
+#define PORT_M32R_SIO	68
+
+/*Digi jsm */
+#define PORT_JSM        65
+
+#ifdef __KERNEL__
+
+#include <linux/config.h>
+#include <linux/interrupt.h>
+#include <linux/circ_buf.h>
+#include <linux/spinlock.h>
+#include <linux/sched.h>
+#include <linux/tty.h>
+
+struct uart_port;
+struct uart_info;
+struct serial_struct;
+struct device;
+
+/*
+ * This structure describes all the operations that can be
+ * done on the physical hardware.
+ */
+struct uart_ops {
+	unsigned int	(*tx_empty)(struct uart_port *);
+	void		(*set_mctrl)(struct uart_port *, unsigned int mctrl);
+	unsigned int	(*get_mctrl)(struct uart_port *);
+	void		(*stop_tx)(struct uart_port *, unsigned int tty_stop);
+	void		(*start_tx)(struct uart_port *, unsigned int tty_start);
+	void		(*send_xchar)(struct uart_port *, char ch);
+	void		(*stop_rx)(struct uart_port *);
+	void		(*enable_ms)(struct uart_port *);
+	void		(*break_ctl)(struct uart_port *, int ctl);
+	int		(*startup)(struct uart_port *);
+	void		(*shutdown)(struct uart_port *);
+	void		(*set_termios)(struct uart_port *, struct termios *new,
+				       struct termios *old);
+	void		(*pm)(struct uart_port *, unsigned int state,
+			      unsigned int oldstate);
+	int		(*set_wake)(struct uart_port *, unsigned int state);
+
+	/*
+	 * Return a string describing the type of the port
+	 */
+	const char *(*type)(struct uart_port *);
+
+	/*
+	 * Release IO and memory resources used by the port.
+	 * This includes iounmap if necessary.
+	 */
+	void		(*release_port)(struct uart_port *);
+
+	/*
+	 * Request IO and memory resources used by the port.
+	 * This includes iomapping the port if necessary.
+	 */
+	int		(*request_port)(struct uart_port *);
+	void		(*config_port)(struct uart_port *, int);
+	int		(*verify_port)(struct uart_port *, struct serial_struct *);
+	int		(*ioctl)(struct uart_port *, unsigned int, unsigned long);
+};
+
+#define UART_CONFIG_TYPE	(1 << 0)
+#define UART_CONFIG_IRQ		(1 << 1)
+
+struct uart_icount {
+	__u32	cts;
+	__u32	dsr;
+	__u32	rng;
+	__u32	dcd;
+	__u32	rx;
+	__u32	tx;
+	__u32	frame;
+	__u32	overrun;
+	__u32	parity;
+	__u32	brk;
+	__u32	buf_overrun;
+};
+
+struct uart_port {
+	spinlock_t		lock;			/* port lock */
+	unsigned int		iobase;			/* in/out[bwl] */
+	unsigned char __iomem	*membase;		/* read/write[bwl] */
+	unsigned int		irq;			/* irq number */
+	unsigned int		uartclk;		/* base uart clock */
+	unsigned char		fifosize;		/* tx fifo size */
+	unsigned char		x_char;			/* xon/xoff char */
+	unsigned char		regshift;		/* reg offset shift */
+	unsigned char		iotype;			/* io access style */
+
+#define UPIO_PORT		(0)
+#define UPIO_HUB6		(1)
+#define UPIO_MEM		(2)
+#define UPIO_MEM32		(3)
+
+	unsigned int		read_status_mask;	/* driver specific */
+	unsigned int		ignore_status_mask;	/* driver specific */
+	struct uart_info	*info;			/* pointer to parent info */
+	struct uart_icount	icount;			/* statistics */
+
+	struct console		*cons;			/* struct console, if any */
+#ifdef CONFIG_SERIAL_CORE_CONSOLE
+	unsigned long		sysrq;			/* sysrq timeout */
+#endif
+
+	unsigned int		flags;
+
+#define UPF_FOURPORT		(1 << 1)
+#define UPF_SAK			(1 << 2)
+#define UPF_SPD_MASK		(0x1030)
+#define UPF_SPD_HI		(0x0010)
+#define UPF_SPD_VHI		(0x0020)
+#define UPF_SPD_CUST		(0x0030)
+#define UPF_SPD_SHI		(0x1000)
+#define UPF_SPD_WARP		(0x1010)
+#define UPF_SKIP_TEST		(1 << 6)
+#define UPF_AUTO_IRQ		(1 << 7)
+#define UPF_HARDPPS_CD		(1 << 11)
+#define UPF_LOW_LATENCY		(1 << 13)
+#define UPF_BUGGY_UART		(1 << 14)
+#define UPF_AUTOPROBE		(1 << 15)
+#define UPF_MAGIC_MULTIPLIER	(1 << 16)
+#define UPF_BOOT_ONLYMCA	(1 << 22)
+#define UPF_CONS_FLOW		(1 << 23)
+#define UPF_SHARE_IRQ		(1 << 24)
+#define UPF_BOOT_AUTOCONF	(1 << 28)
+#define UPF_IOREMAP		(1 << 31)
+
+#define UPF_CHANGE_MASK		(0x17fff)
+#define UPF_USR_MASK		(UPF_SPD_MASK|UPF_LOW_LATENCY)
+
+	unsigned int		mctrl;			/* current modem ctrl settings */
+	unsigned int		timeout;		/* character-based timeout */
+	unsigned int		type;			/* port type */
+	struct uart_ops		*ops;
+	unsigned int		custom_divisor;
+	unsigned int		line;			/* port index */
+	unsigned long		mapbase;		/* for ioremap */
+	struct device		*dev;			/* parent device */
+	unsigned char		hub6;			/* this should be in the 8250 driver */
+	unsigned char		unused[3];
+};
+
+/*
+ * This is the state information which is persistent across opens.
+ * The low level driver must not to touch any elements contained
+ * within.
+ */
+struct uart_state {
+	unsigned int		close_delay;		/* msec */
+	unsigned int		closing_wait;		/* msec */
+
+#define USF_CLOSING_WAIT_INF	(0)
+#define USF_CLOSING_WAIT_NONE	(~0U)
+
+	int			count;
+	int			pm_state;
+	struct uart_info	*info;
+	struct uart_port	*port;
+
+	struct semaphore	sem;
+};
+
+#define UART_XMIT_SIZE	PAGE_SIZE
+/*
+ * This is the state information which is only valid when the port
+ * is open; it may be freed by the core driver once the device has
+ * been closed.  Either the low level driver or the core can modify
+ * stuff here.
+ */
+struct uart_info {
+	struct tty_struct	*tty;
+	struct circ_buf		xmit;
+	unsigned int		flags;
+
+/*
+ * These are the flags that specific to info->flags, and reflect our
+ * internal state.  They can not be accessed via port->flags.  Low
+ * level drivers must not change these, but may query them instead.
+ */
+#define UIF_CHECK_CD		(1 << 25)
+#define UIF_CTS_FLOW		(1 << 26)
+#define UIF_NORMAL_ACTIVE	(1 << 29)
+#define UIF_INITIALIZED		(1 << 31)
+
+	int			blocked_open;
+
+	struct tasklet_struct	tlet;
+
+	wait_queue_head_t	open_wait;
+	wait_queue_head_t	delta_msr_wait;
+};
+
+/* number of characters left in xmit buffer before we ask for more */
+#define WAKEUP_CHARS		256
+
+struct module;
+struct tty_driver;
+
+struct uart_driver {
+	struct module		*owner;
+	const char		*driver_name;
+	const char		*dev_name;
+	const char		*devfs_name;
+	int			 major;
+	int			 minor;
+	int			 nr;
+	struct console		*cons;
+
+	/*
+	 * these are private; the low level driver should not
+	 * touch these; they should be initialised to NULL
+	 */
+	struct uart_state	*state;
+	struct tty_driver	*tty_driver;
+};
+
+void uart_write_wakeup(struct uart_port *port);
+
+/*
+ * Baud rate helpers.
+ */
+void uart_update_timeout(struct uart_port *port, unsigned int cflag,
+			 unsigned int baud);
+unsigned int uart_get_baud_rate(struct uart_port *port, struct termios *termios,
+				struct termios *old, unsigned int min,
+				unsigned int max);
+unsigned int uart_get_divisor(struct uart_port *port, unsigned int baud);
+
+/*
+ * Console helpers.
+ */
+struct uart_port *uart_get_console(struct uart_port *ports, int nr,
+				   struct console *c);
+void uart_parse_options(char *options, int *baud, int *parity, int *bits,
+			int *flow);
+int uart_set_options(struct uart_port *port, struct console *co, int baud,
+		     int parity, int bits, int flow);
+struct tty_driver *uart_console_device(struct console *co, int *index);
+
+/*
+ * Port/driver registration/removal
+ */
+int uart_register_driver(struct uart_driver *uart);
+void uart_unregister_driver(struct uart_driver *uart);
+void uart_unregister_port(struct uart_driver *reg, int line);
+int uart_register_port(struct uart_driver *reg, struct uart_port *port);
+int uart_add_one_port(struct uart_driver *reg, struct uart_port *port);
+int uart_remove_one_port(struct uart_driver *reg, struct uart_port *port);
+int uart_match_port(struct uart_port *port1, struct uart_port *port2);
+
+/*
+ * Power Management
+ */
+int uart_suspend_port(struct uart_driver *reg, struct uart_port *port);
+int uart_resume_port(struct uart_driver *reg, struct uart_port *port);
+
+#define uart_circ_empty(circ)		((circ)->head == (circ)->tail)
+#define uart_circ_clear(circ)		((circ)->head = (circ)->tail = 0)
+
+#define uart_circ_chars_pending(circ)	\
+	(CIRC_CNT((circ)->head, (circ)->tail, UART_XMIT_SIZE))
+
+#define uart_circ_chars_free(circ)	\
+	(CIRC_SPACE((circ)->head, (circ)->tail, UART_XMIT_SIZE))
+
+#define uart_tx_stopped(port)		\
+	((port)->info->tty->stopped || (port)->info->tty->hw_stopped)
+
+/*
+ * The following are helper functions for the low level drivers.
+ */
+#ifdef SUPPORT_SYSRQ
+static inline int
+uart_handle_sysrq_char(struct uart_port *port, unsigned int ch,
+		       struct pt_regs *regs)
+{
+	if (port->sysrq) {
+		if (ch && time_before(jiffies, port->sysrq)) {
+			handle_sysrq(ch, regs, NULL);
+			port->sysrq = 0;
+			return 1;
+		}
+		port->sysrq = 0;
+	}
+	return 0;
+}
+#else
+#define uart_handle_sysrq_char(port,ch,regs)	(0)
+#endif
+
+/*
+ * We do the SysRQ and SAK checking like this...
+ */
+static inline int uart_handle_break(struct uart_port *port)
+{
+	struct uart_info *info = port->info;
+#ifdef SUPPORT_SYSRQ
+	if (port->cons && port->cons->index == port->line) {
+		if (!port->sysrq) {
+			port->sysrq = jiffies + HZ*5;
+			return 1;
+		}
+		port->sysrq = 0;
+	}
+#endif
+	if (info->flags & UPF_SAK)
+		do_SAK(info->tty);
+	return 0;
+}
+
+/**
+ *	uart_handle_dcd_change - handle a change of carrier detect state
+ *	@port: uart_port structure for the open port
+ *	@status: new carrier detect status, nonzero if active
+ */
+static inline void
+uart_handle_dcd_change(struct uart_port *port, unsigned int status)
+{
+	struct uart_info *info = port->info;
+
+	port->icount.dcd++;
+
+#ifdef CONFIG_HARD_PPS
+	if ((port->flags & UPF_HARDPPS_CD) && status)
+		hardpps();
+#endif
+
+	if (info->flags & UIF_CHECK_CD) {
+		if (status)
+			wake_up_interruptible(&info->open_wait);
+		else if (info->tty)
+			tty_hangup(info->tty);
+	}
+}
+
+/**
+ *	uart_handle_cts_change - handle a change of clear-to-send state
+ *	@port: uart_port structure for the open port
+ *	@status: new clear to send status, nonzero if active
+ */
+static inline void
+uart_handle_cts_change(struct uart_port *port, unsigned int status)
+{
+	struct uart_info *info = port->info;
+	struct tty_struct *tty = info->tty;
+
+	port->icount.cts++;
+
+	if (info->flags & UIF_CTS_FLOW) {
+		if (tty->hw_stopped) {
+			if (status) {
+				tty->hw_stopped = 0;
+				port->ops->start_tx(port, 0);
+				uart_write_wakeup(port);
+			}
+		} else {
+			if (!status) {
+				tty->hw_stopped = 1;
+				port->ops->stop_tx(port, 0);
+			}
+		}
+	}
+}
+
+/*
+ *	UART_ENABLE_MS - determine if port should enable modem status irqs
+ */
+#define UART_ENABLE_MS(port,cflag)	((port)->flags & UPF_HARDPPS_CD || \
+					 (cflag) & CRTSCTS || \
+					 !((cflag) & CLOCAL))
+
+#endif
+
+#endif /* LINUX_SERIAL_CORE_H */
